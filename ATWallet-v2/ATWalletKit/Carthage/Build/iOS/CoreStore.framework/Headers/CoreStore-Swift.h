#ifndef TARGET_OS_SIMULATOR
#include <TargetConditionals.h>
#endif
#if TARGET_OS_SIMULATOR
#if 0
#elif defined(__x86_64__) && __x86_64__
// Generated by Apple Swift version 5.1.3 (swiftlang-1100.0.282.1 clang-1100.0.33.15)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if !defined(IBSegueAction)
# define IBSegueAction
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import CoreData;
@import Foundation;
@import ObjectiveC;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="CoreStore",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif



@class CSInto;
@class NSManagedObject;
@class NSManagedObjectID;

/// The <code>CSBaseDataTransaction</code> serves as the Objective-C bridging type for <code>BaseDataTransaction</code>.
/// seealso:
/// <code>BaseDataTransaction</code>
SWIFT_CLASS("_TtC9CoreStore21CSBaseDataTransaction")
@interface CSBaseDataTransaction : NSObject
/// Indicates if the transaction has pending changes
@property (nonatomic, readonly) BOOL hasChanges;
/// Creates a new <code>NSManagedObject</code> with the specified entity type.
/// \param into the <code>CSInto</code> clause indicating the destination <code>NSManagedObject</code> entity type and the destination configuration
///
///
/// returns:
/// a new <code>NSManagedObject</code> instance of the specified entity type.
- (id _Nonnull)createInto:(CSInto * _Nonnull)into SWIFT_WARN_UNUSED_RESULT;
/// Returns an editable proxy of a specified <code>NSManagedObject</code>.
/// \param object the <code>NSManagedObject</code> type to be edited
///
///
/// returns:
/// an editable proxy for the specified <code>NSManagedObject</code>.
- (id _Nullable)editObject:(NSManagedObject * _Nullable)object SWIFT_WARN_UNUSED_RESULT;
/// Returns an editable proxy of the object with the specified <code>NSManagedObjectID</code>.
/// \param into a <code>CSInto</code> clause specifying the entity type
///
/// \param objectID the <code>NSManagedObjectID</code> for the object to be edited
///
///
/// returns:
/// an editable proxy for the specified <code>NSManagedObject</code>.
- (id _Nullable)editInto:(CSInto * _Nonnull)into objectID:(NSManagedObjectID * _Nonnull)objectID SWIFT_WARN_UNUSED_RESULT;
/// Deletes a specified <code>NSManagedObject</code>.
/// \param object the <code>NSManagedObject</code> to be deleted
///
- (void)deleteObject:(NSManagedObject * _Nullable)object;
/// Deletes the specified <code>NSManagedObject</code>s.
/// \param objects the <code>NSManagedObject</code>s to be deleted
///
- (void)deleteObjects:(NSArray<NSManagedObject *> * _Nonnull)objects;
/// Refreshes all registered objects <code>NSManagedObject</code>s in the transaction.
- (void)refreshAndMergeAllObjects;
/// Returns all pending <code>NSManagedObject</code>s of the specified type that were inserted to the transaction. This method should not be called after the <code>-commit*:</code> method was called.
/// \param entity the <code>NSManagedObject</code> subclass to filter
///
///
/// returns:
/// an <code>NSSet</code> of pending <code>NSManagedObject</code>s of the specified type that were inserted to the transaction.
- (NSSet<NSManagedObject *> * _Nonnull)insertedObjectsOfType:(SWIFT_METATYPE(NSManagedObject) _Nonnull)entity SWIFT_WARN_UNUSED_RESULT;
/// Returns all pending <code>NSManagedObjectID</code>s that were inserted to the transaction. This method should not be called after the <code>-commit*:</code> method was called.
///
/// returns:
/// an <code>NSSet</code> of pending <code>NSManagedObjectID</code>s that were inserted to the transaction.
- (NSSet<NSManagedObjectID *> * _Nonnull)insertedObjectIDs SWIFT_WARN_UNUSED_RESULT;
/// Returns all pending <code>NSManagedObjectID</code>s of the specified type that were inserted to the transaction. This method should not be called after the <code>-commit*:</code> method was called.
/// \param entity the <code>NSManagedObject</code> subclass to filter
///
///
/// returns:
/// an <code>NSSet</code> of pending <code>NSManagedObjectID</code>s of the specified type that were inserted to the transaction.
- (NSSet<NSManagedObjectID *> * _Nonnull)insertedObjectIDsOfType:(SWIFT_METATYPE(NSManagedObject) _Nonnull)entity SWIFT_WARN_UNUSED_RESULT;
/// Returns all pending <code>NSManagedObject</code>s of the specified type that were updated in the transaction. This method should not be called after the <code>-commit*:</code> method was called.
/// \param entity the <code>NSManagedObject</code> subclass to filter
///
///
/// returns:
/// an <code>NSSet</code> of pending <code>NSManagedObject</code>s of the specified type that were updated in the transaction.
- (NSSet<NSManagedObject *> * _Nonnull)updatedObjectsOfType:(SWIFT_METATYPE(NSManagedObject) _Nonnull)entity SWIFT_WARN_UNUSED_RESULT;
/// Returns all pending <code>NSManagedObjectID</code>s that were updated in the transaction. This method should not be called after the <code>-commit*:</code> method was called.
///
/// returns:
/// an <code>NSSet</code> of pending <code>NSManagedObjectID</code>s that were updated in the transaction.
- (NSSet<NSManagedObjectID *> * _Nonnull)updatedObjectIDs SWIFT_WARN_UNUSED_RESULT;
/// Returns all pending <code>NSManagedObjectID</code>s of the specified type that were updated in the transaction. This method should not be called after the <code>-commit*:</code> method was called.
/// \param entity the <code>NSManagedObject</code> subclass to filter
///
///
/// returns:
/// an <code>NSSet</code> of pending <code>NSManagedObjectID</code>s of the specified type that were updated in the transaction.
- (NSSet<NSManagedObjectID *> * _Nonnull)updatedObjectIDsOfType:(SWIFT_METATYPE(NSManagedObject) _Nonnull)entity SWIFT_WARN_UNUSED_RESULT;
/// Returns all pending <code>NSManagedObject</code>s of the specified type that were deleted from the transaction. This method should not be called after the <code>-commit*:</code> method was called.
/// \param entity the <code>NSManagedObject</code> subclass to filter
///
///
/// returns:
/// an <code>NSSet</code> of pending <code>NSManagedObject</code>s of the specified type that were deleted from the transaction.
- (NSSet<NSManagedObject *> * _Nonnull)deletedObjectsOfType:(SWIFT_METATYPE(NSManagedObject) _Nonnull)entity SWIFT_WARN_UNUSED_RESULT;
/// Returns all pending <code>NSManagedObjectID</code>s of the specified type that were deleted from the transaction. This method should not be called after the <code>-commit*:</code> method was called.
///
/// returns:
/// an <code>NSSet</code> of pending <code>NSManagedObjectID</code>s of the specified type that were deleted from the transaction.
- (NSSet<NSManagedObjectID *> * _Nonnull)deletedObjectIDs SWIFT_WARN_UNUSED_RESULT;
/// Returns all pending <code>NSManagedObjectID</code>s of the specified type that were deleted from the transaction. This method should not be called after the <code>-commit*:</code> method was called.
/// \param entity the <code>NSManagedObject</code> subclass to filter
///
///
/// returns:
/// a <code>Set</code> of pending <code>NSManagedObjectID</code>s of the specified type that were deleted from the transaction.
- (NSSet<NSManagedObjectID *> * _Nonnull)deletedObjectIDsOfType:(SWIFT_METATYPE(NSManagedObject) _Nonnull)entity SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class CSError;

/// The <code>CSAsynchronousDataTransaction</code> serves as the Objective-C bridging type for <code>AsynchronousDataTransaction</code>.
/// seealso:
/// <code>AsynchronousDataTransaction</code>
SWIFT_CLASS("_TtC9CoreStore29CSAsynchronousDataTransaction") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSAsynchronousDataTransaction : CSBaseDataTransaction
/// Saves the transaction changes. This method should not be used after the <code>-commitWithCompletion:</code> method was already called once.
/// \param success the block executed if the save succeeds.
///
/// \param failure the block executed if the save fails. A <code>CSError</code> is reported as the argument of the block.
///
- (void)commitWithSuccess:(void (^ _Nullable)(void))success failure:(void (^ _Nullable)(CSError * _Nonnull))failure;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
/// Creates a new <code>NSManagedObject</code> with the specified entity type.
/// \param into the <code>CSInto</code> clause indicating the destination <code>NSManagedObject</code> entity type and the destination configuration
///
///
/// returns:
/// a new <code>NSManagedObject</code> instance of the specified entity type.
- (id _Nonnull)createInto:(CSInto * _Nonnull)into SWIFT_WARN_UNUSED_RESULT;
/// Returns an editable proxy of a specified <code>NSManagedObject</code>. This method should not be used after the <code>-commitWithCompletion:</code> method was already called once.
/// \param object the <code>NSManagedObject</code> type to be edited
///
///
/// returns:
/// an editable proxy for the specified <code>NSManagedObject</code>.
- (id _Nullable)editObject:(NSManagedObject * _Nullable)object SWIFT_WARN_UNUSED_RESULT;
/// Returns an editable proxy of the object with the specified <code>NSManagedObjectID</code>. This method should not be used after the <code>-commitWithCompletion:</code> method was already called once.
/// \param into a <code>CSInto</code> clause specifying the entity type
///
/// \param objectID the <code>NSManagedObjectID</code> for the object to be edited
///
///
/// returns:
/// an editable proxy for the specified <code>NSManagedObject</code>.
- (id _Nullable)editInto:(CSInto * _Nonnull)into objectID:(NSManagedObjectID * _Nonnull)objectID SWIFT_WARN_UNUSED_RESULT;
/// Deletes a specified <code>NSManagedObject</code>. This method should not be used after the <code>-commitWithCompletion:</code> method was already called once.
/// \param object the <code>NSManagedObject</code> type to be deleted
///
- (void)deleteObject:(NSManagedObject * _Nullable)object;
/// Deletes the specified <code>NSManagedObject</code>s.
/// \param objects the <code>NSManagedObject</code>s type to be deleted
///
- (void)deleteObjects:(NSArray<NSManagedObject *> * _Nonnull)objects;
@end


@class CSFrom;
@protocol CSFetchClause;
@class NSNumber;
@class CSSelect;
@protocol CSQueryClause;

@interface CSBaseDataTransaction (SWIFT_EXTENSION(CoreStore))
/// Fetches the <code>NSManagedObject</code> instance in the transaction’s context from a reference created from a transaction or from a different managed object context.
/// \param object a reference to the object created/fetched outside the transaction
///
///
/// returns:
/// the <code>NSManagedObject</code> instance if the object exists in the transaction, or <code>nil</code> if not found.
- (id _Nullable)fetchExistingObject:(NSManagedObject * _Nonnull)object SWIFT_WARN_UNUSED_RESULT;
/// Fetches the <code>NSManagedObject</code> instance in the transaction’s context from an <code>NSManagedObjectID</code>.
/// \param objectID the <code>NSManagedObjectID</code> for the object
///
///
/// returns:
/// the <code>NSManagedObject</code> instance if the object exists in the transaction, or <code>nil</code> if not found.
- (id _Nullable)fetchExistingObjectWithID:(NSManagedObjectID * _Nonnull)objectID SWIFT_WARN_UNUSED_RESULT;
/// Fetches the <code>NSManagedObject</code> instances in the transaction’s context from references created from a transaction or from a different managed object context.
/// \param objects an array of <code>NSManagedObject</code>s created/fetched outside the transaction
///
///
/// returns:
/// the <code>NSManagedObject</code> array for objects that exists in the transaction
- (NSArray * _Nonnull)fetchExistingObjects:(NSArray<NSManagedObject *> * _Nonnull)objects SWIFT_WARN_UNUSED_RESULT;
/// Fetches the <code>NSManagedObject</code> instances in the transaction’s context from a list of <code>NSManagedObjectID</code>.
/// \param objectIDs the <code>NSManagedObjectID</code> array for the objects
///
///
/// returns:
/// the <code>NSManagedObject</code> array for objects that exists in the transaction
- (NSArray * _Nonnull)fetchExistingObjectsWithIDs:(NSArray<NSManagedObjectID *> * _Nonnull)objectIDs SWIFT_WARN_UNUSED_RESULT;
/// Fetches the first <code>NSManagedObject</code> instance that satisfies the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>From</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the first <code>NSManagedObject</code> instance that satisfies the specified <code>CSFetchClause</code>s
- (id _Nullable)fetchOneFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Fetches all <code>NSManagedObject</code> instances that satisfy the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// all <code>NSManagedObject</code> instances that satisfy the specified <code>CSFetchClause</code>s
- (NSArray * _Nullable)fetchAllFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Fetches the number of <code>NSManagedObject</code>s that satisfy the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the number <code>NSManagedObject</code>s that satisfy the specified <code>CSFetchClause</code>s
- (NSNumber * _Nullable)fetchCountFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Fetches the <code>NSManagedObjectID</code> for the first <code>NSManagedObject</code> that satisfies the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the <code>NSManagedObjectID</code> for the first <code>NSManagedObject</code> that satisfies the specified <code>CSFetchClause</code>s
- (NSManagedObjectID * _Nullable)fetchObjectIDFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Queries aggregate values as specified by the <code>CSQueryClause</code>s. Requires at least a <code>CSSelect</code> clause, and optional <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
/// A “query” differs from a “fetch” in that it only retrieves values already stored in the persistent store. As such, values from unsaved transactions or contexts will not be incorporated in the query result.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param selectClause a <code>CSSelect</code> clause indicating the properties to fetch, and with the generic type indicating the return type.
///
/// \param queryClauses a series of <code>CSQueryClause</code> instances for the query request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the result of the the query. The type of the return value is specified by the generic type of the <code>CSSelect</code> parameter.
- (id _Nullable)queryValueFrom:(CSFrom * _Nonnull)from selectClause:(CSSelect * _Nonnull)selectClause queryClauses:(NSArray<id <CSQueryClause>> * _Nonnull)queryClauses SWIFT_WARN_UNUSED_RESULT;
/// Queries a dictionary of attribute values as specified by the <code>CSQueryClause</code>s. Requires at least a <code>CSSelect</code> clause, and optional <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
/// A “query” differs from a “fetch” in that it only retrieves values already stored in the persistent store. As such, values from unsaved transactions or contexts will not be incorporated in the query result.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param selectClause a <code>CSSelect</code> clause indicating the properties to fetch, and with the generic type indicating the return type.
///
/// \param queryClauses a series of <code>CSQueryClause</code> instances for the query request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the result of the the query. The type of the return value is specified by the generic type of the <code>CSSelect</code> parameter.
- (NSArray<NSDictionary<NSString *, id> *> * _Nullable)queryAttributesFrom:(CSFrom * _Nonnull)from selectClause:(CSSelect * _Nonnull)selectClause queryClauses:(NSArray<id <CSQueryClause>> * _Nonnull)queryClauses SWIFT_WARN_UNUSED_RESULT;
@end

@class CSDataStack;

/// The <code>CSCoreStore</code> serves as the Objective-C bridging type for <code>CoreStore</code>.
/// seealso:
/// <code>CoreStore</code>
SWIFT_CLASS("_TtC9CoreStore11CSCoreStore") SWIFT_DEPRECATED_MSG("Call methods directly from the CSDataStack instead")
@interface CSCoreStore : NSObject
/// The default <code>CSDataStack</code> instance to be used. If <code>defaultStack</code> is not set before the first time accessed, a default-configured <code>CSDataStack</code> will be created.
/// seealso:
/// <code>CSDataStack</code>
/// note:
/// Changing the <code>defaultStack</code> is thread safe, but it is recommended to setup <code>CSDataStacks</code> on a common queue (e.g. the main queue).
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) CSDataStack * _Nonnull defaultStack;)
+ (CSDataStack * _Nonnull)defaultStack SWIFT_WARN_UNUSED_RESULT;
+ (void)setDefaultStack:(CSDataStack * _Nonnull)newValue;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class CSSQLiteStore;
@class CSMigrationResult;
@class NSError;
@class NSProgress;
@class CSMigrationType;

SWIFT_DEPRECATED_MSG("Call methods directly from the CSDataStack instead")
@interface CSCoreStore (SWIFT_EXTENSION(CoreStore))
/// Migrates a <code>CSSQLiteStore</code> to match the <code>defaultStack</code>’s managed object model version. This method does NOT add the migrated store to the data stack.
/// \param storage the <code>CSSQLiteStore</code> instance
///
/// \param completion the closure to be executed on the main queue when the migration completes, either due to success or failure. The closure’s <code>CSMigrationResult</code> argument indicates the result. This closure is NOT executed if an error is thrown, but will be executed with a failure <code>CSSetupResult</code> result if an error occurs asynchronously.
///
/// \param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// an <code>NSProgress</code> instance if a migration has started. <code>nil</code> if no migrations are required or if <code>error</code> was set.
+ (NSProgress * _Nullable)upgradeStorageIfNeeded:(CSSQLiteStore * _Nonnull)storage completion:(void (^ _Nonnull)(CSMigrationResult * _Nonnull))completion error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
/// Checks the migration steps required for the <code>CSSQLiteStore</code> to match the <code>defaultStack</code>’s managed object model version.
/// \param storage the <code>CSSQLiteStore</code> instance
///
/// \param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// a <code>CSMigrationType</code> array indicating the migration steps required for the store, or an empty array if the file does not exist yet. Otherwise, <code>nil</code> is returned and the <code>error</code> argument is set if either inspection of the store failed, or if no mapping model was found/inferred.
+ (NSArray<CSMigrationType *> * _Nullable)requiredMigrationsForSQLiteStore:(CSSQLiteStore * _Nonnull)storage error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
@end

@class CSObjectMonitor;
@class CSListMonitor;
@class CSSectionBy;

SWIFT_AVAILABILITY(macos,introduced=10.12) SWIFT_DEPRECATED_MSG("Call methods directly from the CSDataStack instead")
@interface CSCoreStore (SWIFT_EXTENSION(CoreStore))
/// Using the <code>defaultStack</code>, creates an <code>CSObjectMonitor</code> for the specified <code>NSManagedObject</code>. Multiple <code>CSObjectObserver</code>s may then register themselves to be notified when changes are made to the <code>NSManagedObject</code>.
/// \param object the <code>NSManagedObject</code> to observe changes from
///
///
/// returns:
/// a <code>CSObjectMonitor</code> that monitors changes to <code>object</code>
+ (CSObjectMonitor * _Nonnull)monitorObject:(NSManagedObject * _Nonnull)object SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, creates a <code>CSListMonitor</code> for a list of <code>NSManagedObject</code>s that satisfy the specified fetch clauses. Multiple <code>CSListObserver</code>s may then register themselves to be notified when changes are made to the list.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for fetching the object list. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// a <code>CSListMonitor</code> instance that monitors changes to the list
+ (CSListMonitor * _Nonnull)monitorListFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, asynchronously creates a <code>CSListMonitor</code> for a list of <code>NSManagedObject</code>s that satisfy the specified fetch clauses. Multiple <code>CSListObserver</code>s may then register themselves to be notified when changes are made to the list. Since <code>NSFetchedResultsController</code> greedily locks the persistent store on initial fetch, you may prefer this method instead of the synchronous counterpart to avoid deadlocks while background updates/saves are being executed.
/// \param createAsynchronously the closure that receives the created <code>CSListMonitor</code> instance
///
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for fetching the object list. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
+ (void)monitorListByCreatingAsynchronously:(void (^ _Nonnull)(CSListMonitor * _Nonnull))createAsynchronously from:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses;
/// Using the <code>defaultStack</code>, creates a <code>CSListMonitor</code> for a sectioned list of <code>NSManagedObject</code>s that satisfy the specified fetch clauses. Multiple <code>CSListObserver</code>s may then register themselves to be notified when changes are made to the list.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param sectionBy a <code>CSSectionBy</code> clause indicating the keyPath for the attribute to use when sorting the list into sections.
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for fetching the object list. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// a <code>CSListMonitor</code> instance that monitors changes to the list
+ (CSListMonitor * _Nonnull)monitorSectionedListFrom:(CSFrom * _Nonnull)from sectionBy:(CSSectionBy * _Nonnull)sectionBy fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, asynchronously creates a <code>CSListMonitor</code> for a sectioned list of <code>NSManagedObject</code>s that satisfy the specified fetch clauses. Multiple <code>CSListObserver</code>s may then register themselves to be notified when changes are made to the list. Since <code>NSFetchedResultsController</code> greedily locks the persistent store on initial fetch, you may prefer this method instead of the synchronous counterpart to avoid deadlocks while background updates/saves are being executed.
/// \param createAsynchronously the closure that receives the created <code>CSListMonitor</code> instance
///
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param sectionBy a <code>CSSectionBy</code> clause indicating the keyPath for the attribute to use when sorting the list into sections.
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for fetching the object list. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
+ (void)monitorSectionedListByCreatingAsynchronously:(void (^ _Nonnull)(CSListMonitor * _Nonnull))createAsynchronously from:(CSFrom * _Nonnull)from sectionBy:(CSSectionBy * _Nonnull)sectionBy fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses;
@end

@class CSSynchronousDataTransaction;
@class CSUnsafeDataTransaction;

SWIFT_DEPRECATED_MSG("Call methods directly from the CSDataStack instead")
@interface CSCoreStore (SWIFT_EXTENSION(CoreStore))
/// Using the <code>defaultStack</code>, begins a transaction asynchronously where <code>NSManagedObject</code> creates, updates, and deletes can be made.
/// \param closure the block where creates, updates, and deletes can be made to the transaction. Transaction blocks are executed serially in a background queue, and all changes are made from a concurrent <code>NSManagedObjectContext</code>.
///
+ (void)beginAsynchronous:(void (^ _Nonnull)(CSAsynchronousDataTransaction * _Nonnull))closure;
/// Using the <code>defaultStack</code>, begins a transaction synchronously where <code>NSManagedObject</code> creates, updates, and deletes can be made.
/// \param closure the block where creates, updates, and deletes can be made to the transaction. Transaction blocks are executed serially in a background queue, and all changes are made from a concurrent <code>NSManagedObjectContext</code>.
///
///
/// returns:
/// <code>YES</code> if the commit succeeded, <code>NO</code> if the commit failed. If <code>NO</code>, the <code>error</code> argument will hold error information.
+ (BOOL)beginSynchronous:(void (^ _Nonnull)(CSSynchronousDataTransaction * _Nonnull))closure error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, begins a child transaction where <code>NSManagedObject</code> creates, updates, and deletes can be made. This is useful for making temporary changes, such as partially filled forms.
/// To support “undo” methods such as <code>-undo</code>, <code>-redo</code>, and <code>-rollback</code>, use the <code>-beginSafeWithSupportsUndo:</code> method passing <code>YES</code> to the argument. Without “undo” support, calling those methods will raise an exception.
///
/// returns:
/// a <code>CSUnsafeDataTransaction</code> instance where creates, updates, and deletes can be made.
+ (CSUnsafeDataTransaction * _Nonnull)beginUnsafe SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, begins a child transaction where <code>NSManagedObject</code> creates, updates, and deletes can be made. This is useful for making temporary changes, such as partially filled forms.
/// <ul>
///   <li>
///     prameter supportsUndo: <code>-undo</code>, <code>-redo</code>, and <code>-rollback</code> methods are only available when this parameter is <code>YES</code>, otherwise those method will raise an exception. Note that turning on Undo support may heavily impact performance especially on iOS or watchOS where memory is limited.
///   </li>
/// </ul>
///
/// returns:
/// a <code>CSUnsafeDataTransaction</code> instance where creates, updates, and deletes can be made.
+ (CSUnsafeDataTransaction * _Nonnull)beginUnsafeWithSupportsUndo:(BOOL)supportsUndo SWIFT_WARN_UNUSED_RESULT;
/// Refreshes all registered objects <code>NSManagedObject</code>s in the <code>defaultStack</code>.
+ (void)refreshAndMergeAllObjects;
@end

@class NSEntityDescription;
@class CSInMemoryStore;

SWIFT_DEPRECATED_MSG("Call methods directly from the CSDataStack instead")
@interface CSCoreStore (SWIFT_EXTENSION(CoreStore))
/// Returns the <code>defaultStack</code>’s model version. The version string is the same as the name of the version-specific .xcdatamodeld file.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull modelVersion;)
+ (NSString * _Nonnull)modelVersion SWIFT_WARN_UNUSED_RESULT;
/// Returns the entity name-to-class type mapping from the <code>defaultStack</code>’s model.
+ (NSDictionary<NSString *, SWIFT_METATYPE(NSManagedObject)> * _Nonnull)entityTypesByNameForType:(SWIFT_METATYPE(NSManagedObject) _Nonnull)type SWIFT_WARN_UNUSED_RESULT;
/// Returns the <code>NSEntityDescription</code> for the specified <code>NSManagedObject</code> subclass from <code>defaultStack</code>’s model.
+ (NSEntityDescription * _Nullable)entityDescriptionForClass:(SWIFT_METATYPE(NSManagedObject) _Nonnull)type SWIFT_WARN_UNUSED_RESULT;
/// Creates an <code>CSInMemoryStore</code> with default parameters and adds it to the <code>defaultStack</code>. This method blocks until completion.
/// \code
/// CSSQLiteStore *storage = [CSCoreStore addInMemoryStorageAndWaitAndReturnError:&error];
///
/// \endcode\param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// the <code>CSInMemoryStore</code> added to the <code>defaultStack</code>
+ (CSInMemoryStore * _Nullable)addInMemoryStorageAndWaitAndReturnError:(NSError * _Nullable * _Nullable)error;
/// Creates an <code>CSSQLiteStore</code> with default parameters and adds it to the <code>defaultStack</code>. This method blocks until completion.
/// \code
/// CSSQLiteStore *storage = [CSCoreStore addSQLiteStorageAndWaitAndReturnError:&error];
///
/// \endcode\param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// the <code>CSSQLiteStore</code> added to the <code>defaultStack</code>
+ (CSSQLiteStore * _Nullable)addSQLiteStorageAndWaitAndReturnError:(NSError * _Nullable * _Nullable)error;
/// Adds a <code>CSInMemoryStore</code> to the <code>defaultStack</code> and blocks until completion.
/// \code
/// NSError *error;
/// CSInMemoryStore *storage = [CSCoreStore
///     addStorageAndWait: [[CSInMemoryStore alloc] initWithConfiguration: @"Config1"]
///     error: &error];
///
/// \endcode\param storage the <code>CSInMemoryStore</code>
///
/// \param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// the <code>CSInMemoryStore</code> added to the <code>defaultStack</code>
+ (CSInMemoryStore * _Nullable)addInMemoryStorageAndWait:(CSInMemoryStore * _Nonnull)storage error:(NSError * _Nullable * _Nullable)error;
/// Adds a <code>CSSQLiteStore</code> to the <code>defaultStack</code> and blocks until completion.
/// \code
/// NSError *error;
/// CSSQLiteStore *storage = [CSCoreStore
///     addStorageAndWait: [[CSSQLiteStore alloc] initWithConfiguration: @"Config1"]
///     error: &error];
///
/// \endcode\param storage the <code>CSSQLiteStore</code>
///
/// \param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// the <code>CSSQLiteStore</code> added to the <code>defaultStack</code>
+ (CSSQLiteStore * _Nullable)addSQLiteStorageAndWait:(CSSQLiteStore * _Nonnull)storage error:(NSError * _Nullable * _Nullable)error;
@end


SWIFT_DEPRECATED_MSG("Call methods directly from the DataStack instead")
@interface CSCoreStore (SWIFT_EXTENSION(CoreStore))
/// Using the <code>defaultStack</code>, fetches the <code>NSManagedObject</code> instance in the transaction’s context from a reference created from a transaction or from a different managed object context.
/// \param object a reference to the object created/fetched outside the transaction
///
///
/// returns:
/// the <code>NSManagedObject</code> instance if the object exists in the transaction, or <code>nil</code> if not found.
+ (id _Nullable)fetchExistingObject:(NSManagedObject * _Nonnull)object SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, fetches the <code>NSManagedObject</code> instance in the transaction’s context from an <code>NSManagedObjectID</code>.
/// \param objectID the <code>NSManagedObjectID</code> for the object
///
///
/// returns:
/// the <code>NSManagedObject</code> instance if the object exists in the transaction, or <code>nil</code> if not found.
+ (id _Nullable)fetchExistingObjectWithID:(NSManagedObjectID * _Nonnull)objectID SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, fetches the <code>NSManagedObject</code> instances in the transaction’s context from references created from a transaction or from a different managed object context.
/// \param objects an array of <code>NSManagedObject</code>s created/fetched outside the transaction
///
///
/// returns:
/// the <code>NSManagedObject</code> array for objects that exists in the transaction
+ (NSArray * _Nonnull)fetchExistingObjects:(NSArray<NSManagedObject *> * _Nonnull)objects SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, fetches the <code>NSManagedObject</code> instances in the transaction’s context from a list of <code>NSManagedObjectID</code>.
/// \param objectIDs the <code>NSManagedObjectID</code> array for the objects
///
///
/// returns:
/// the <code>NSManagedObject</code> array for objects that exists in the transaction
+ (NSArray * _Nonnull)fetchExistingObjectsWithIDs:(NSArray<NSManagedObjectID *> * _Nonnull)objectIDs SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, fetches the first <code>NSManagedObject</code> instance that satisfies the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>From</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the first <code>NSManagedObject</code> instance that satisfies the specified <code>CSFetchClause</code>s
+ (id _Nullable)fetchOneFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, fetches all <code>NSManagedObject</code> instances that satisfy the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// all <code>NSManagedObject</code> instances that satisfy the specified <code>CSFetchClause</code>s
+ (NSArray * _Nullable)fetchAllFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, fetches the number of <code>NSManagedObject</code>s that satisfy the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the number <code>NSManagedObject</code>s that satisfy the specified <code>CSFetchClause</code>s
+ (NSNumber * _Nullable)fetchCountFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, fetches the <code>NSManagedObjectID</code> for the first <code>NSManagedObject</code> that satisfies the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the <code>NSManagedObjectID</code> for the first <code>NSManagedObject</code> that satisfies the specified <code>CSFetchClause</code>s
+ (NSManagedObjectID * _Nullable)fetchObjectIDFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, fetches the <code>NSManagedObjectID</code> for all <code>NSManagedObject</code>s that satisfy the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>FetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the <code>NSManagedObjectID</code> for all <code>NSManagedObject</code>s that satisfy the specified <code>CSFetchClause</code>s
+ (NSArray<NSManagedObjectID *> * _Nullable)fetchObjectIDsFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, queries aggregate values as specified by the <code>CSQueryClause</code>s. Requires at least a <code>CSSelect</code> clause, and optional <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
/// A “query” differs from a “fetch” in that it only retrieves values already stored in the persistent store. As such, values from unsaved transactions or contexts will not be incorporated in the query result.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param selectClause a <code>CSSelect</code> clause indicating the properties to fetch, and with the generic type indicating the return type.
///
/// \param queryClauses a series of <code>CSQueryClause</code> instances for the query request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the result of the the query. The type of the return value is specified by the generic type of the <code>CSSelect</code> parameter.
+ (id _Nullable)queryValueFrom:(CSFrom * _Nonnull)from selectClause:(CSSelect * _Nonnull)selectClause queryClauses:(NSArray<id <CSQueryClause>> * _Nonnull)queryClauses SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, queries a dictionary of attribute values as specified by the <code>CSQueryClause</code>s. Requires at least a <code>CSSelect</code> clause, and optional <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
/// A “query” differs from a “fetch” in that it only retrieves values already stored in the persistent store. As such, values from unsaved transactions or contexts will not be incorporated in the query result.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param selectClause a <code>CSSelect</code> clause indicating the properties to fetch, and with the generic type indicating the return type.
///
/// \param queryClauses a series of <code>CSQueryClause</code> instances for the query request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the result of the the query. The type of the return value is specified by the generic type of the <code>CSSelect</code> parameter.
+ (NSArray<NSDictionary<NSString *, id> *> * _Nullable)queryAttributesFrom:(CSFrom * _Nonnull)from selectClause:(CSSelect * _Nonnull)selectClause queryClauses:(NSArray<id <CSQueryClause>> * _Nonnull)queryClauses SWIFT_WARN_UNUSED_RESULT;
@end


/// The <code>CSDataStack</code> serves as the Objective-C bridging type for <code>DataStack</code>.
/// seealso:
/// <code>DataStack</code>
SWIFT_CLASS("_TtC9CoreStore11CSDataStack") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSDataStack : NSObject
/// Initializes a <code>CSDataStack</code> with default settings. CoreStore searches for <CFBundleName>.xcdatamodeld from the main <code>NSBundle</code> and loads an <code>NSManagedObjectModel</code> from it. An assertion is raised if the model could not be found.
- (nonnull instancetype)init;
/// Initializes a <code>CSDataStack</code> from the model with the specified <code>modelName</code> in the specified <code>bundle</code>.
/// \param xcodeModelName the name of the (.xcdatamodeld) model file. If not specified, the application name (CFBundleName) will be used if it exists, or “CoreData” if it the bundle name was not set.
///
/// \param bundle an optional bundle to load .xcdatamodeld models from. If not specified, the main bundle will be used.
///
/// \param versionChain the version strings that indicate the sequence of model versions to be used as the order for progressive migrations. If not specified, will default to a non-migrating data stack.
///
- (nonnull instancetype)initWithXcodeModelName:(NSString * _Nullable)xcodeModelName bundle:(NSBundle * _Nullable)bundle versionChain:(NSArray<NSString *> * _Nullable)versionChain;
/// Returns the stack’s model version. The version string is the same as the name of the version-specific .xcdatamodeld file.
@property (nonatomic, readonly, copy) NSString * _Nonnull modelVersion;
/// Returns the entity name-to-class type mapping from the <code>CSDataStack</code>’s model.
- (NSDictionary<NSString *, SWIFT_METATYPE(NSManagedObject)> * _Nonnull)entityTypesByNameForType:(SWIFT_METATYPE(NSManagedObject) _Nonnull)type SWIFT_WARN_UNUSED_RESULT;
/// Returns the <code>NSEntityDescription</code> for the specified <code>NSManagedObject</code> subclass from stack’s model.
- (NSEntityDescription * _Nullable)entityDescriptionForClass:(SWIFT_METATYPE(NSManagedObject) _Nonnull)type SWIFT_WARN_UNUSED_RESULT;
/// Creates an <code>CSInMemoryStore</code> with default parameters and adds it to the stack. This method blocks until completion.
/// \code
/// CSSQLiteStore *storage = [dataStack addInMemoryStorageAndWaitAndReturnError:&error];
///
/// \endcode\param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// the <code>CSInMemoryStore</code> added to the stack
- (CSInMemoryStore * _Nullable)addInMemoryStorageAndWaitAndReturnError:(NSError * _Nullable * _Nullable)error;
/// Creates an <code>CSSQLiteStore</code> with default parameters and adds it to the stack. This method blocks until completion.
/// \code
/// CSSQLiteStore *storage = [dataStack addSQLiteStorageAndWaitAndReturnError:&error];
///
/// \endcode\param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// the <code>CSSQLiteStore</code> added to the stack
- (CSSQLiteStore * _Nullable)addSQLiteStorageAndWaitAndReturnError:(NSError * _Nullable * _Nullable)error;
/// Adds a <code>CSInMemoryStore</code> to the stack and blocks until completion.
/// \code
/// NSError *error;
/// CSInMemoryStore *storage = [dataStack
///     addStorageAndWait: [[CSInMemoryStore alloc] initWithConfiguration: @"Config1"]
///     error: &error];
///
/// \endcode\param storage the <code>CSInMemoryStore</code>
///
/// \param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// the <code>CSInMemoryStore</code> added to the stack
- (CSInMemoryStore * _Nullable)addInMemoryStorageAndWait:(CSInMemoryStore * _Nonnull)storage error:(NSError * _Nullable * _Nullable)error;
/// Adds a <code>CSSQLiteStore</code> to the stack and blocks until completion.
/// \code
/// NSError *error;
/// CSSQLiteStore *storage = [dataStack
///     addStorageAndWait: [[CSSQLiteStore alloc] initWithConfiguration: @"Config1"]
///     error: &error];
///
/// \endcode\param storage the <code>CSSQLiteStore</code>
///
/// \param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// the <code>CSSQLiteStore</code> added to the stack
- (CSSQLiteStore * _Nullable)addSQLiteStorageAndWait:(CSSQLiteStore * _Nonnull)storage error:(NSError * _Nullable * _Nullable)error;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
@end

@class CSSetupResult;

SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSDataStack (SWIFT_EXTENSION(CoreStore))
/// Asynchronously adds a <code>CSInMemoryStore</code> to the stack. Migrations are also initiated by default.
/// \code
/// NSError *error;
/// NSProgress *migrationProgress = [dataStack 
///     addInMemoryStorage:[CSInMemoryStore new]
///     completion:^(CSSetupResult *result) {
///         if (result.isSuccess) {
///             // ...
///         }
///     }
///     error: &error];
///
/// \endcode\param storage the <code>CSInMemoryStore</code> instance
///
/// \param completion the closure to be executed on the main queue when the process completes, either due to success or failure. The closure’s <code>CSSetupResult</code> argument indicates the result. This closure is NOT executed if an error is thrown, but will be executed with a failure <code>CSSetupResult</code> result if an error occurs asynchronously.
///
- (void)addInMemoryStorage:(CSInMemoryStore * _Nonnull)storage completion:(void (^ _Nonnull)(CSSetupResult * _Nonnull))completion;
/// Asynchronously adds a <code>CSSQLiteStore</code> to the stack. Migrations are also initiated by default.
/// \code
/// NSError *error;
/// NSProgress *migrationProgress = [dataStack
///     addInMemoryStorage:[[CSSQLiteStore alloc] 
///         initWithFileName:@"core_data.sqlite"
///         configuration:@"Config1"]
///     completion:^(CSSetupResult *result) {
///         if (result.isSuccess) {
///             // ...
///         }
///     }
///     error: &error];
///
/// \endcode\param storage the <code>CSSQLiteStore</code> instance
///
/// \param completion the closure to be executed on the main queue when the process completes, either due to success or failure. The closure’s <code>CSSetupResult</code> argument indicates the result. This closure is NOT executed if an error is thrown, but will be executed with a failure <code>CSSetupResult</code> result if an error occurs asynchronously. Note that the <code>CSLocalStorage</code> associated to the <code>-[CSSetupResult storage]</code> may not always be the same instance as the parameter argument if a previous <code>CSLocalStorage</code> was already added at the same URL and with the same configuration.
///
/// \param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// an <code>NSProgress</code> instance if a migration has started. <code>nil</code> if no migrations are required or if <code>error</code> was set.
- (NSProgress * _Nullable)addSQLiteStorage:(CSSQLiteStore * _Nonnull)storage completion:(void (^ _Nonnull)(CSSetupResult * _Nonnull))completion error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
/// Migrates a <code>CSSQLiteStore</code> to match the <code>CSDataStack</code>’s managed object model version. This method does NOT add the migrated store to the data stack.
/// \param storage the <code>CSSQLiteStore</code> instance
///
/// \param completion the closure to be executed on the main queue when the migration completes, either due to success or failure. The closure’s <code>CSMigrationResult</code> argument indicates the result. This closure is NOT executed if an error is thrown, but will be executed with a failure <code>CSSetupResult</code> result if an error occurs asynchronously.
///
/// \param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// an <code>NSProgress</code> instance if a migration has started. <code>nil</code> if no migrations are required or if <code>error</code> was set.
- (NSProgress * _Nullable)upgradeStorageIfNeeded:(CSSQLiteStore * _Nonnull)storage completion:(void (^ _Nonnull)(CSMigrationResult * _Nonnull))completion error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
/// Checks the migration steps required for the <code>CSSQLiteStore</code> to match the <code>CSDataStack</code>’s managed object model version.
/// \param storage the <code>CSSQLiteStore</code> instance
///
/// \param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// a <code>CSMigrationType</code> array indicating the migration steps required for the store, or an empty array if the file does not exist yet. Otherwise, <code>nil</code> is returned and the <code>error</code> argument is set if either inspection of the store failed, or if no mapping model was found/inferred.
- (NSArray<CSMigrationType *> * _Nullable)requiredMigrationsForSQLiteStore:(CSSQLiteStore * _Nonnull)storage error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
@end


SWIFT_AVAILABILITY(macos,introduced=10.12) SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSDataStack (SWIFT_EXTENSION(CoreStore))
/// Creates a <code>CSObjectMonitor</code> for the specified <code>NSManagedObject</code>. Multiple <code>ObjectObserver</code>s may then register themselves to be notified when changes are made to the <code>NSManagedObject</code>.
/// \param object the <code>NSManagedObject</code> to observe changes from
///
///
/// returns:
/// an <code>ObjectMonitor</code> that monitors changes to <code>object</code>
- (CSObjectMonitor * _Nonnull)monitorObject:(NSManagedObject * _Nonnull)object SWIFT_WARN_UNUSED_RESULT;
/// Creates a <code>CSListMonitor</code> for a list of <code>NSManagedObject</code>s that satisfy the specified fetch clauses. Multiple <code>CSListObserver</code>s may then register themselves to be notified when changes are made to the list.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>FetchClause</code> instances for fetching the object list. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// a <code>CSListMonitor</code> instance that monitors changes to the list
- (CSListMonitor * _Nonnull)monitorListFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Asynchronously creates a <code>CSListMonitor</code> for a list of <code>NSManagedObject</code>s that satisfy the specified fetch clauses. Multiple <code>CSListObserver</code>s may then register themselves to be notified when changes are made to the list. Since <code>NSFetchedResultsController</code> greedily locks the persistent store on initial fetch, you may prefer this method instead of the synchronous counterpart to avoid deadlocks while background updates/saves are being executed.
/// \param createAsynchronously the closure that receives the created <code>CSListMonitor</code> instance
///
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for fetching the object list. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
- (void)monitorListByCreatingAsynchronously:(void (^ _Nonnull)(CSListMonitor * _Nonnull))createAsynchronously from:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses;
/// Creates a <code>CSListMonitor</code> for a sectioned list of <code>NSManagedObject</code>s that satisfy the specified fetch clauses. Multiple <code>ListObserver</code>s may then register themselves to be notified when changes are made to the list.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param sectionBy a <code>CSSectionBy</code> clause indicating the keyPath for the attribute to use when sorting the list into sections.
///
/// \param fetchClauses a series of <code>FetchClause</code> instances for fetching the object list. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// a <code>CSListMonitor</code> instance that monitors changes to the list
- (CSListMonitor * _Nonnull)monitorSectionedListFrom:(CSFrom * _Nonnull)from sectionBy:(CSSectionBy * _Nonnull)sectionBy fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
@end


SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSDataStack (SWIFT_EXTENSION(CoreStore))
/// Begins a transaction asynchronously where <code>NSManagedObject</code> creates, updates, and deletes can be made.
/// \param closure the block where creates, updates, and deletes can be made to the transaction. Transaction blocks are executed serially in a background queue, and all changes are made from a concurrent <code>NSManagedObjectContext</code>.
///
- (void)beginAsynchronous:(void (^ _Nonnull)(CSAsynchronousDataTransaction * _Nonnull))closure;
/// Begins a transaction synchronously where <code>NSManagedObject</code> creates, updates, and deletes can be made.
/// \param closure the block where creates, updates, and deletes can be made to the transaction. Transaction blocks are executed serially in a background queue, and all changes are made from a concurrent <code>NSManagedObjectContext</code>.
///
/// \param error the <code>CSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// <code>YES</code> if the commit succeeded, <code>NO</code> if the commit failed. If <code>NO</code>, the <code>error</code> argument will hold error information.
- (BOOL)beginSynchronous:(void (^ _Nonnull)(CSSynchronousDataTransaction * _Nonnull))closure error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
/// Begins a child transaction where <code>NSManagedObject</code> creates, updates, and deletes can be made. This is useful for making temporary changes, such as partially filled forms.
/// To support “undo” methods such as <code>-undo</code>, <code>-redo</code>, and <code>-rollback</code>, use the <code>-beginSafeWithSupportsUndo:</code> method passing <code>YES</code> to the argument. Without “undo” support, calling those methods will raise an exception.
///
/// returns:
/// a <code>CSUnsafeDataTransaction</code> instance where creates, updates, and deletes can be made.
- (CSUnsafeDataTransaction * _Nonnull)beginUnsafe SWIFT_WARN_UNUSED_RESULT;
/// Begins a child transaction where <code>NSManagedObject</code> creates, updates, and deletes can be made. This is useful for making temporary changes, such as partially filled forms.
/// <ul>
///   <li>
///     prameter supportsUndo: <code>-undo</code>, <code>-redo</code>, and <code>-rollback</code> methods are only available when this parameter is <code>YES</code>, otherwise those method will raise an exception. Note that turning on Undo support may heavily impact performance especially on iOS or watchOS where memory is limited.
///   </li>
/// </ul>
///
/// returns:
/// a <code>CSUnsafeDataTransaction</code> instance where creates, updates, and deletes can be made.
- (CSUnsafeDataTransaction * _Nonnull)beginUnsafeWithSupportsUndo:(BOOL)supportsUndo SWIFT_WARN_UNUSED_RESULT;
/// Refreshes all registered objects <code>NSManagedObject</code>s in the <code>DataStack</code>.
- (void)refreshAndMergeAllObjects;
@end


SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSDataStack (SWIFT_EXTENSION(CoreStore))
/// Fetches the <code>NSManagedObject</code> instance in the transaction’s context from a reference created from a transaction or from a different managed object context.
/// \param object a reference to the object created/fetched outside the transaction
///
///
/// returns:
/// the <code>NSManagedObject</code> instance if the object exists in the transaction, or <code>nil</code> if not found.
- (id _Nullable)fetchExistingObject:(NSManagedObject * _Nonnull)object SWIFT_WARN_UNUSED_RESULT;
/// Fetches the <code>NSManagedObject</code> instance in the transaction’s context from an <code>NSManagedObjectID</code>.
/// \param objectID the <code>NSManagedObjectID</code> for the object
///
///
/// returns:
/// the <code>NSManagedObject</code> instance if the object exists in the transaction, or <code>nil</code> if not found.
- (id _Nullable)fetchExistingObjectWithID:(NSManagedObjectID * _Nonnull)objectID SWIFT_WARN_UNUSED_RESULT;
/// Fetches the <code>NSManagedObject</code> instances in the transaction’s context from references created from a transaction or from a different managed object context.
/// \param objects an array of <code>NSManagedObject</code>s created/fetched outside the transaction
///
///
/// returns:
/// the <code>NSManagedObject</code> array for objects that exists in the transaction
- (NSArray * _Nonnull)fetchExistingObjects:(NSArray<NSManagedObject *> * _Nonnull)objects SWIFT_WARN_UNUSED_RESULT;
/// Fetches the <code>NSManagedObject</code> instances in the transaction’s context from a list of <code>NSManagedObjectID</code>.
/// \param objectIDs the <code>NSManagedObjectID</code> array for the objects
///
///
/// returns:
/// the <code>NSManagedObject</code> array for objects that exists in the transaction
- (NSArray * _Nonnull)fetchExistingObjectsWithIDs:(NSArray<NSManagedObjectID *> * _Nonnull)objectIDs SWIFT_WARN_UNUSED_RESULT;
/// Fetches the first <code>NSManagedObject</code> instance that satisfies the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>From</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the first <code>NSManagedObject</code> instance that satisfies the specified <code>CSFetchClause</code>s
- (id _Nullable)fetchOneFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Fetches all <code>NSManagedObject</code> instances that satisfy the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// all <code>NSManagedObject</code> instances that satisfy the specified <code>CSFetchClause</code>s
- (NSArray * _Nullable)fetchAllFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Fetches the number of <code>NSManagedObject</code>s that satisfy the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the number <code>NSManagedObject</code>s that satisfy the specified <code>CSFetchClause</code>s
- (NSNumber * _Nullable)fetchCountFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Fetches the <code>NSManagedObjectID</code> for the first <code>NSManagedObject</code> that satisfies the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the <code>NSManagedObjectID</code> for the first <code>NSManagedObject</code> that satisfies the specified <code>CSFetchClause</code>s
- (NSManagedObjectID * _Nullable)fetchObjectIDFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Fetches the <code>NSManagedObjectID</code> for all <code>NSManagedObject</code>s that satisfy the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>FetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the <code>NSManagedObjectID</code> for all <code>NSManagedObject</code>s that satisfy the specified <code>CSFetchClause</code>s
- (NSArray<NSManagedObjectID *> * _Nullable)fetchObjectIDsFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Queries aggregate values as specified by the <code>CSQueryClause</code>s. Requires at least a <code>CSSelect</code> clause, and optional <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
/// A “query” differs from a “fetch” in that it only retrieves values already stored in the persistent store. As such, values from unsaved transactions or contexts will not be incorporated in the query result.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param selectClause a <code>CSSelect</code> clause indicating the properties to fetch, and with the generic type indicating the return type.
///
/// \param queryClauses a series of <code>CSQueryClause</code> instances for the query request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the result of the the query. The type of the return value is specified by the generic type of the <code>CSSelect</code> parameter.
- (id _Nullable)queryValueFrom:(CSFrom * _Nonnull)from selectClause:(CSSelect * _Nonnull)selectClause queryClauses:(NSArray<id <CSQueryClause>> * _Nonnull)queryClauses SWIFT_WARN_UNUSED_RESULT;
/// Queries a dictionary of attribute values as specified by the <code>CSQueryClause</code>s. Requires at least a <code>CSSelect</code> clause, and optional <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
/// A “query” differs from a “fetch” in that it only retrieves values already stored in the persistent store. As such, values from unsaved transactions or contexts will not be incorporated in the query result.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param selectClause a <code>CSSelect</code> clause indicating the properties to fetch, and with the generic type indicating the return type.
///
/// \param queryClauses a series of <code>CSQueryClause</code> instances for the query request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the result of the the query. The type of the return value is specified by the generic type of the <code>CSSelect</code> parameter.
- (NSArray<NSDictionary<NSString *, id> *> * _Nullable)queryAttributesFrom:(CSFrom * _Nonnull)from selectClause:(CSSelect * _Nonnull)selectClause queryClauses:(NSArray<id <CSQueryClause>> * _Nonnull)queryClauses SWIFT_WARN_UNUSED_RESULT;
@end


/// The <code>CSDeleteClause</code> implement clauses used to configure <code>NSFetchRequest</code>s.
/// seealso:
/// <code>DeleteClause</code>
SWIFT_PROTOCOL("_TtP9CoreStore14CSDeleteClause_")
@protocol CSDeleteClause
- (void)applyToFetchRequest:(NSFetchRequest<id <NSFetchRequestResult>> * _Nonnull)fetchRequest;
@end

@class NSManagedObjectModel;

/// The <code>CSDynamicSchema</code> serves as the Objective-C bridging type for <code>DynamicSchema</code>.
/// seealso:
/// <code>DynamicSchema</code>
SWIFT_PROTOCOL("_TtP9CoreStore15CSDynamicSchema_")
@protocol CSDynamicSchema
/// The version string for this model schema.
@property (nonatomic, readonly, copy) NSString * _Nonnull modelVersion;
/// Do not call this directly. The <code>NSManagedObjectModel</code> for this schema may be created lazily and using this method directly may affect the integrity of the model.
- (NSManagedObjectModel * _Nonnull)rawModel SWIFT_WARN_UNUSED_RESULT;
@end

@class NSCoder;

/// All errors thrown from CoreStore are expressed in <code>CSError</code>s.
/// seealso:
/// <code>CoreStoreError</code>
SWIFT_CLASS("_TtC9CoreStore7CSError")
@interface CSError : NSError
/// The <code>NSError</code> error domain for <code>CSError</code>.
/// seealso:
/// <code>CoreStoreErrorErrorDomain</code>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull errorDomain;)
+ (NSString * _Nonnull)errorDomain SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithDomain:(NSString * _Nonnull)domain code:(NSInteger)code userInfo:(NSDictionary<NSString *, id> * _Nullable)dict SWIFT_UNAVAILABLE;
@end



/// The <code>NSError</code> error codes for <code>CSError.Domain</code>.
/// seealso:
/// <code>CSError</code>
/// seealso:
/// <code>CoreStoreError</code>
typedef SWIFT_ENUM(NSInteger, CSErrorCode, closed) {
/// A failure occured because of an unknown error.
  CSErrorCodeUnknownError = 0,
/// The <code>NSPersistentStore</code> could note be initialized because another store existed at the specified <code>NSURL</code>.
  CSErrorCodeDifferentStorageExistsAtURL = 1,
/// An <code>NSMappingModel</code> could not be found for a specific source and destination model versions.
  CSErrorCodeMappingModelNotFound = 2,
/// Progressive migrations are disabled for a store, but an <code>NSMappingModel</code> could not be found for a specific source and destination model versions.
  CSErrorCodeProgressiveMigrationRequired = 3,
/// An internal SDK call failed with the specified “NSError” userInfo key.
  CSErrorCodeInternalError = 4,
/// The transaction was terminated by a user-thrown error with the specified “Error” userInfo key.
  CSErrorCodeUserError = 5,
/// The transaction was cancelled by the user.
  CSErrorCodeUserCancelled = 6,
};


/// The <code>CSFetchClause</code> implement clauses used to configure <code>NSFetchRequest</code>s.
/// seealso:
/// <code>FetchClause</code>
SWIFT_PROTOCOL("_TtP9CoreStore13CSFetchClause_")
@protocol CSFetchClause
- (void)applyToFetchRequest:(NSFetchRequest<id <NSFetchRequestResult>> * _Nonnull)fetchRequest;
@end


/// The <code>CSFrom</code> serves as the Objective-C bridging type for <code>From</code>.
/// seealso:
/// <code>From</code>
SWIFT_CLASS("_TtC9CoreStore6CSFrom")
@interface CSFrom : NSObject
/// The associated <code>NSManagedObject</code> entity class
@property (nonatomic, readonly) Class _Nonnull entityClass;
/// The <code>NSPersistentStore</code> configuration names to associate objects from.
/// May contain <code>NSString</code> instances to pertain to named configurations, or <code>NSNull</code> to pertain to the default configuration
@property (nonatomic, readonly, copy) NSArray * _Nullable configurations;
/// Initializes a <code>CSFrom</code> clause with the specified entity class.
/// \code
/// MyPersonEntity *people = [transaction fetchAllFrom:CSFromClass([MyPersonEntity class])];
///
/// \endcode\param entityClass the <code>NSManagedObject</code> class type to be created
///
- (nonnull instancetype)initWithEntityClass:(SWIFT_METATYPE(NSManagedObject) _Nonnull)entityClass;
/// Initializes a <code>CSFrom</code> clause with the specified configurations.
/// \code
/// MyPersonEntity *people = [transaction fetchAllFrom:
///    CSFromClass([MyPersonEntity class], @"Config1")];
///
/// \endcode\param entityClass the associated <code>NSManagedObject</code> entity class
///
/// \param configuration the <code>NSPersistentStore</code> configuration name to associate objects from. This parameter is required if multiple configurations contain the created <code>NSManagedObject</code>’s entity type. Set to <code>[NSNull null]</code> to use the default configuration.
///
- (nonnull instancetype)initWithEntityClass:(SWIFT_METATYPE(NSManagedObject) _Nonnull)entityClass configuration:(id _Nonnull)configuration;
/// Initializes a <code>CSFrom</code> clause with the specified configurations.
/// \code
/// MyPersonEntity *people = [transaction fetchAllFrom:
///    CSFromClass([MyPersonEntity class],
///                 @[[NSNull null], @"Config1"])];
///
/// \endcode\param entityClass the associated <code>NSManagedObject</code> entity class
///
/// \param configurations an array of the <code>NSPersistentStore</code> configuration names to associate objects from. This parameter is required if multiple configurations contain the created <code>NSManagedObject</code>’s entity type. Set to <code>[NSNull null]</code> to use the default configuration.
///
- (nonnull instancetype)initWithEntityClass:(SWIFT_METATYPE(NSManagedObject) _Nonnull)entityClass configurations:(NSArray * _Nonnull)configurations;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The <code>CSQueryClause</code> implement clauses used to configure <code>NSFetchRequest</code>s.
/// seealso:
/// <code>QueryClause</code>
SWIFT_PROTOCOL("_TtP9CoreStore13CSQueryClause_")
@protocol CSQueryClause
- (void)applyToFetchRequest:(NSFetchRequest<id <NSFetchRequestResult>> * _Nonnull)fetchRequest;
@end


/// The <code>CSGroupBy</code> serves as the Objective-C bridging type for <code>GroupBy</code>.
/// seealso:
/// <code>GroupBy</code>
SWIFT_CLASS("_TtC9CoreStore9CSGroupBy")
@interface CSGroupBy : NSObject <CSQueryClause>
/// The list of key path strings to group results with
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nonnull keyPaths;
/// Initializes a <code>CSGroupBy</code> clause with a key path string
/// \param keyPath a key path string to group results with
///
- (nonnull instancetype)initWithKeyPath:(NSString * _Nonnull)keyPath;
/// Initializes a <code>CSGroupBy</code> clause with a list of key path strings
/// \param keyPaths a list of key path strings to group results with
///
- (nonnull instancetype)initWithKeyPaths:(NSArray<NSString *> * _Nonnull)keyPaths;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (void)applyToFetchRequest:(NSFetchRequest<id <NSFetchRequestResult>> * _Nonnull)fetchRequest;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The <code>CSStorageInterface</code> serves as the Objective-C bridging type for <code>StorageInterface</code>.
/// seealso:
/// <code>StorageInterface</code>
SWIFT_PROTOCOL("_TtP9CoreStore18CSStorageInterface_")
@protocol CSStorageInterface
/// The string identifier for the <code>NSPersistentStore</code>’s <code>type</code> property. This is the same string CoreStore will use to create the <code>NSPersistentStore</code> from the <code>NSPersistentStoreCoordinator</code>’s <code>addPersistentStoreWithType(...)</code> method.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull storeType;)
+ (NSString * _Nonnull)storeType SWIFT_WARN_UNUSED_RESULT;
/// The configuration name in the model file
@property (nonatomic, readonly, copy) NSString * _Nullable configuration;
/// The options dictionary for the <code>NSPersistentStore</code>
@property (nonatomic, readonly, copy) NSDictionary * _Nullable storeOptions;
@end


/// The <code>CSInMemoryStore</code> serves as the Objective-C bridging type for <code>InMemoryStore</code>.
/// seealso:
/// <code>InMemoryStore</code>
SWIFT_CLASS("_TtC9CoreStore15CSInMemoryStore") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSInMemoryStore : NSObject <CSStorageInterface>
/// Initializes a <code>CSInMemoryStore</code> for the specified configuration
/// \param configuration an optional configuration name from the model file. If not specified, defaults to <code>nil</code>, the “Default” configuration.
///
- (nonnull instancetype)initWithConfiguration:(NSString * _Nullable)configuration;
/// Initializes a <code>CSInMemoryStore</code> with the “Default” configuration
- (nonnull instancetype)init;
/// The string identifier for the <code>NSPersistentStore</code>’s <code>type</code> property. For <code>CSInMemoryStore</code>s, this is always set to <code>NSInMemoryStoreType</code>.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull storeType;)
+ (NSString * _Nonnull)storeType SWIFT_WARN_UNUSED_RESULT;
/// The configuration name in the model file
@property (nonatomic, readonly, copy) NSString * _Nullable configuration;
/// The options dictionary for the <code>NSPersistentStore</code>. For <code>CSInMemoryStore</code>s, this is always set to <code>nil</code>.
@property (nonatomic, readonly, copy) NSDictionary * _Nullable storeOptions;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
@end


/// The <code>CSInto</code> serves as the Objective-C bridging type for <code>Into<T></code>.
/// seealso:
/// <code>Into</code>
SWIFT_CLASS("_TtC9CoreStore6CSInto")
@interface CSInto : NSObject
/// The associated <code>NSManagedObject</code> entity class
@property (nonatomic, readonly) SWIFT_METATYPE(NSManagedObject) _Nonnull entityClass;
/// The <code>NSPersistentStore</code> configuration name to associate objects from.
/// May contain a <code>String</code> to pertain to a named configuration, or <code>nil</code> to pertain to the default configuration
@property (nonatomic, readonly, copy) NSString * _Nullable configuration;
/// Initializes a <code>CSInto</code> clause with the specified entity class.
/// \code
/// MyPersonEntity *person = [transaction createInto:
///    CSIntoClass([MyPersonEntity class])];
///
/// \endcode\param entityClass the <code>NSManagedObject</code> class type to be created
///
- (nonnull instancetype)initWithEntityClass:(SWIFT_METATYPE(NSManagedObject) _Nonnull)entityClass;
/// Initializes a <code>CSInto</code> clause with the specified configuration.
/// \code
/// MyPersonEntity *person = [transaction createInto:
///    CSIntoClass([MyPersonEntity class])];
///
/// \endcode\param entityClass the <code>NSManagedObject</code> class type to be created
///
/// \param configuration the <code>NSPersistentStore</code> configuration name to associate the object to. This parameter is required if multiple configurations contain the created <code>NSManagedObject</code>’s entity type. Set to <code>nil</code> to use the default configuration.
///
- (nonnull instancetype)initWithEntityClass:(SWIFT_METATYPE(NSManagedObject) _Nonnull)entityClass configuration:(NSString * _Nullable)configuration;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@protocol NSFetchedResultsSectionInfo;
@protocol CSListObserver;
@protocol CSListSectionObserver;

/// The <code>CSListMonitor</code> serves as the Objective-C bridging type for <code>ListMonitor<T></code>.
/// seealso:
/// <code>ListMonitor</code>
SWIFT_CLASS("_TtC9CoreStore13CSListMonitor") SWIFT_AVAILABILITY(macos,introduced=10.12)
@interface CSListMonitor : NSObject
- (id _Nonnull)objectAtIndexedSubscript:(NSInteger)index SWIFT_WARN_UNUSED_RESULT;
/// Returns the object at the given index, or <code>nil</code> if out of bounds. This indexer is typically used for <code>CSListMonitor</code>s created without section groupings.
/// \param index the index for the object. Using an index above the valid range will return <code>nil</code>.
///
///
/// returns:
/// the <code>NSManagedObject</code> at the specified index, or <code>nil</code> if out of bounds
- (id _Nullable)objectAtSafeIndex:(NSInteger)index SWIFT_WARN_UNUSED_RESULT;
/// Returns the object at the given <code>sectionIndex</code> and <code>itemIndex</code>. This indexer is typically used for <code>CSListMonitor</code>s created as sectioned lists.
/// \param sectionIndex the section index for the object. Using a <code>sectionIndex</code> with an invalid range will raise an exception.
///
/// \param itemIndex the index for the object within the section. Using an <code>itemIndex</code> with an invalid range will raise an exception.
///
///
/// returns:
/// the <code>NSManagedObject</code> at the specified section and item index
- (id _Nonnull)objectAtSectionIndex:(NSInteger)sectionIndex itemIndex:(NSInteger)itemIndex SWIFT_WARN_UNUSED_RESULT;
/// Returns the object at the given section and item index, or <code>nil</code> if out of bounds. This indexer is typically used for <code>CSListMonitor</code>s created as sectioned lists.
/// \param sectionIndex the section index for the object. Using a <code>sectionIndex</code> with an invalid range will return <code>nil</code>.
///
/// \param itemIndex the index for the object within the section. Using an <code>itemIndex</code> with an invalid range will return <code>nil</code>.
///
///
/// returns:
/// the <code>NSManagedObject</code> at the specified section and item index, or <code>nil</code> if out of bounds
- (id _Nullable)objectAtSafeSectionIndex:(NSInteger)sectionIndex safeItemIndex:(NSInteger)itemIndex SWIFT_WARN_UNUSED_RESULT;
/// Returns the object at the given <code>NSIndexPath</code>. This subscript indexer is typically used for <code>CSListMonitor</code>s created as sectioned lists.
/// \param indexPath the <code>NSIndexPath</code> for the object. Using an <code>indexPath</code> with an invalid range will raise an exception.
///
///
/// returns:
/// the <code>NSManagedObject</code> at the specified index path
- (id _Nonnull)objectAtIndexPath:(NSIndexPath * _Nonnull)indexPath SWIFT_WARN_UNUSED_RESULT;
/// Returns the object at the given <code>NSIndexPath</code>, or <code>nil</code> if out of bounds. This subscript indexer is typically used for <code>CSListMonitor</code>s created as sectioned lists.
/// \param indexPath the <code>NSIndexPath</code> for the object. Using an <code>indexPath</code> with an invalid range will return <code>nil</code>.
///
///
/// returns:
/// the <code>NSManagedObject</code> at the specified index path, or <code>nil</code> if out of bounds
- (id _Nullable)objectAtSafeIndexPath:(NSIndexPath * _Nonnull)indexPath SWIFT_WARN_UNUSED_RESULT;
/// Checks if the <code>CSListMonitor</code> has at least one object in any section.
///
/// returns:
/// <code>YES</code> if at least one object in any section exists, <code>NO</code> otherwise
- (BOOL)hasObjects SWIFT_WARN_UNUSED_RESULT;
/// Checks if the <code>CSListMonitor</code> has at least one object the specified section.
/// \param section the section index. Using an index outside the valid range will return <code>NO</code>.
///
///
/// returns:
/// <code>YES</code> if at least one object in the specified section exists, <code>NO</code> otherwise
- (BOOL)hasObjectsInSection:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// Returns all objects in all sections
///
/// returns:
/// all objects in all sections
- (NSArray<NSManagedObject *> * _Nonnull)objectsInAllSections SWIFT_WARN_UNUSED_RESULT;
/// Returns all objects in the specified section
/// \param section the section index. Using an index outside the valid range will raise an exception.
///
///
/// returns:
/// all objects in the specified section
- (NSArray<NSManagedObject *> * _Nonnull)objectsInSection:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// Returns all objects in the specified section, or <code>nil</code> if out of bounds.
/// \param section the section index. Using an index outside the valid range will return <code>nil</code>.
///
///
/// returns:
/// all objects in the specified section, or <code>nil</code> if out of bounds
- (NSArray<NSManagedObject *> * _Nullable)objectsInSafeSectionWithSafeSectionIndex:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// Returns the number of sections
///
/// returns:
/// the number of sections
- (NSInteger)numberOfSections SWIFT_WARN_UNUSED_RESULT;
/// Returns the number of objects in all sections
///
/// returns:
/// the number of objects in all sections
- (NSInteger)numberOfObjects SWIFT_WARN_UNUSED_RESULT;
/// Returns the number of objects in the specified section
/// \param section the section index. Using an index outside the valid range will raise an exception.
///
///
/// returns:
/// the number of objects in the specified section
- (NSInteger)numberOfObjectsInSection:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// Returns the number of objects in the specified section, or <code>nil</code> if out of bounds.
/// \param section the section index. Using an index outside the valid range will return <code>nil</code>.
///
///
/// returns:
/// the number of objects in the specified section, or <code>nil</code> if out of bounds
- (NSNumber * _Nullable)numberOfObjectsInSafeSectionWithSafeSectionIndex:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// Returns the <code>NSFetchedResultsSectionInfo</code> for the specified section
/// \param section the section index. Using an index outside the valid range will raise an exception.
///
///
/// returns:
/// the <code>NSFetchedResultsSectionInfo</code> for the specified section
- (id <NSFetchedResultsSectionInfo> _Nonnull)sectionInfoAtIndex:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// Returns the <code>NSFetchedResultsSectionInfo</code> for the specified section, or <code>nil</code> if out of bounds.
/// \param section the section index. Using an index outside the valid range will return <code>nil</code>.
///
///
/// returns:
/// the <code>NSFetchedResultsSectionInfo</code> for the specified section, or <code>nil</code> if the section index is out of bounds.
- (id <NSFetchedResultsSectionInfo> _Nullable)sectionInfoAtSafeSectionIndexWithSafeSectionIndex:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// Returns the <code>NSFetchedResultsSectionInfo</code>s for all sections
///
/// returns:
/// the <code>NSFetchedResultsSectionInfo</code>s for all sections
- (NSArray<id <NSFetchedResultsSectionInfo>> * _Nonnull)sections SWIFT_WARN_UNUSED_RESULT;
/// Returns the target section for a specified “Section Index” title and index.
/// \param title the title of the Section Index
///
/// \param index the index of the Section Index
///
///
/// returns:
/// the target section for the specified “Section Index” title and index.
- (NSInteger)targetSectionForSectionIndexTitleWithTitle:(NSString * _Nonnull)title index:(NSInteger)index SWIFT_WARN_UNUSED_RESULT;
/// Returns the section index titles for all sections
///
/// returns:
/// the section index titles for all sections
- (NSArray<NSString *> * _Nonnull)sectionIndexTitles SWIFT_WARN_UNUSED_RESULT;
/// Returns the index of the <code>NSManagedObject</code> if it exists in the <code>CSListMonitor</code>’s fetched objects, or <code>nil</code> if not found.
/// \param object the <code>NSManagedObject</code> to search the index of
///
///
/// returns:
/// the index of the <code>NSManagedObject</code> if it exists in the <code>CSListMonitor</code>’s fetched objects, or <code>nil</code> if not found.
- (NSNumber * _Nullable)indexOf:(NSManagedObject * _Nonnull)object SWIFT_WARN_UNUSED_RESULT;
/// Returns the <code>NSIndexPath</code> of the <code>NSManagedObject</code> if it exists in the <code>CSListMonitor</code>’s fetched objects, or <code>nil</code> if not found.
/// \param object the <code>NSManagedObject</code> to search the index of
///
///
/// returns:
/// the <code>NSIndexPath</code> of the <code>NSManagedObject</code> if it exists in the <code>ListMonitor</code>’s fetched objects, or <code>nil</code> if not found.
- (NSIndexPath * _Nullable)indexPathOf:(NSManagedObject * _Nonnull)object SWIFT_WARN_UNUSED_RESULT;
/// Registers a <code>CSListObserver</code> to be notified when changes to the receiver’s list occur.
/// To prevent retain-cycles, <code>CSListMonitor</code> only keeps <code>weak</code> references to its observers.
/// For thread safety, this method needs to be called from the main thread. An assertion failure will occur (on debug builds only) if called from any thread other than the main thread.
/// Calling <code>-addListObserver:</code> multiple times on the same observer is safe, as <code>CSListMonitor</code> unregisters previous notifications to the observer before re-registering them.
/// \param observer a <code>CSListObserver</code> to send change notifications to
///
- (void)addListObserver:(id <CSListObserver> _Nonnull)observer;
/// Registers a <code>CSListSectionObserver</code> to be notified when changes to the receiver’s list occur.
/// To prevent retain-cycles, <code>CSListMonitor</code> only keeps <code>weak</code> references to its observers.
/// For thread safety, this method needs to be called from the main thread. An assertion failure will occur (on debug builds only) if called from any thread other than the main thread.
/// Calling <code>-addListSectionObserver:</code> multiple times on the same observer is safe, as <code>ListMonitor</code> unregisters previous notifications to the observer before re-registering them.
/// \param observer a <code>CSListSectionObserver</code> to send change notifications to
///
- (void)addListSectionObserver:(id <CSListSectionObserver> _Nonnull)observer;
/// Unregisters a <code>CSListObserver</code> from receiving notifications for changes to the receiver’s list.
/// For thread safety, this method needs to be called from the main thread. An assertion failure will occur (on debug builds only) if called from any thread other than the main thread.
/// \param observer a <code>CSListObserver</code> to unregister notifications to
///
- (void)removeListObserver:(id <CSListObserver> _Nonnull)observer;
/// Returns <code>YES</code> if a call to <code>-refetch:</code> was made to the <code>CSListMonitor</code> and is currently waiting for the fetching to complete. Returns <code>NO</code> otherwise.
@property (nonatomic, readonly) BOOL isPendingRefetch;
/// Asks the <code>CSListMonitor</code> to refetch its objects using the specified series of <code>CSFetchClause</code>s. Note that this method does not execute the fetch immediately; the actual fetching will happen after the <code>NSFetchedResultsController</code>’s last <code>controllerDidChangeContent(_:)</code> notification completes.
/// <code>refetch(...)</code> broadcasts <code>listMonitorWillRefetch(...)</code> to its observers immediately, and then <code>listMonitorDidRefetch(...)</code> after the new fetch request completes.
/// important:
/// Starting CoreStore 4.0, all <code>CSFetchClause</code>s required by the <code>CSListMonitor</code> should be provided in the arguments list of <code>refetch(...)</code>.
/// \param fetchClauses a series of <code>FetchClause</code> instances for fetching the object list. Accepts <code>Where</code>, <code>OrderBy</code>, and <code>Tweak</code> clauses.
///
- (void)refetch:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Implement the <code>CSListObserver</code> protocol to observe changes to a list of <code>NSManagedObject</code>s. <code>CSListObserver</code>s may register themselves to a <code>CSListMonitor</code>’s <code>-addListObserver:</code> method:
/// \code
/// CSListMonitor *monitor = [CSCoreStore 
///     monitorListFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     fetchClauses:@[[CSOrderBy sortDescriptor:[CSSortKey withKeyPath:@"lastName" ascending:YES]]]];
/// [monitor addListObserver:self];
///
/// \endcodeseealso:
/// <code>ListObserver</code>
SWIFT_PROTOCOL("_TtP9CoreStore14CSListObserver_") SWIFT_AVAILABILITY(macos,introduced=10.12)
@protocol CSListObserver
@optional
/// Handles processing just before a change to the observed list occurs
/// \param monitor the <code>CSListMonitor</code> monitoring the list being observed
///
- (void)listMonitorWillChange:(CSListMonitor * _Nonnull)monitor;
/// Handles processing right after a change to the observed list occurs
/// \param monitor the <code>CSListMonitor</code> monitoring the object being observed
///
- (void)listMonitorDidChange:(CSListMonitor * _Nonnull)monitor;
/// This method is broadcast from within the <code>CSListMonitor</code>’s <code>-refetchWithFetchClauses:</code> method to let observers prepare for the internal <code>NSFetchedResultsController</code>’s pending change to its predicate, sort descriptors, etc. Note that the actual refetch will happen after the <code>NSFetchedResultsController</code>’s last <code>-controllerDidChangeContent:</code> notification completes.
/// \param monitor the <code>CSListMonitor</code> monitoring the object being observed
///
- (void)listMonitorWillRefetch:(CSListMonitor * _Nonnull)monitor;
/// After the <code>CSListMonitor</code>’s <code>-refetchWithFetchClauses:</code> method is called, this method is broadcast after the <code>NSFetchedResultsController</code>’s last <code>-controllerDidChangeContent:</code> notification completes.
/// \param monitor the <code>CSListMonitor</code> monitoring the object being observed
///
- (void)listMonitorDidRefetch:(CSListMonitor * _Nonnull)monitor;
@end


/// Implement the <code>CSListObjectObserver</code> protocol to observe detailed changes to a list’s object. <code>CSListObjectObserver</code>s may register themselves to a <code>CSListMonitor</code>’s <code>-addListObjectObserver(_:)</code> method:
/// \code
/// CSListMonitor *monitor = [CSCoreStore
///     monitorListFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     fetchClauses:@[[CSOrderBy sortDescriptor:[CSSortKey withKeyPath:@"lastName" ascending:YES]]]];
/// [monitor addListObjectObserver:self];
///
/// \endcodeseealso:
/// <code>ListObjectObserver</code>
SWIFT_PROTOCOL("_TtP9CoreStore20CSListObjectObserver_") SWIFT_AVAILABILITY(macos,introduced=10.12)
@protocol CSListObjectObserver <CSListObserver>
@optional
/// Notifies that an object was inserted to the specified <code>NSIndexPath</code> in the list
/// \param monitor the <code>CSListMonitor</code> monitoring the list being observed
///
/// \param object the entity type for the inserted object
///
/// \param indexPath the new <code>NSIndexPath</code> for the inserted object
///
- (void)listMonitor:(CSListMonitor * _Nonnull)monitor didInsertObject:(id _Nonnull)object toIndexPath:(NSIndexPath * _Nonnull)indexPath;
/// Notifies that an object was deleted from the specified <code>NSIndexPath</code> in the list
/// \param monitor the <code>CSListMonitor</code> monitoring the list being observed
///
/// \param object the entity type for the deleted object
///
/// \param indexPath the <code>NSIndexPath</code> for the deleted object
///
- (void)listMonitor:(CSListMonitor * _Nonnull)monitor didDeleteObject:(id _Nonnull)object fromIndexPath:(NSIndexPath * _Nonnull)indexPath;
/// Notifies that an object at the specified <code>NSIndexPath</code> was updated
/// \param monitor the <code>CSListMonitor</code> monitoring the list being observed
///
/// \param object the entity type for the updated object
///
/// \param indexPath the <code>NSIndexPath</code> for the updated object
///
- (void)listMonitor:(CSListMonitor * _Nonnull)monitor didUpdateObject:(id _Nonnull)object atIndexPath:(NSIndexPath * _Nonnull)indexPath;
/// Notifies that an object’s index changed
/// \param monitor the <code>CSListMonitor</code> monitoring the list being observed
///
/// \param object the entity type for the moved object
///
/// \param fromIndexPath the previous <code>NSIndexPath</code> for the moved object
///
/// \param toIndexPath the new <code>NSIndexPath</code> for the moved object
///
- (void)listMonitor:(CSListMonitor * _Nonnull)monitor didMoveObject:(id _Nonnull)object fromIndexPath:(NSIndexPath * _Nonnull)fromIndexPath toIndexPath:(NSIndexPath * _Nonnull)toIndexPath;
@end



/// Implement the <code>CSListSectionObserver</code> protocol to observe changes to a list’s section info. <code>CSListSectionObserver</code>s may register themselves to a <code>CSListMonitor</code>’s <code>-addListSectionObserver:</code> method:
/// \code
/// CSListMonitor *monitor = [CSCoreStore
///     monitorSectionedListFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     sectionBy:[CSSectionBy keyPath:@"age"]
///     fetchClauses:@[[CSOrderBy sortDescriptor:[CSSortKey withKeyPath:@"lastName" ascending:YES]]]];
/// [monitor addListSectionObserver:self];
///
/// \endcodeseealso:
/// <code>ListSectionObserver</code>
SWIFT_PROTOCOL("_TtP9CoreStore21CSListSectionObserver_") SWIFT_AVAILABILITY(macos,introduced=10.12)
@protocol CSListSectionObserver <CSListObjectObserver>
@optional
/// Notifies that a section was inserted at the specified index
/// \param monitor the <code>CSListMonitor</code> monitoring the list being observed
///
/// \param sectionInfo the <code>NSFetchedResultsSectionInfo</code> for the inserted section
///
/// \param sectionIndex the new section index for the new section
///
- (void)listMonitor:(CSListMonitor * _Nonnull)monitor didInsertSection:(id <NSFetchedResultsSectionInfo> _Nonnull)sectionInfo toSectionIndex:(NSInteger)sectionIndex;
/// Notifies that a section was inserted at the specified index
/// \param monitor the <code>CSListMonitor</code> monitoring the list being observed
///
/// \param sectionInfo the <code>NSFetchedResultsSectionInfo</code> for the deleted section
///
/// \param sectionIndex the previous section index for the deleted section
///
- (void)listMonitor:(CSListMonitor * _Nonnull)monitor didDeleteSection:(id <NSFetchedResultsSectionInfo> _Nonnull)sectionInfo fromSectionIndex:(NSInteger)sectionIndex;
@end

@class NSDictionary;

/// The <code>CSLocalStorage</code> serves as the Objective-C bridging type for <code>LocalStorage</code>.
/// seealso:
/// <code>LocalStorage</code>
SWIFT_PROTOCOL("_TtP9CoreStore14CSLocalStorage_")
@protocol CSLocalStorage <CSStorageInterface>
/// The <code>NSURL</code> that points to the store file
@property (nonatomic, readonly, copy) NSURL * _Nonnull fileURL;
/// An array of <code>SchemaMappingProvider</code>s that provides the complete mapping models for custom migrations. This is currently only supported for Swift code.
@property (nonatomic, readonly, copy) NSArray * _Nonnull migrationMappingProviders;
/// Options that tell the <code>CSDataStack</code> how to setup the persistent store
@property (nonatomic, readonly) NSInteger localStorageOptions;
/// Called by the <code>CSDataStack</code> to perform actual deletion of the store file from disk. Do not call directly! The <code>sourceModel</code> argument is a hint for the existing store’s model version. Implementers can use the <code>sourceModel</code> to perform necessary store operations. (SQLite stores for example, can convert WAL journaling mode to DELETE before deleting)
- (BOOL)cs_eraseStorageAndWaitWithMetadata:(NSDictionary * _Nonnull)metadata soureModelHint:(NSManagedObjectModel * _Nullable)soureModelHint error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
@end

/// The <code>CSLocalStorageOptions</code> provides settings that tells the <code>CSDataStack</code> how to setup the persistent store for <code>CSLocalStorage</code> implementers.
/// seealso:
/// <code>LocalStorageOptions</code>
typedef SWIFT_ENUM(NSInteger, CSLocalStorageOptions, closed) {
/// Tells the <code>DataStack</code> that the store should not be migrated or recreated, and should simply fail on model mismatch
  CSLocalStorageOptionsNone = 0,
/// Tells the <code>DataStack</code> to delete and recreate the store on model mismatch, otherwise exceptions will be thrown on failure instead
  CSLocalStorageOptionsRecreateStoreOnModelMismatch = 1,
/// Tells the <code>DataStack</code> to prevent progressive migrations for the store
  CSLocalStorageOptionsPreventProgressiveMigration = 2,
/// Tells the <code>DataStack</code> to allow lightweight migration for the store when added synchronously
  CSLocalStorageOptionsAllowSynchronousLightweightMigration = 4,
};


/// The <code>CSMigrationResult</code> serves as the Objective-C bridging type for <code>MigrationResult</code>.
/// seealso:
/// <code>MigrationResult</code>
SWIFT_CLASS("_TtC9CoreStore17CSMigrationResult") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSMigrationResult : NSObject
/// <code>YES</code> if the migration succeeded, <code>NO</code> otherwise
@property (nonatomic, readonly) BOOL isSuccess;
/// <code>YES</code> if the migration failed, <code>NO</code> otherwise
@property (nonatomic, readonly) BOOL isFailure;
/// <code>YES</code> if the migration succeeded, <code>NO</code> otherwise
@property (nonatomic, readonly, copy) NSArray<CSMigrationType *> * _Nullable migrationTypes;
/// The <code>NSError</code> for a failed migration, or <code>nil</code> if the migration succeeded
@property (nonatomic, readonly, strong) NSError * _Nullable error;
/// If the result was a success, the <code>success</code> block is executed with an array of <code>CSMigrationType</code>s that indicates the migration steps completed. If the result was a failure, the <code>failure</code> block is executed with an <code>NSError</code> argument pertaining to the actual error.
/// The blocks are executed immediately as <code>@noescape</code> and will not be retained.
/// \param success the block to execute on success. The block passes an array of <code>CSMigrationType</code>s that indicates the migration steps completed.
///
/// \param failure the block to execute on failure. The block passes an <code>NSError</code> argument that pertains to the actual error.
///
- (void)handleSuccess:(SWIFT_NOESCAPE void (^ _Nonnull)(NSArray<CSMigrationType *> * _Nonnull))success failure:(SWIFT_NOESCAPE void (^ _Nonnull)(NSError * _Nonnull))failure;
/// If the result was a success, the <code>success</code> block is executed with an array of <code>CSMigrationType</code>s that indicates the migration steps completed. If the result was a failure, this method does nothing.
/// The block is executed immediately as <code>@noescape</code> and will not be retained.
/// \param success the block to execute on success. The block passes an array of <code>CSMigrationType</code>s that indicates the migration steps completed.
///
- (void)handleSuccess:(SWIFT_NOESCAPE void (^ _Nonnull)(NSArray<CSMigrationType *> * _Nonnull))success;
/// If the result was a failure, the <code>failure</code> block is executed with an <code>NSError</code> argument pertaining to the actual error. If the result was a success, this method does nothing.
/// The block is executed immediately as <code>@noescape</code> and will not be retained.
/// \param failure the block to execute on failure. The block passes an <code>NSError</code> argument that pertains to the actual error.
///
- (void)handleFailure:(SWIFT_NOESCAPE void (^ _Nonnull)(NSError * _Nonnull))failure;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The <code>CSMigrationType</code> serves as the Objective-C bridging type for <code>MigrationType</code>.
/// seealso:
/// <code>MigrationType</code>
SWIFT_CLASS("_TtC9CoreStore15CSMigrationType") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSMigrationType : NSObject
/// Returns <code>YES</code> if the <code>CSMigrationType</code>’s <code>sourceVersion</code> and <code>destinationVersion</code> do not match. Returns <code>NO</code> otherwise.
@property (nonatomic, readonly) BOOL needsMigration;
/// Returns the source model version for the migration type. If no migration is required, <code>sourceVersion</code> will be equal to the <code>destinationVersion</code>.
@property (nonatomic, readonly, copy) NSString * _Nonnull sourceVersion;
/// Returns the destination model version for the migration type. If no migration is required, <code>destinationVersion</code> will be equal to the <code>sourceVersion</code>.
@property (nonatomic, readonly, copy) NSString * _Nonnull destinationVersion;
/// Returns <code>YES</code> if the <code>CSMigrationType</code> is a lightweight migration. Used as syntactic sugar.
@property (nonatomic, readonly) BOOL isLightweightMigration;
/// Returns <code>YES</code> if the <code>CSMigrationType</code> is a heavyweight migration. Used as syntactic sugar.
@property (nonatomic, readonly) BOOL isHeavyweightMigration;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The <code>CSObjectMonitor</code> serves as the Objective-C bridging type for <code>ObjectMonitor<T></code>.
/// seealso:
/// <code>ObjectMonitor</code>
SWIFT_CLASS("_TtC9CoreStore15CSObjectMonitor") SWIFT_AVAILABILITY(macos,introduced=10.12)
@interface CSObjectMonitor : NSObject
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Implement the <code>CSObjectObserver</code> protocol to observe changes  to a single <code>NSManagedObject</code> instance. <code>CSObjectObserver</code>s may register themselves to a <code>CSObjectMonitor</code>’s <code>-addObjectObserver:</code> method:
/// \code
/// CSObjectMonitor *monitor = [CSCoreStore monitorObject:myObject];
/// [monitor addObjectObserver:self];
///
/// \endcodeseealso:
/// <code>ObjectObserver</code>
SWIFT_PROTOCOL("_TtP9CoreStore16CSObjectObserver_") SWIFT_AVAILABILITY(macos,introduced=10.12)
@protocol CSObjectObserver
@optional
/// Handles processing just before a change to the observed <code>object</code> occurs
/// \param monitor the <code>CSObjectMonitor</code> monitoring the object being observed
///
/// \param object the <code>NSManagedObject</code> instance being observed
///
- (void)objectMonitor:(CSObjectMonitor * _Nonnull)monitor willUpdateObject:(id _Nonnull)object;
/// Handles processing right after a change to the observed <code>object</code> occurs
/// \param monitor the <code>CSObjectMonitor</code> monitoring the object being observed
///
/// \param object the <code>NSManagedObject</code> instance being observed
///
/// \param changedPersistentKeys an <code>NSSet</code> of key paths for the attributes that were changed. Note that <code>changedPersistentKeys</code> only contains keys for attributes/relationships present in the persistent store, thus transient properties will not be reported.
///
- (void)objectMonitor:(CSObjectMonitor * _Nonnull)monitor didUpdateObject:(id _Nonnull)object changedPersistentKeys:(NSSet<NSString *> * _Nonnull)changedPersistentKeys;
/// Handles processing right after <code>object</code> is deleted
/// \param monitor the <code>CSObjectMonitor</code> monitoring the object being observed
///
/// \param object the <code>NSManagedObject</code> instance being observed
///
- (void)objectMonitor:(CSObjectMonitor * _Nonnull)monitor didDeleteObject:(id _Nonnull)object;
@end

@class NSSortDescriptor;

/// The <code>CSOrderBy</code> serves as the Objective-C bridging type for <code>OrderBy</code>.
/// seealso:
/// <code>OrderBy</code>
SWIFT_CLASS("_TtC9CoreStore9CSOrderBy")
@interface CSOrderBy : NSObject <CSDeleteClause, CSFetchClause, CSQueryClause>
/// The list of sort descriptors
@property (nonatomic, readonly, copy) NSArray<NSSortDescriptor *> * _Nonnull sortDescriptors;
/// Initializes a <code>CSOrderBy</code> clause with a single sort descriptor
/// \code
/// MyPersonEntity *people = [transaction
///    fetchAllFrom:CSFromClass([MyPersonEntity class])
///    fetchClauses:@[CSOrderByKey(CSSortAscending(@"fullname"))]]];
///
/// \endcode\param sortDescriptor a <code>NSSortDescriptor</code>
///
- (nonnull instancetype)initWithSortDescriptor:(NSSortDescriptor * _Nonnull)sortDescriptor;
/// Initializes a <code>CSOrderBy</code> clause with a list of sort descriptors
/// \code
/// MyPersonEntity *people = [transaction
///    fetchAllFrom:CSFromClass([MyPersonEntity class])
///    fetchClauses:@[CSOrderByKeys(CSSortAscending(@"fullname"), CSSortDescending(@"age"), nil))]]];
///
/// \endcode\param sortDescriptors an array of <code>NSSortDescriptor</code>s
///
- (nonnull instancetype)initWithSortDescriptors:(NSArray<NSSortDescriptor *> * _Nonnull)sortDescriptors;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (void)applyToFetchRequest:(NSFetchRequest<id <NSFetchRequestResult>> * _Nonnull)fetchRequest;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



/// The <code>CSSQLiteStore</code> serves as the Objective-C bridging type for <code>SQLiteStore</code>.
/// seealso:
/// <code>SQLiteStore</code>
SWIFT_CLASS("_TtC9CoreStore13CSSQLiteStore") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSSQLiteStore : NSObject <CSLocalStorage>
/// Initializes an SQLite store interface from the given SQLite file URL. When this instance is passed to the <code>CSDataStack</code>’s <code>-addStorage*:</code> methods, a new SQLite file will be created if it does not exist.
/// important:
/// Initializing <code>CSSQLiteStore</code>s with custom migration mapping models is currently not supported. Create an <code>SQLiteStore</code> instance from Swift code and bridge the instance to Objective-C using its <code>SQLiteStore.bridgeToObjectiveC</code> property.
/// \param fileURL the local file URL for the target SQLite persistent store. Note that if you have multiple configurations, you will need to specify a different <code>fileURL</code> explicitly for each of them.
///
/// \param configuration an optional configuration name from the model file. If not specified, defaults to <code>nil</code>, the “Default” configuration. Note that if you have multiple configurations, you will need to specify a different <code>fileURL</code> explicitly for each of them.
///
/// \param localStorageOptions When the <code>CSSQLiteStore</code> is passed to the <code>CSDataStack</code>’s <code>addStorage()</code> methods, tells the <code>CSDataStack</code> how to setup the persistent store. Defaults to <code>CSLocalStorageOptionsNone</code>.
///
- (nonnull instancetype)initWithFileURL:(NSURL * _Nonnull)fileURL configuration:(NSString * _Nullable)configuration localStorageOptions:(NSInteger)localStorageOptions;
/// Initializes an SQLite store interface from the given SQLite file name. When this instance is passed to the <code>CSDataStack</code>’s <code>-addStorage*:</code> methods, a new SQLite file will be created if it does not exist.
/// important:
/// Initializing <code>CSSQLiteStore</code>s with custom migration mapping models is currently not supported. Create an <code>SQLiteStore</code> instance from Swift code and bridge the instance to Objective-C using its <code>SQLiteStore.bridgeToObjectiveC</code> property.
/// \param fileName the local filename for the SQLite persistent store in the “Application Support/<bundle id>” directory (or the “Caches/<bundle id>” directory on tvOS). Note that if you have multiple configurations, you will need to specify a different <code>fileName</code> explicitly for each of them.
///
/// \param configuration an optional configuration name from the model file. If not specified, defaults to <code>nil</code>, the “Default” configuration. Note that if you have multiple configurations, you will need to specify a different <code>fileName</code> explicitly for each of them.
///
/// \param localStorageOptions When the <code>CSSQLiteStore</code> is passed to the <code>CSDataStack</code>’s <code>addStorage()</code> methods, tells the <code>CSDataStack</code> how to setup the persistent store. Defaults to <code>[CSLocalStorageOptions none]</code>.
///
- (nonnull instancetype)initWithFileName:(NSString * _Nonnull)fileName configuration:(NSString * _Nullable)configuration localStorageOptions:(NSInteger)localStorageOptions;
/// Initializes an <code>CSSQLiteStore</code> with an all-default settings: a <code>fileURL</code> pointing to a “<Application name>.sqlite” file in the “Application Support/<bundle id>” directory (or the “Caches/<bundle id>” directory on tvOS), a <code>nil</code> <code>configuration</code> pertaining to the “Default” configuration, and <code>localStorageOptions</code> set to <code>[CSLocalStorageOptions none]</code>.
/// important:
/// Initializing <code>CSSQLiteStore</code>s with custom migration mapping models is currently not supported. Create an <code>SQLiteStore</code> instance from Swift code and bridge the instance to Objective-C using its <code>SQLiteStore.bridgeToObjectiveC</code> property.
- (nonnull instancetype)init;
/// The <code>NSURL</code> that points to the SQLite file
@property (nonatomic, readonly, copy) NSURL * _Nonnull fileURL;
/// An array of <code>SchemaMappingProvider</code>s that provides the complete mapping models for custom migrations. This is currently only supported for Swift code.
@property (nonatomic, readonly, copy) NSArray * _Nonnull migrationMappingProviders;
/// Options that tell the <code>CSDataStack</code> how to setup the persistent store
@property (nonatomic, readonly) NSInteger localStorageOptions;
/// The string identifier for the <code>NSPersistentStore</code>’s <code>type</code> property. For <code>CSSQLiteStore</code>s, this is always set to <code>NSSQLiteStoreType</code>.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull storeType;)
+ (NSString * _Nonnull)storeType SWIFT_WARN_UNUSED_RESULT;
/// The configuration name in the model file
@property (nonatomic, readonly, copy) NSString * _Nullable configuration;
/// The options dictionary for the <code>NSPersistentStore</code>. For <code>CSSQLiteStore</code>s, this is always set to
/// \code
/// [NSSQLitePragmasOption: ["journal_mode": "WAL"]]
///
/// \endcode
@property (nonatomic, readonly, copy) NSDictionary * _Nullable storeOptions;
/// Called by the <code>CSDataStack</code> to perform actual deletion of the store file from disk. Do not call directly! The <code>sourceModel</code> argument is a hint for the existing store’s model version. For <code>CSSQLiteStore</code>, this converts the database’s WAL journaling mode to DELETE before deleting the file.
- (BOOL)cs_eraseStorageAndWaitWithMetadata:(NSDictionary * _Nonnull)metadata soureModelHint:(NSManagedObjectModel * _Nullable)soureModelHint error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
@end


/// The <code>CSSectionBy</code> serves as the Objective-C bridging type for <code>SectionBy</code>.
/// seealso:
/// <code>SectionBy</code>
SWIFT_CLASS("_TtC9CoreStore11CSSectionBy") SWIFT_AVAILABILITY(macos,introduced=10.12)
@interface CSSectionBy : NSObject
/// Initializes a <code>CSSectionBy</code> clause with the key path to use to group <code>CSListMonitor</code> objects into sections
/// \param sectionKeyPath the key path to use to group the objects into sections
///
///
/// returns:
/// a <code>CSSectionBy</code> clause with the key path to use to group <code>CSListMonitor</code> objects into sections
+ (CSSectionBy * _Nonnull)keyPath:(NSString * _Nonnull)sectionKeyPath SWIFT_WARN_UNUSED_RESULT;
/// Initializes a <code>CSSectionBy</code> clause with the key path to use to group <code>CSListMonitor</code> objects into sections, and a closure to transform the value for the key path to an appropriate section name
/// \param sectionKeyPath the key path to use to group the objects into sections
///
/// \param sectionIndexTransformer a closure to transform the value for the key path to an appropriate section name
///
///
/// returns:
/// a <code>CSSectionBy</code> clause with the key path to use to group <code>CSListMonitor</code> objects into sections
+ (CSSectionBy * _Nonnull)keyPath:(NSString * _Nonnull)sectionKeyPath sectionIndexTransformer:(NSString * _Nullable (^ _Nonnull)(NSString * _Nullable))sectionIndexTransformer SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class CSSelectTerm;

/// The <code>CSSelect</code> serves as the Objective-C bridging type for <code>Select</code>.
/// seealso:
/// <code>Select</code>
SWIFT_CLASS("_TtC9CoreStore8CSSelect")
@interface CSSelect : NSObject
/// Creates a <code>CSSelect</code> clause for querying <code>NSNumber</code> values.
/// \code
/// NSNumber *maxAge = [CSCoreStore
///    queryValueFrom:CSFromClass([MyPersonEntity class])
///    select:CSSelectNumber(CSAggregateMax(@"age"))
///    // ...
///
/// \endcode\param numberTerm the <code>CSSelectTerm</code> specifying the attribute/aggregate value to query
///
- (nonnull instancetype)initWithNumberTerm:(CSSelectTerm * _Nonnull)numberTerm;
/// Creates a <code>CSSelect</code> clause for querying <code>NSDecimalNumber</code> values.
/// \code
/// NSDecimalNumber *averagePrice = [CSCoreStore
///    queryValueFrom:CSFromClass([MyPersonEntity class])
///    select:CSSelectDecimal(CSAggregateAverage(@"price"))
///    // ...
///
/// \endcode\param decimalTerm the <code>CSSelectTerm</code> specifying the attribute/aggregate value to query
///
- (nonnull instancetype)initWithDecimalTerm:(CSSelectTerm * _Nonnull)decimalTerm;
/// Creates a <code>CSSelect</code> clause for querying <code>NSString</code> values.
/// \code
/// NSString *fullname = [CSCoreStore
///    queryValueFrom:CSFromClass([MyPersonEntity class])
///    select:CSSelectString(CSAttribute(@"fullname"))
///    // ...
///
/// \endcode\param stringTerm the <code>CSSelectTerm</code> specifying the attribute/aggregate value to query
///
- (nonnull instancetype)initWithStringTerm:(CSSelectTerm * _Nonnull)stringTerm;
/// Creates a <code>CSSelect</code> clause for querying <code>NSDate</code> values.
/// \code
/// NSDate *lastUpdate = [CSCoreStore
///    queryValueFrom:CSFromClass([MyPersonEntity class])
///    select:CSSelectDate(CSAggregateMax(@"updatedDate"))
///    // ...
///
/// \endcode\param dateTerm the <code>CSSelectTerm</code> specifying the attribute/aggregate value to query
///
- (nonnull instancetype)initWithDateTerm:(CSSelectTerm * _Nonnull)dateTerm;
/// Creates a <code>CSSelect</code> clause for querying <code>NSData</code> values.
/// \code
/// NSData *imageData = [CSCoreStore
///    queryValueFrom:CSFromClass([MyPersonEntity class])
///    select:CSSelectData(CSAttribute(@"imageData"))
///    // ...
///
/// \endcode\param dataTerm the <code>CSSelectTerm</code> specifying the attribute/aggregate value to query
///
- (nonnull instancetype)initWithDataTerm:(CSSelectTerm * _Nonnull)dataTerm;
/// Creates a <code>CSSelect</code> clause for querying <code>NSManagedObjectID</code> values.
/// \code
/// NSManagedObjectID *objectID = [CSCoreStore
///    queryValueFrom:CSFromClass([MyPersonEntity class])
///    select:CSSelectObjectID()
///    // ...
///
/// \endcode
- (nonnull instancetype)initWithObjectIDTerm;
/// Creates a <code>CSSelect</code> clause for querying <code>NSDictionary</code> of an entity’s attribute keys and values.
/// \code
/// NSDictionary *keyValues = [CSCoreStore
///     queryValueFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     select:[CSSelect dictionaryForTerm:[CSSelectTerm maximum:@"age" as:nil]]];
///
/// \endcode\param term the <code>CSSelectTerm</code> specifying the attribute/aggregate value to query
///
///
/// returns:
/// a <code>CSSelect</code> clause for querying an entity attribute
+ (CSSelect * _Nonnull)dictionaryForTerm:(CSSelectTerm * _Nonnull)term SWIFT_WARN_UNUSED_RESULT;
/// Creates a <code>CSSelect</code> clause for querying <code>NSDictionary</code> of an entity’s attribute keys and values.
/// \code
/// NSDictionary *keyValues = [CSCoreStore
///     queryValueFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     select:[CSSelect dictionaryForTerms:@[
///         [CSSelectTerm attribute:@"name" as:nil],
///         [CSSelectTerm attribute:@"age" as:nil]
///     ]]];
///
/// \endcode\param terms the <code>CSSelectTerm</code>s specifying the attribute/aggregate values to query
///
///
/// returns:
/// a <code>CSSelect</code> clause for querying an entity attribute
+ (CSSelect * _Nonnull)dictionaryForTerms:(NSArray<CSSelectTerm *> * _Nonnull)terms SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The <code>CSSelectTerm</code> serves as the Objective-C bridging type for <code>SelectTerm</code>.
/// seealso:
/// <code>SelectTerm</code>
SWIFT_CLASS("_TtC9CoreStore12CSSelectTerm")
@interface CSSelectTerm : NSObject
/// Provides a <code>CSSelectTerm</code> to a <code>CSSelect</code> clause for querying an entity attribute.
/// \code
/// NSString *fullName = [CSCoreStore
///     queryValueFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     select:CSSelectString(CSAttribute(@"fullname"))
///     fetchClauses:@[[CSWhere keyPath:@"employeeID" isEqualTo: @1111]]];
///
/// \endcode\param keyPath the attribute name
///
- (nonnull instancetype)initWithKeyPath:(NSString * _Nonnull)keyPath;
/// Provides a <code>CSSelectTerm</code> to a <code>CSSelect</code> clause for querying the average value of an attribute.
/// \code
/// NSNumber *averageAge = [CSCoreStore
///     queryValueFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     select:[CSSelect numberForTerm:[CSSelectTerm average:@"age" as:nil]]];
///
/// \endcode<ul>
///   <li>
///     <code>as</code>: the dictionary key to use to access the result. Ignored when the query return value is not an <code>NSDictionary</code>. If <code>nil</code>, the default key “average(<attributeName>)” is used
///   </li>
/// </ul>
/// \param keyPath the attribute name
///
///
/// returns:
/// a <code>CSSelectTerm</code> to a <code>CSSelect</code> clause for querying the average value of an attribute
+ (CSSelectTerm * _Nonnull)average:(NSString * _Nonnull)keyPath as:(NSString * _Nullable)alias SWIFT_WARN_UNUSED_RESULT;
/// Provides a <code>CSSelectTerm</code> to a <code>CSSelect</code> clause for a count query.
/// \code
/// NSNumber *numberOfEmployees = [CSCoreStore
///     queryValueFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     select:[CSSelect numberForTerm:[CSSelectTerm count:@"employeeID" as:nil]]];
///
/// \endcode\param keyPath the attribute name
///
/// \param alias the dictionary key to use to access the result. Ignored when the query return value is not an <code>NSDictionary</code>. If <code>nil</code>, the default key “count(<attributeName>)” is used
///
///
/// returns:
/// a <code>SelectTerm</code> to a <code>Select</code> clause for a count query
+ (CSSelectTerm * _Nonnull)count:(NSString * _Nonnull)keyPath as:(NSString * _Nullable)alias SWIFT_WARN_UNUSED_RESULT;
/// Provides a <code>CSSelectTerm</code> to a <code>CSSelect</code> clause for querying the maximum value for an attribute.
/// \code
/// NSNumber *maximumAge = [CSCoreStore
///     queryValueFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     select:[CSSelect numberForTerm:[CSSelectTerm maximum:@"age" as:nil]]];
///
/// \endcode\param keyPath the attribute name
///
/// \param alias the dictionary key to use to access the result. Ignored when the query return value is not an <code>NSDictionary</code>. If <code>nil</code>, the default key “max(<attributeName>)” is used
///
///
/// returns:
/// a <code>CSSelectTerm</code> to a <code>CSSelect</code> clause for querying the maximum value for an attribute
+ (CSSelectTerm * _Nonnull)maximum:(NSString * _Nonnull)keyPath as:(NSString * _Nullable)alias SWIFT_WARN_UNUSED_RESULT;
/// Provides a <code>CSSelectTerm</code> to a <code>CSSelect</code> clause for querying the minimum value for an attribute.
/// \code
/// NSNumber *minimumAge = [CSCoreStore
///     queryValueFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     select:[CSSelect numberForTerm:[CSSelectTerm minimum:@"age" as:nil]]];
///
/// \endcode\param keyPath the attribute name
///
/// \param alias the dictionary key to use to access the result. Ignored when the query return value is not an <code>NSDictionary</code>. If <code>nil</code>, the default key “min(<attributeName>)” is used
///
///
/// returns:
/// a <code>CSSelectTerm</code> to a <code>CSSelect</code> clause for querying the minimum value for an attribute
+ (CSSelectTerm * _Nonnull)minimum:(NSString * _Nonnull)keyPath as:(NSString * _Nullable)alias SWIFT_WARN_UNUSED_RESULT;
/// Provides a <code>CSSelectTerm</code> to a <code>CSSelect</code> clause for querying the sum value for an attribute.
/// \code
/// NSNumber *totalAge = [CSCoreStore
///     queryValueFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     select:[CSSelect numberForTerm:[CSSelectTerm sum:@"age" as:nil]]];
///
/// \endcode\param keyPath the attribute name
///
/// \param alias the dictionary key to use to access the result. Ignored when the query return value is not an <code>NSDictionary</code>. If <code>nil</code>, the default key “sum(<attributeName>)” is used
///
///
/// returns:
/// a <code>CSSelectTerm</code> to a <code>CSSelect</code> clause for querying the sum value for an attribute
+ (CSSelectTerm * _Nonnull)sum:(NSString * _Nonnull)keyPath as:(NSString * _Nullable)alias SWIFT_WARN_UNUSED_RESULT;
/// Provides a <code>CSSelectTerm</code> to a <code>CSSelect</code> clause for querying the <code>NSManagedObjectID</code>.
/// \code
/// NSManagedObjectID *objectID = [CSCoreStore
///     queryValueFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     select:[CSSelect objectIDForTerm:[CSSelectTerm objectIDAs:nil]]
///     fetchClauses:@[[CSWhere keyPath:@"employeeID" isEqualTo: @1111]]];
///
/// \endcode\param alias the dictionary key to use to access the result. Ignored when the query return value is not an <code>NSDictionary</code>. If <code>nil</code>, the default key “objecID” is used
///
///
/// returns:
/// a <code>SelectTerm</code> to a <code>Select</code> clause for querying the sum value for an attribute
+ (CSSelectTerm * _Nonnull)objectIDAs:(NSString * _Nullable)alias SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The <code>CSSetupResult</code> serves as the Objective-C bridging type for <code>SetupResult</code>.
/// seealso:
/// <code>SetupResult</code>
SWIFT_CLASS("_TtC9CoreStore13CSSetupResult") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSSetupResult : NSObject
/// <code>YES</code> if adding the <code>CSStorageInterface</code> to the <code>CSDataStack</code> succeeded, <code>NO</code> otherwise.
@property (nonatomic, readonly) BOOL isSuccess;
/// <code>YES</code> if adding the <code>CSStorageInterface</code> to the <code>CSDataStack</code> failed, <code>NO</code> otherwise. When <code>YES</code>, the <code>error</code> property returns the actual <code>NSError</code> for the failure.
@property (nonatomic, readonly) BOOL isFailure;
/// A <code>CSStorageInterface</code> instance if the <code>commit</code> operation for the transaction succeeded. Returns <code>nil</code> otherwise.
@property (nonatomic, readonly, strong) id <CSStorageInterface> _Nullable storage;
/// The <code>NSError</code> for a failed <code>commit</code> operation, or <code>nil</code> if the <code>commit</code> succeeded
@property (nonatomic, readonly, strong) NSError * _Nullable error;
/// If the result was a success, the <code>success</code> block is executed with the <code>CSStorageInterface</code> instance that was added to the <code>CSDataStack</code>. If the result was a failure, the <code>failure</code> block is executed with an <code>NSError</code> argument pertaining to the actual error.
/// The blocks are executed immediately as <code>@noescape</code> and will not be retained.
/// \param success the block to execute on success. The block passes a <code>CSStorageInterface</code> instance that was added to the <code>CSDataStack</code>.
///
/// \param failure the block to execute on failure. The block passes an <code>NSError</code> argument that pertains to the actual error.
///
- (void)handleSuccess:(SWIFT_NOESCAPE void (^ _Nonnull)(id <CSStorageInterface> _Nonnull))success failure:(SWIFT_NOESCAPE void (^ _Nonnull)(NSError * _Nonnull))failure;
/// If the result was a success, the <code>success</code> block is executed with a <code>BOOL</code> argument that indicates if there were any changes made. If the result was a failure, this method does nothing.
/// The block is executed immediately as <code>@noescape</code> and will not be retained.
/// \param success the block to execute on success. The block passes a <code>BOOL</code> argument that indicates if there were any changes made.
///
- (void)handleSuccess:(SWIFT_NOESCAPE void (^ _Nonnull)(id <CSStorageInterface> _Nonnull))success;
/// If the result was a failure, the <code>failure</code> block is executed with an <code>NSError</code> argument pertaining to the actual error. If the result was a success, this method does nothing.
/// The block is executed immediately as <code>@noescape</code> and will not be retained.
/// \param failure the block to execute on failure. The block passes an <code>NSError</code> argument that pertains to the actual error.
///
- (void)handleFailure:(SWIFT_NOESCAPE void (^ _Nonnull)(NSError * _Nonnull))failure;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



/// The <code>CSSynchronousDataTransaction</code> serves as the Objective-C bridging type for <code>SynchronousDataTransaction</code>.
/// seealso:
/// <code>SynchronousDataTransaction</code>
SWIFT_CLASS("_TtC9CoreStore28CSSynchronousDataTransaction") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSSynchronousDataTransaction : CSBaseDataTransaction
/// Saves the transaction changes and waits for completion synchronously. This method should not be used after the <code>-commitAndWaitWithError:</code> method was already called once.
/// \param error the <code>CSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// <code>YES</code> if the commit succeeded, <code>NO</code> if the commit failed. If <code>NO</code>, the <code>error</code> argument will hold error information.
- (BOOL)commitAndWaitWithError:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
/// Creates a new <code>NSManagedObject</code> with the specified entity type.
/// \param into the <code>CSInto</code> clause indicating the destination <code>NSManagedObject</code> entity type and the destination configuration
///
///
/// returns:
/// a new <code>NSManagedObject</code> instance of the specified entity type.
- (id _Nonnull)createInto:(CSInto * _Nonnull)into SWIFT_WARN_UNUSED_RESULT;
/// Returns an editable proxy of a specified <code>NSManagedObject</code>. This method should not be used after the <code>-commitAndWait</code> method was already called once.
/// \param object the <code>NSManagedObject</code> type to be edited
///
///
/// returns:
/// an editable proxy for the specified <code>NSManagedObject</code>.
- (id _Nullable)editObject:(NSManagedObject * _Nullable)object SWIFT_WARN_UNUSED_RESULT;
/// Returns an editable proxy of the object with the specified <code>NSManagedObjectID</code>. This method should not be used after the <code>-commitAndWait</code> method was already called once.
/// \param into a <code>CSInto</code> clause specifying the entity type
///
/// \param objectID the <code>NSManagedObjectID</code> for the object to be edited
///
///
/// returns:
/// an editable proxy for the specified <code>NSManagedObject</code>.
- (id _Nullable)editInto:(CSInto * _Nonnull)into objectID:(NSManagedObjectID * _Nonnull)objectID SWIFT_WARN_UNUSED_RESULT;
/// Deletes a specified <code>NSManagedObject</code>. This method should not be used after the <code>-commitAndWait</code> method was already called once.
/// \param object the <code>NSManagedObject</code> type to be deleted
///
- (void)deleteObject:(NSManagedObject * _Nullable)object;
/// Deletes the specified <code>NSManagedObject</code>s.
/// \param objects the <code>NSManagedObject</code>s to be deleted
///
- (void)deleteObjects:(NSArray<NSManagedObject *> * _Nonnull)objects;
@end


/// The <code>CSTweak</code> serves as the Objective-C bridging type for <code>Tweak</code>.
/// seealso:
/// <code>Tweak</code>
SWIFT_CLASS("_TtC9CoreStore7CSTweak") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSTweak : NSObject <CSDeleteClause, CSFetchClause, CSQueryClause>
/// The block to customize the <code>NSFetchRequest</code>
@property (nonatomic, readonly, copy) void (^ _Nonnull block)(NSFetchRequest<id <NSFetchRequestResult>> * _Nonnull);
/// Initializes a <code>CSTweak</code> clause with a closure where the <code>NSFetchRequest</code> may be configured.
/// important:
/// <code>CSTweak</code>’s closure is executed only just before the fetch occurs, so make sure that any values captured by the closure is not prone to race conditions. Also, some utilities (such as <code>CSListMonitor</code>s) may keep <code>CSFetchClause</code>s in memory and may thus introduce retain cycles if reference captures are not handled properly.
/// \param block the block to customize the <code>NSFetchRequest</code>
///
- (nonnull instancetype)initWithBlock:(void (^ _Nonnull)(NSFetchRequest<id <NSFetchRequestResult>> * _Nonnull))block;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (void)applyToFetchRequest:(NSFetchRequest<id <NSFetchRequestResult>> * _Nonnull)fetchRequest;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The <code>CSUnsafeDataModelSchema</code> serves as the Objective-C bridging type for <code>UnsafeDataModelSchema</code>.
/// seealso:
/// <code>UnsafeDataModelSchema</code>
SWIFT_CLASS("_TtC9CoreStore23CSUnsafeDataModelSchema") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSUnsafeDataModelSchema : NSObject <CSDynamicSchema>
/// Initializes a <code>CSUnsafeDataModelSchema</code> from an <code>NSManagedObjectModel</code>.
/// \param modelName the model version, typically the file name of an *.xcdatamodeld file (without the file extension)
///
/// \param model the <code>NSManagedObjectModel</code>
///
- (nonnull instancetype)initWithModelName:(NSString * _Nonnull)modelName model:(NSManagedObjectModel * _Nonnull)model OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
@property (nonatomic, readonly, copy) NSString * _Nonnull modelVersion;
- (NSManagedObjectModel * _Nonnull)rawModel SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class NSManagedObjectContext;

/// The <code>CSUnsafeDataTransaction</code> serves as the Objective-C bridging type for <code>UnsafeDataTransaction</code>.
/// seealso:
/// <code>UnsafeDataTransaction</code>
SWIFT_CLASS("_TtC9CoreStore23CSUnsafeDataTransaction") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSUnsafeDataTransaction : CSBaseDataTransaction
/// Saves the transaction changes asynchronously. For a <code>CSUnsafeDataTransaction</code>, multiple commits are allowed, although it is the developer’s responsibility to ensure a reasonable leeway to prevent blocking the main thread.
/// \param success the block executed if the save succeeds.
///
/// \param failure the block executed if the save fails. A <code>CSError</code> is reported as the argument of the block.
///
- (void)commitWithSuccess:(void (^ _Nullable)(void))success :(void (^ _Nullable)(CSError * _Nonnull))failure;
/// Saves the transaction changes and waits for completion synchronously. For a <code>CSUnsafeDataTransaction</code>, multiple commits are allowed, although it is the developer’s responsibility to ensure a reasonable leeway to prevent blocking the main thread.
/// \param error the <code>CSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// <code>YES</code> if the commit succeeded, <code>NO</code> if the commit failed. If <code>NO</code>, the <code>error</code> argument will hold error information.
- (BOOL)commitAndWaitWithError:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
/// Rolls back the transaction.
- (void)rollback;
/// Undo’s the last change made to the transaction.
- (void)undo;
/// Redo’s the last undone change to the transaction.
- (void)redo;
/// Immediately flushes all pending changes to the transaction’s observers. This is useful in conjunction with <code>ListMonitor</code>s and <code>ObjectMonitor</code>s created from <code>UnsafeDataTransaction</code>s used to manage temporary “scratch” data.
/// important:
/// Note that unlike <code>commit()</code>, <code>flush()</code> does not propagate/save updates to the <code>DataStack</code> and the persistent store. However, the flushed changes will be seen by children transactions created further from the current transaction (i.e. through <code>transaction.beginUnsafe()</code>)
- (void)flush;
/// Flushes all pending changes to the transaction’s observers at the end of the <code>closure</code>’s execution. This is useful in conjunction with <code>ListMonitor</code>s and <code>ObjectMonitor</code>s created from <code>UnsafeDataTransaction</code>s used to manage temporary “scratch” data.
/// important:
/// Note that unlike <code>commit()</code>, <code>flush()</code> does not propagate/save updates to the <code>DataStack</code> and the persistent store. However, the flushed changes will be seen by children transactions created further from the current transaction (i.e. through <code>transaction.beginUnsafe()</code>)
/// \param block the block where changes can be made prior to the flush
///
- (void)flush:(SWIFT_NOESCAPE void (^ _Nonnull)(void))block;
/// Begins a child transaction where <code>NSManagedObject</code> creates, updates, and deletes can be made. This is useful for making temporary changes, such as partially filled forms.
/// To support “undo” methods such as <code>-undo</code>, <code>-redo</code>, and <code>-rollback</code>, use the <code>-beginSafeWithSupportsUndo:</code> method passing <code>YES</code> to the argument. Without “undo” support, calling those methods will raise an exception.
///
/// returns:
/// a <code>CSUnsafeDataTransaction</code> instance where creates, updates, and deletes can be made.
- (CSUnsafeDataTransaction * _Nonnull)beginUnsafe SWIFT_WARN_UNUSED_RESULT;
/// Begins a child transaction where <code>NSManagedObject</code> creates, updates, and deletes can be made. This is useful for making temporary changes, such as partially filled forms.
/// <ul>
///   <li>
///     prameter supportsUndo: <code>-undo</code>, <code>-redo</code>, and <code>-rollback</code> methods are only available when this parameter is <code>YES</code>, otherwise those method will raise an exception. Note that turning on Undo support may heavily impact performance especially on iOS or watchOS where memory is limited.
///   </li>
/// </ul>
///
/// returns:
/// a <code>CSUnsafeDataTransaction</code> instance where creates, updates, and deletes can be made.
- (CSUnsafeDataTransaction * _Nonnull)beginUnsafeWithSupportsUndo:(BOOL)supportsUndo SWIFT_WARN_UNUSED_RESULT;
/// Returns the <code>NSManagedObjectContext</code> for this unsafe transaction. Use only for cases where external frameworks need an <code>NSManagedObjectContext</code> instance to work with.
/// Note that it is the developer’s responsibility to ensure the following:
/// <ul>
///   <li>
///     that the <code>CSUnsafeDataTransaction</code> that owns this context should be strongly referenced and prevented from being deallocated during the context’s lifetime
///   </li>
///   <li>
///     that all saves will be done either through the <code>CSUnsafeDataTransaction</code>’s <code>-commit:</code> or <code>-commitAndWait</code> method, or by calling <code>-save:</code> manually on the context, its parent, and all other ancestor contexts if there are any.
///   </li>
/// </ul>
- (NSManagedObjectContext * _Nonnull)unsafeContext SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
@end

@class NSPredicate;
@protocol CoreDataNativeType;

/// The <code>CSWhere</code> serves as the Objective-C bridging type for <code>Where</code>.
/// seealso:
/// <code>Where</code>
SWIFT_CLASS("_TtC9CoreStore7CSWhere")
@interface CSWhere : NSObject <CSDeleteClause, CSFetchClause, CSQueryClause>
/// The internal <code>NSPredicate</code> instance for the <code>Where</code> clause
@property (nonatomic, readonly, strong) NSPredicate * _Nonnull predicate;
/// Initializes a <code>CSWhere</code> clause with a predicate that always evaluates to the specified boolean value
/// \code
/// MyPersonEntity *people = [transaction
///    fetchAllFrom:CSFromClass([MyPersonEntity class])
///    fetchClauses:@[CSWhereValue(YES)]]];
///
/// \endcode\param value the boolean value for the predicate
///
- (nonnull instancetype)initWithValue:(BOOL)value;
/// Initializes a <code>CSWhere</code> clause with a predicate using the specified string format and arguments
/// \code
/// NSPredicate *predicate = // ...
/// MyPersonEntity *people = [transaction
///    fetchAllFrom:CSFromClass([MyPersonEntity class])
///    fetchClauses:@[CSWherePredicate(predicate)]];
///
/// \endcode\param format the format string for the predicate
///
/// \param argumentArray the arguments for <code>format</code>
///
- (nonnull instancetype)initWithFormat:(NSString * _Nonnull)format argumentArray:(NSArray<NSObject *> * _Nullable)argumentArray;
/// Initializes a <code>CSWhere</code> clause that compares equality
/// \param keyPath the keyPath to compare with
///
/// \param value the arguments for the <code>==</code> operator
///
- (nonnull instancetype)initWithKeyPath:(NSString * _Nonnull)keyPath isEqualTo:(id <CoreDataNativeType> _Nullable)value;
/// Initializes a <code>CSWhere</code> clause that compares membership
/// \param keyPath the keyPath to compare with
///
/// \param list the array to check membership of
///
- (nonnull instancetype)initWithKeyPath:(NSString * _Nonnull)keyPath isMemberOf:(NSArray<id <CoreDataNativeType>> * _Nonnull)list;
/// Initializes a <code>CSWhere</code> clause with an <code>NSPredicate</code>
/// \param predicate the <code>NSPredicate</code> for the fetch or query
///
- (nonnull instancetype)initWithPredicate:(NSPredicate * _Nonnull)predicate;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (void)applyToFetchRequest:(NSFetchRequest<id <NSFetchRequestResult>> * _Nonnull)fetchRequest;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The <code>CSXcodeDataModelSchema</code> serves as the Objective-C bridging type for <code>XcodeDataModelSchema</code>.
/// seealso:
/// <code>XcodeDataModelSchema</code>
SWIFT_CLASS("_TtC9CoreStore22CSXcodeDataModelSchema") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSXcodeDataModelSchema : NSObject <CSDynamicSchema>
/// Initializes an <code>CSXcodeDataModelSchema</code> from an *.xcdatamodeld file URL.
/// \param modelName the model version, typically the file name of an *.xcdatamodeld file (without the file extension)
///
/// \param modelVersionFileURL the file URL that points to the .xcdatamodeld’s “momd” file.
///
- (nonnull instancetype)initWithModelName:(NSString * _Nonnull)modelName modelVersionFileURL:(NSURL * _Nonnull)modelVersionFileURL OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
@property (nonatomic, readonly, copy) NSString * _Nonnull modelVersion;
- (NSManagedObjectModel * _Nonnull)rawModel SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Objective-C Foundation types that are natively supported by Core Data managed attributes all conform to <code>CoreDataNativeType</code>.
SWIFT_PROTOCOL("_TtP9CoreStore18CoreDataNativeType_")
@protocol CoreDataNativeType <NSObject>
@end


SWIFT_CLASS("_TtC9CoreStore22CoreStoreManagedObject")
@interface CoreStoreManagedObject : NSManagedObject
- (nonnull instancetype)initWithEntity:(NSEntityDescription * _Nonnull)entity insertIntoManagedObjectContext:(NSManagedObjectContext * _Nullable)context OBJC_DESIGNATED_INITIALIZER;
@end






@interface NSData (SWIFT_EXTENSION(CoreStore)) <CoreDataNativeType>
@end










@interface NSDate (SWIFT_EXTENSION(CoreStore)) <CoreDataNativeType>
@end








@interface NSDecimalNumber (SWIFT_EXTENSION(CoreStore))
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSAttributeType cs_rawAttributeType;)
+ (NSAttributeType)cs_rawAttributeType SWIFT_WARN_UNUSED_RESULT;
@end














@interface NSManagedObject (SWIFT_EXTENSION(CoreStore)) <CoreDataNativeType>
@end












@interface NSManagedObject (SWIFT_EXTENSION(CoreStore))
/// Provides a convenience wrapper for accessing <code>-primitiveValueForKey:</code> with proper calls to <code>-willAccessValueForKey:</code> and <code>-didAccessValueForKey:</code>. This is useful when implementing accessor methods for transient attributes.
/// \param KVCKey the KVC key
///
///
/// returns:
/// the primitive value for the KVC key
- (id _Nullable)cs_accessValueForKVCKey:(NSString * _Nonnull)KVCKey SWIFT_WARN_UNUSED_RESULT;
/// Provides a convenience wrapper for setting <code>-setPrimitiveValue:</code> with proper calls to <code>-willChangeValueForKey:</code> and <code>-didChangeValueForKey:</code>. This is useful when implementing mutator methods for transient attributes.
/// \param value the value to set the KVC key with
///
/// \param KVCKey the KVC key
///
- (void)cs_setValue:(id _Nullable)value forKVCKey:(NSString * _Nonnull)KVCKey;
/// Re-faults the object to use the latest values from the persistent store
- (void)cs_refreshAsFault;
@end






















@interface NSManagedObjectID (SWIFT_EXTENSION(CoreStore)) <CoreDataNativeType>
@end












@interface NSNull (SWIFT_EXTENSION(CoreStore)) <CoreDataNativeType>
@end






@interface NSNumber (SWIFT_EXTENSION(CoreStore)) <CoreDataNativeType>
@end






@interface NSNumber (SWIFT_EXTENSION(CoreStore))
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSAttributeType cs_rawAttributeType;)
+ (NSAttributeType)cs_rawAttributeType SWIFT_WARN_UNUSED_RESULT;
@end






@interface NSOrderedSet<ObjectType> (SWIFT_EXTENSION(CoreStore)) <CoreDataNativeType>
@end














@interface NSSet<ObjectType> (SWIFT_EXTENSION(CoreStore)) <CoreDataNativeType>
@end










@interface NSString (SWIFT_EXTENSION(CoreStore)) <CoreDataNativeType>
@end




























@interface NSProgress (SWIFT_EXTENSION(CoreStore))
/// Sets a closure that the <code>NSProgress</code> calls whenever its <code>fractionCompleted</code> changes. You can use this instead of setting up KVO.
/// \param closure the closure to execute on progress change
///
- (void)cs_setProgressHandler:(void (^ _Nullable)(NSProgress * _Nonnull))closure;
@end



#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop

#elif defined(__i386__) && __i386__
// Generated by Apple Swift version 5.1.3 (swiftlang-1100.0.282.1 clang-1100.0.33.15)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if !defined(IBSegueAction)
# define IBSegueAction
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import CoreData;
@import Foundation;
@import ObjectiveC;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="CoreStore",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif



@class CSInto;
@class NSManagedObject;
@class NSManagedObjectID;

/// The <code>CSBaseDataTransaction</code> serves as the Objective-C bridging type for <code>BaseDataTransaction</code>.
/// seealso:
/// <code>BaseDataTransaction</code>
SWIFT_CLASS("_TtC9CoreStore21CSBaseDataTransaction")
@interface CSBaseDataTransaction : NSObject
/// Indicates if the transaction has pending changes
@property (nonatomic, readonly) BOOL hasChanges;
/// Creates a new <code>NSManagedObject</code> with the specified entity type.
/// \param into the <code>CSInto</code> clause indicating the destination <code>NSManagedObject</code> entity type and the destination configuration
///
///
/// returns:
/// a new <code>NSManagedObject</code> instance of the specified entity type.
- (id _Nonnull)createInto:(CSInto * _Nonnull)into SWIFT_WARN_UNUSED_RESULT;
/// Returns an editable proxy of a specified <code>NSManagedObject</code>.
/// \param object the <code>NSManagedObject</code> type to be edited
///
///
/// returns:
/// an editable proxy for the specified <code>NSManagedObject</code>.
- (id _Nullable)editObject:(NSManagedObject * _Nullable)object SWIFT_WARN_UNUSED_RESULT;
/// Returns an editable proxy of the object with the specified <code>NSManagedObjectID</code>.
/// \param into a <code>CSInto</code> clause specifying the entity type
///
/// \param objectID the <code>NSManagedObjectID</code> for the object to be edited
///
///
/// returns:
/// an editable proxy for the specified <code>NSManagedObject</code>.
- (id _Nullable)editInto:(CSInto * _Nonnull)into objectID:(NSManagedObjectID * _Nonnull)objectID SWIFT_WARN_UNUSED_RESULT;
/// Deletes a specified <code>NSManagedObject</code>.
/// \param object the <code>NSManagedObject</code> to be deleted
///
- (void)deleteObject:(NSManagedObject * _Nullable)object;
/// Deletes the specified <code>NSManagedObject</code>s.
/// \param objects the <code>NSManagedObject</code>s to be deleted
///
- (void)deleteObjects:(NSArray<NSManagedObject *> * _Nonnull)objects;
/// Refreshes all registered objects <code>NSManagedObject</code>s in the transaction.
- (void)refreshAndMergeAllObjects;
/// Returns all pending <code>NSManagedObject</code>s of the specified type that were inserted to the transaction. This method should not be called after the <code>-commit*:</code> method was called.
/// \param entity the <code>NSManagedObject</code> subclass to filter
///
///
/// returns:
/// an <code>NSSet</code> of pending <code>NSManagedObject</code>s of the specified type that were inserted to the transaction.
- (NSSet<NSManagedObject *> * _Nonnull)insertedObjectsOfType:(SWIFT_METATYPE(NSManagedObject) _Nonnull)entity SWIFT_WARN_UNUSED_RESULT;
/// Returns all pending <code>NSManagedObjectID</code>s that were inserted to the transaction. This method should not be called after the <code>-commit*:</code> method was called.
///
/// returns:
/// an <code>NSSet</code> of pending <code>NSManagedObjectID</code>s that were inserted to the transaction.
- (NSSet<NSManagedObjectID *> * _Nonnull)insertedObjectIDs SWIFT_WARN_UNUSED_RESULT;
/// Returns all pending <code>NSManagedObjectID</code>s of the specified type that were inserted to the transaction. This method should not be called after the <code>-commit*:</code> method was called.
/// \param entity the <code>NSManagedObject</code> subclass to filter
///
///
/// returns:
/// an <code>NSSet</code> of pending <code>NSManagedObjectID</code>s of the specified type that were inserted to the transaction.
- (NSSet<NSManagedObjectID *> * _Nonnull)insertedObjectIDsOfType:(SWIFT_METATYPE(NSManagedObject) _Nonnull)entity SWIFT_WARN_UNUSED_RESULT;
/// Returns all pending <code>NSManagedObject</code>s of the specified type that were updated in the transaction. This method should not be called after the <code>-commit*:</code> method was called.
/// \param entity the <code>NSManagedObject</code> subclass to filter
///
///
/// returns:
/// an <code>NSSet</code> of pending <code>NSManagedObject</code>s of the specified type that were updated in the transaction.
- (NSSet<NSManagedObject *> * _Nonnull)updatedObjectsOfType:(SWIFT_METATYPE(NSManagedObject) _Nonnull)entity SWIFT_WARN_UNUSED_RESULT;
/// Returns all pending <code>NSManagedObjectID</code>s that were updated in the transaction. This method should not be called after the <code>-commit*:</code> method was called.
///
/// returns:
/// an <code>NSSet</code> of pending <code>NSManagedObjectID</code>s that were updated in the transaction.
- (NSSet<NSManagedObjectID *> * _Nonnull)updatedObjectIDs SWIFT_WARN_UNUSED_RESULT;
/// Returns all pending <code>NSManagedObjectID</code>s of the specified type that were updated in the transaction. This method should not be called after the <code>-commit*:</code> method was called.
/// \param entity the <code>NSManagedObject</code> subclass to filter
///
///
/// returns:
/// an <code>NSSet</code> of pending <code>NSManagedObjectID</code>s of the specified type that were updated in the transaction.
- (NSSet<NSManagedObjectID *> * _Nonnull)updatedObjectIDsOfType:(SWIFT_METATYPE(NSManagedObject) _Nonnull)entity SWIFT_WARN_UNUSED_RESULT;
/// Returns all pending <code>NSManagedObject</code>s of the specified type that were deleted from the transaction. This method should not be called after the <code>-commit*:</code> method was called.
/// \param entity the <code>NSManagedObject</code> subclass to filter
///
///
/// returns:
/// an <code>NSSet</code> of pending <code>NSManagedObject</code>s of the specified type that were deleted from the transaction.
- (NSSet<NSManagedObject *> * _Nonnull)deletedObjectsOfType:(SWIFT_METATYPE(NSManagedObject) _Nonnull)entity SWIFT_WARN_UNUSED_RESULT;
/// Returns all pending <code>NSManagedObjectID</code>s of the specified type that were deleted from the transaction. This method should not be called after the <code>-commit*:</code> method was called.
///
/// returns:
/// an <code>NSSet</code> of pending <code>NSManagedObjectID</code>s of the specified type that were deleted from the transaction.
- (NSSet<NSManagedObjectID *> * _Nonnull)deletedObjectIDs SWIFT_WARN_UNUSED_RESULT;
/// Returns all pending <code>NSManagedObjectID</code>s of the specified type that were deleted from the transaction. This method should not be called after the <code>-commit*:</code> method was called.
/// \param entity the <code>NSManagedObject</code> subclass to filter
///
///
/// returns:
/// a <code>Set</code> of pending <code>NSManagedObjectID</code>s of the specified type that were deleted from the transaction.
- (NSSet<NSManagedObjectID *> * _Nonnull)deletedObjectIDsOfType:(SWIFT_METATYPE(NSManagedObject) _Nonnull)entity SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class CSError;

/// The <code>CSAsynchronousDataTransaction</code> serves as the Objective-C bridging type for <code>AsynchronousDataTransaction</code>.
/// seealso:
/// <code>AsynchronousDataTransaction</code>
SWIFT_CLASS("_TtC9CoreStore29CSAsynchronousDataTransaction") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSAsynchronousDataTransaction : CSBaseDataTransaction
/// Saves the transaction changes. This method should not be used after the <code>-commitWithCompletion:</code> method was already called once.
/// \param success the block executed if the save succeeds.
///
/// \param failure the block executed if the save fails. A <code>CSError</code> is reported as the argument of the block.
///
- (void)commitWithSuccess:(void (^ _Nullable)(void))success failure:(void (^ _Nullable)(CSError * _Nonnull))failure;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
/// Creates a new <code>NSManagedObject</code> with the specified entity type.
/// \param into the <code>CSInto</code> clause indicating the destination <code>NSManagedObject</code> entity type and the destination configuration
///
///
/// returns:
/// a new <code>NSManagedObject</code> instance of the specified entity type.
- (id _Nonnull)createInto:(CSInto * _Nonnull)into SWIFT_WARN_UNUSED_RESULT;
/// Returns an editable proxy of a specified <code>NSManagedObject</code>. This method should not be used after the <code>-commitWithCompletion:</code> method was already called once.
/// \param object the <code>NSManagedObject</code> type to be edited
///
///
/// returns:
/// an editable proxy for the specified <code>NSManagedObject</code>.
- (id _Nullable)editObject:(NSManagedObject * _Nullable)object SWIFT_WARN_UNUSED_RESULT;
/// Returns an editable proxy of the object with the specified <code>NSManagedObjectID</code>. This method should not be used after the <code>-commitWithCompletion:</code> method was already called once.
/// \param into a <code>CSInto</code> clause specifying the entity type
///
/// \param objectID the <code>NSManagedObjectID</code> for the object to be edited
///
///
/// returns:
/// an editable proxy for the specified <code>NSManagedObject</code>.
- (id _Nullable)editInto:(CSInto * _Nonnull)into objectID:(NSManagedObjectID * _Nonnull)objectID SWIFT_WARN_UNUSED_RESULT;
/// Deletes a specified <code>NSManagedObject</code>. This method should not be used after the <code>-commitWithCompletion:</code> method was already called once.
/// \param object the <code>NSManagedObject</code> type to be deleted
///
- (void)deleteObject:(NSManagedObject * _Nullable)object;
/// Deletes the specified <code>NSManagedObject</code>s.
/// \param objects the <code>NSManagedObject</code>s type to be deleted
///
- (void)deleteObjects:(NSArray<NSManagedObject *> * _Nonnull)objects;
@end


@class CSFrom;
@protocol CSFetchClause;
@class NSNumber;
@class CSSelect;
@protocol CSQueryClause;

@interface CSBaseDataTransaction (SWIFT_EXTENSION(CoreStore))
/// Fetches the <code>NSManagedObject</code> instance in the transaction’s context from a reference created from a transaction or from a different managed object context.
/// \param object a reference to the object created/fetched outside the transaction
///
///
/// returns:
/// the <code>NSManagedObject</code> instance if the object exists in the transaction, or <code>nil</code> if not found.
- (id _Nullable)fetchExistingObject:(NSManagedObject * _Nonnull)object SWIFT_WARN_UNUSED_RESULT;
/// Fetches the <code>NSManagedObject</code> instance in the transaction’s context from an <code>NSManagedObjectID</code>.
/// \param objectID the <code>NSManagedObjectID</code> for the object
///
///
/// returns:
/// the <code>NSManagedObject</code> instance if the object exists in the transaction, or <code>nil</code> if not found.
- (id _Nullable)fetchExistingObjectWithID:(NSManagedObjectID * _Nonnull)objectID SWIFT_WARN_UNUSED_RESULT;
/// Fetches the <code>NSManagedObject</code> instances in the transaction’s context from references created from a transaction or from a different managed object context.
/// \param objects an array of <code>NSManagedObject</code>s created/fetched outside the transaction
///
///
/// returns:
/// the <code>NSManagedObject</code> array for objects that exists in the transaction
- (NSArray * _Nonnull)fetchExistingObjects:(NSArray<NSManagedObject *> * _Nonnull)objects SWIFT_WARN_UNUSED_RESULT;
/// Fetches the <code>NSManagedObject</code> instances in the transaction’s context from a list of <code>NSManagedObjectID</code>.
/// \param objectIDs the <code>NSManagedObjectID</code> array for the objects
///
///
/// returns:
/// the <code>NSManagedObject</code> array for objects that exists in the transaction
- (NSArray * _Nonnull)fetchExistingObjectsWithIDs:(NSArray<NSManagedObjectID *> * _Nonnull)objectIDs SWIFT_WARN_UNUSED_RESULT;
/// Fetches the first <code>NSManagedObject</code> instance that satisfies the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>From</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the first <code>NSManagedObject</code> instance that satisfies the specified <code>CSFetchClause</code>s
- (id _Nullable)fetchOneFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Fetches all <code>NSManagedObject</code> instances that satisfy the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// all <code>NSManagedObject</code> instances that satisfy the specified <code>CSFetchClause</code>s
- (NSArray * _Nullable)fetchAllFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Fetches the number of <code>NSManagedObject</code>s that satisfy the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the number <code>NSManagedObject</code>s that satisfy the specified <code>CSFetchClause</code>s
- (NSNumber * _Nullable)fetchCountFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Fetches the <code>NSManagedObjectID</code> for the first <code>NSManagedObject</code> that satisfies the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the <code>NSManagedObjectID</code> for the first <code>NSManagedObject</code> that satisfies the specified <code>CSFetchClause</code>s
- (NSManagedObjectID * _Nullable)fetchObjectIDFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Queries aggregate values as specified by the <code>CSQueryClause</code>s. Requires at least a <code>CSSelect</code> clause, and optional <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
/// A “query” differs from a “fetch” in that it only retrieves values already stored in the persistent store. As such, values from unsaved transactions or contexts will not be incorporated in the query result.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param selectClause a <code>CSSelect</code> clause indicating the properties to fetch, and with the generic type indicating the return type.
///
/// \param queryClauses a series of <code>CSQueryClause</code> instances for the query request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the result of the the query. The type of the return value is specified by the generic type of the <code>CSSelect</code> parameter.
- (id _Nullable)queryValueFrom:(CSFrom * _Nonnull)from selectClause:(CSSelect * _Nonnull)selectClause queryClauses:(NSArray<id <CSQueryClause>> * _Nonnull)queryClauses SWIFT_WARN_UNUSED_RESULT;
/// Queries a dictionary of attribute values as specified by the <code>CSQueryClause</code>s. Requires at least a <code>CSSelect</code> clause, and optional <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
/// A “query” differs from a “fetch” in that it only retrieves values already stored in the persistent store. As such, values from unsaved transactions or contexts will not be incorporated in the query result.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param selectClause a <code>CSSelect</code> clause indicating the properties to fetch, and with the generic type indicating the return type.
///
/// \param queryClauses a series of <code>CSQueryClause</code> instances for the query request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the result of the the query. The type of the return value is specified by the generic type of the <code>CSSelect</code> parameter.
- (NSArray<NSDictionary<NSString *, id> *> * _Nullable)queryAttributesFrom:(CSFrom * _Nonnull)from selectClause:(CSSelect * _Nonnull)selectClause queryClauses:(NSArray<id <CSQueryClause>> * _Nonnull)queryClauses SWIFT_WARN_UNUSED_RESULT;
@end

@class CSDataStack;

/// The <code>CSCoreStore</code> serves as the Objective-C bridging type for <code>CoreStore</code>.
/// seealso:
/// <code>CoreStore</code>
SWIFT_CLASS("_TtC9CoreStore11CSCoreStore") SWIFT_DEPRECATED_MSG("Call methods directly from the CSDataStack instead")
@interface CSCoreStore : NSObject
/// The default <code>CSDataStack</code> instance to be used. If <code>defaultStack</code> is not set before the first time accessed, a default-configured <code>CSDataStack</code> will be created.
/// seealso:
/// <code>CSDataStack</code>
/// note:
/// Changing the <code>defaultStack</code> is thread safe, but it is recommended to setup <code>CSDataStacks</code> on a common queue (e.g. the main queue).
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) CSDataStack * _Nonnull defaultStack;)
+ (CSDataStack * _Nonnull)defaultStack SWIFT_WARN_UNUSED_RESULT;
+ (void)setDefaultStack:(CSDataStack * _Nonnull)newValue;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class CSSQLiteStore;
@class CSMigrationResult;
@class NSError;
@class NSProgress;
@class CSMigrationType;

SWIFT_DEPRECATED_MSG("Call methods directly from the CSDataStack instead")
@interface CSCoreStore (SWIFT_EXTENSION(CoreStore))
/// Migrates a <code>CSSQLiteStore</code> to match the <code>defaultStack</code>’s managed object model version. This method does NOT add the migrated store to the data stack.
/// \param storage the <code>CSSQLiteStore</code> instance
///
/// \param completion the closure to be executed on the main queue when the migration completes, either due to success or failure. The closure’s <code>CSMigrationResult</code> argument indicates the result. This closure is NOT executed if an error is thrown, but will be executed with a failure <code>CSSetupResult</code> result if an error occurs asynchronously.
///
/// \param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// an <code>NSProgress</code> instance if a migration has started. <code>nil</code> if no migrations are required or if <code>error</code> was set.
+ (NSProgress * _Nullable)upgradeStorageIfNeeded:(CSSQLiteStore * _Nonnull)storage completion:(void (^ _Nonnull)(CSMigrationResult * _Nonnull))completion error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
/// Checks the migration steps required for the <code>CSSQLiteStore</code> to match the <code>defaultStack</code>’s managed object model version.
/// \param storage the <code>CSSQLiteStore</code> instance
///
/// \param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// a <code>CSMigrationType</code> array indicating the migration steps required for the store, or an empty array if the file does not exist yet. Otherwise, <code>nil</code> is returned and the <code>error</code> argument is set if either inspection of the store failed, or if no mapping model was found/inferred.
+ (NSArray<CSMigrationType *> * _Nullable)requiredMigrationsForSQLiteStore:(CSSQLiteStore * _Nonnull)storage error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
@end

@class CSObjectMonitor;
@class CSListMonitor;
@class CSSectionBy;

SWIFT_AVAILABILITY(macos,introduced=10.12) SWIFT_DEPRECATED_MSG("Call methods directly from the CSDataStack instead")
@interface CSCoreStore (SWIFT_EXTENSION(CoreStore))
/// Using the <code>defaultStack</code>, creates an <code>CSObjectMonitor</code> for the specified <code>NSManagedObject</code>. Multiple <code>CSObjectObserver</code>s may then register themselves to be notified when changes are made to the <code>NSManagedObject</code>.
/// \param object the <code>NSManagedObject</code> to observe changes from
///
///
/// returns:
/// a <code>CSObjectMonitor</code> that monitors changes to <code>object</code>
+ (CSObjectMonitor * _Nonnull)monitorObject:(NSManagedObject * _Nonnull)object SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, creates a <code>CSListMonitor</code> for a list of <code>NSManagedObject</code>s that satisfy the specified fetch clauses. Multiple <code>CSListObserver</code>s may then register themselves to be notified when changes are made to the list.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for fetching the object list. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// a <code>CSListMonitor</code> instance that monitors changes to the list
+ (CSListMonitor * _Nonnull)monitorListFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, asynchronously creates a <code>CSListMonitor</code> for a list of <code>NSManagedObject</code>s that satisfy the specified fetch clauses. Multiple <code>CSListObserver</code>s may then register themselves to be notified when changes are made to the list. Since <code>NSFetchedResultsController</code> greedily locks the persistent store on initial fetch, you may prefer this method instead of the synchronous counterpart to avoid deadlocks while background updates/saves are being executed.
/// \param createAsynchronously the closure that receives the created <code>CSListMonitor</code> instance
///
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for fetching the object list. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
+ (void)monitorListByCreatingAsynchronously:(void (^ _Nonnull)(CSListMonitor * _Nonnull))createAsynchronously from:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses;
/// Using the <code>defaultStack</code>, creates a <code>CSListMonitor</code> for a sectioned list of <code>NSManagedObject</code>s that satisfy the specified fetch clauses. Multiple <code>CSListObserver</code>s may then register themselves to be notified when changes are made to the list.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param sectionBy a <code>CSSectionBy</code> clause indicating the keyPath for the attribute to use when sorting the list into sections.
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for fetching the object list. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// a <code>CSListMonitor</code> instance that monitors changes to the list
+ (CSListMonitor * _Nonnull)monitorSectionedListFrom:(CSFrom * _Nonnull)from sectionBy:(CSSectionBy * _Nonnull)sectionBy fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, asynchronously creates a <code>CSListMonitor</code> for a sectioned list of <code>NSManagedObject</code>s that satisfy the specified fetch clauses. Multiple <code>CSListObserver</code>s may then register themselves to be notified when changes are made to the list. Since <code>NSFetchedResultsController</code> greedily locks the persistent store on initial fetch, you may prefer this method instead of the synchronous counterpart to avoid deadlocks while background updates/saves are being executed.
/// \param createAsynchronously the closure that receives the created <code>CSListMonitor</code> instance
///
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param sectionBy a <code>CSSectionBy</code> clause indicating the keyPath for the attribute to use when sorting the list into sections.
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for fetching the object list. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
+ (void)monitorSectionedListByCreatingAsynchronously:(void (^ _Nonnull)(CSListMonitor * _Nonnull))createAsynchronously from:(CSFrom * _Nonnull)from sectionBy:(CSSectionBy * _Nonnull)sectionBy fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses;
@end

@class CSSynchronousDataTransaction;
@class CSUnsafeDataTransaction;

SWIFT_DEPRECATED_MSG("Call methods directly from the CSDataStack instead")
@interface CSCoreStore (SWIFT_EXTENSION(CoreStore))
/// Using the <code>defaultStack</code>, begins a transaction asynchronously where <code>NSManagedObject</code> creates, updates, and deletes can be made.
/// \param closure the block where creates, updates, and deletes can be made to the transaction. Transaction blocks are executed serially in a background queue, and all changes are made from a concurrent <code>NSManagedObjectContext</code>.
///
+ (void)beginAsynchronous:(void (^ _Nonnull)(CSAsynchronousDataTransaction * _Nonnull))closure;
/// Using the <code>defaultStack</code>, begins a transaction synchronously where <code>NSManagedObject</code> creates, updates, and deletes can be made.
/// \param closure the block where creates, updates, and deletes can be made to the transaction. Transaction blocks are executed serially in a background queue, and all changes are made from a concurrent <code>NSManagedObjectContext</code>.
///
///
/// returns:
/// <code>YES</code> if the commit succeeded, <code>NO</code> if the commit failed. If <code>NO</code>, the <code>error</code> argument will hold error information.
+ (BOOL)beginSynchronous:(void (^ _Nonnull)(CSSynchronousDataTransaction * _Nonnull))closure error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, begins a child transaction where <code>NSManagedObject</code> creates, updates, and deletes can be made. This is useful for making temporary changes, such as partially filled forms.
/// To support “undo” methods such as <code>-undo</code>, <code>-redo</code>, and <code>-rollback</code>, use the <code>-beginSafeWithSupportsUndo:</code> method passing <code>YES</code> to the argument. Without “undo” support, calling those methods will raise an exception.
///
/// returns:
/// a <code>CSUnsafeDataTransaction</code> instance where creates, updates, and deletes can be made.
+ (CSUnsafeDataTransaction * _Nonnull)beginUnsafe SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, begins a child transaction where <code>NSManagedObject</code> creates, updates, and deletes can be made. This is useful for making temporary changes, such as partially filled forms.
/// <ul>
///   <li>
///     prameter supportsUndo: <code>-undo</code>, <code>-redo</code>, and <code>-rollback</code> methods are only available when this parameter is <code>YES</code>, otherwise those method will raise an exception. Note that turning on Undo support may heavily impact performance especially on iOS or watchOS where memory is limited.
///   </li>
/// </ul>
///
/// returns:
/// a <code>CSUnsafeDataTransaction</code> instance where creates, updates, and deletes can be made.
+ (CSUnsafeDataTransaction * _Nonnull)beginUnsafeWithSupportsUndo:(BOOL)supportsUndo SWIFT_WARN_UNUSED_RESULT;
/// Refreshes all registered objects <code>NSManagedObject</code>s in the <code>defaultStack</code>.
+ (void)refreshAndMergeAllObjects;
@end

@class NSEntityDescription;
@class CSInMemoryStore;

SWIFT_DEPRECATED_MSG("Call methods directly from the CSDataStack instead")
@interface CSCoreStore (SWIFT_EXTENSION(CoreStore))
/// Returns the <code>defaultStack</code>’s model version. The version string is the same as the name of the version-specific .xcdatamodeld file.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull modelVersion;)
+ (NSString * _Nonnull)modelVersion SWIFT_WARN_UNUSED_RESULT;
/// Returns the entity name-to-class type mapping from the <code>defaultStack</code>’s model.
+ (NSDictionary<NSString *, SWIFT_METATYPE(NSManagedObject)> * _Nonnull)entityTypesByNameForType:(SWIFT_METATYPE(NSManagedObject) _Nonnull)type SWIFT_WARN_UNUSED_RESULT;
/// Returns the <code>NSEntityDescription</code> for the specified <code>NSManagedObject</code> subclass from <code>defaultStack</code>’s model.
+ (NSEntityDescription * _Nullable)entityDescriptionForClass:(SWIFT_METATYPE(NSManagedObject) _Nonnull)type SWIFT_WARN_UNUSED_RESULT;
/// Creates an <code>CSInMemoryStore</code> with default parameters and adds it to the <code>defaultStack</code>. This method blocks until completion.
/// \code
/// CSSQLiteStore *storage = [CSCoreStore addInMemoryStorageAndWaitAndReturnError:&error];
///
/// \endcode\param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// the <code>CSInMemoryStore</code> added to the <code>defaultStack</code>
+ (CSInMemoryStore * _Nullable)addInMemoryStorageAndWaitAndReturnError:(NSError * _Nullable * _Nullable)error;
/// Creates an <code>CSSQLiteStore</code> with default parameters and adds it to the <code>defaultStack</code>. This method blocks until completion.
/// \code
/// CSSQLiteStore *storage = [CSCoreStore addSQLiteStorageAndWaitAndReturnError:&error];
///
/// \endcode\param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// the <code>CSSQLiteStore</code> added to the <code>defaultStack</code>
+ (CSSQLiteStore * _Nullable)addSQLiteStorageAndWaitAndReturnError:(NSError * _Nullable * _Nullable)error;
/// Adds a <code>CSInMemoryStore</code> to the <code>defaultStack</code> and blocks until completion.
/// \code
/// NSError *error;
/// CSInMemoryStore *storage = [CSCoreStore
///     addStorageAndWait: [[CSInMemoryStore alloc] initWithConfiguration: @"Config1"]
///     error: &error];
///
/// \endcode\param storage the <code>CSInMemoryStore</code>
///
/// \param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// the <code>CSInMemoryStore</code> added to the <code>defaultStack</code>
+ (CSInMemoryStore * _Nullable)addInMemoryStorageAndWait:(CSInMemoryStore * _Nonnull)storage error:(NSError * _Nullable * _Nullable)error;
/// Adds a <code>CSSQLiteStore</code> to the <code>defaultStack</code> and blocks until completion.
/// \code
/// NSError *error;
/// CSSQLiteStore *storage = [CSCoreStore
///     addStorageAndWait: [[CSSQLiteStore alloc] initWithConfiguration: @"Config1"]
///     error: &error];
///
/// \endcode\param storage the <code>CSSQLiteStore</code>
///
/// \param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// the <code>CSSQLiteStore</code> added to the <code>defaultStack</code>
+ (CSSQLiteStore * _Nullable)addSQLiteStorageAndWait:(CSSQLiteStore * _Nonnull)storage error:(NSError * _Nullable * _Nullable)error;
@end


SWIFT_DEPRECATED_MSG("Call methods directly from the DataStack instead")
@interface CSCoreStore (SWIFT_EXTENSION(CoreStore))
/// Using the <code>defaultStack</code>, fetches the <code>NSManagedObject</code> instance in the transaction’s context from a reference created from a transaction or from a different managed object context.
/// \param object a reference to the object created/fetched outside the transaction
///
///
/// returns:
/// the <code>NSManagedObject</code> instance if the object exists in the transaction, or <code>nil</code> if not found.
+ (id _Nullable)fetchExistingObject:(NSManagedObject * _Nonnull)object SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, fetches the <code>NSManagedObject</code> instance in the transaction’s context from an <code>NSManagedObjectID</code>.
/// \param objectID the <code>NSManagedObjectID</code> for the object
///
///
/// returns:
/// the <code>NSManagedObject</code> instance if the object exists in the transaction, or <code>nil</code> if not found.
+ (id _Nullable)fetchExistingObjectWithID:(NSManagedObjectID * _Nonnull)objectID SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, fetches the <code>NSManagedObject</code> instances in the transaction’s context from references created from a transaction or from a different managed object context.
/// \param objects an array of <code>NSManagedObject</code>s created/fetched outside the transaction
///
///
/// returns:
/// the <code>NSManagedObject</code> array for objects that exists in the transaction
+ (NSArray * _Nonnull)fetchExistingObjects:(NSArray<NSManagedObject *> * _Nonnull)objects SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, fetches the <code>NSManagedObject</code> instances in the transaction’s context from a list of <code>NSManagedObjectID</code>.
/// \param objectIDs the <code>NSManagedObjectID</code> array for the objects
///
///
/// returns:
/// the <code>NSManagedObject</code> array for objects that exists in the transaction
+ (NSArray * _Nonnull)fetchExistingObjectsWithIDs:(NSArray<NSManagedObjectID *> * _Nonnull)objectIDs SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, fetches the first <code>NSManagedObject</code> instance that satisfies the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>From</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the first <code>NSManagedObject</code> instance that satisfies the specified <code>CSFetchClause</code>s
+ (id _Nullable)fetchOneFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, fetches all <code>NSManagedObject</code> instances that satisfy the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// all <code>NSManagedObject</code> instances that satisfy the specified <code>CSFetchClause</code>s
+ (NSArray * _Nullable)fetchAllFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, fetches the number of <code>NSManagedObject</code>s that satisfy the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the number <code>NSManagedObject</code>s that satisfy the specified <code>CSFetchClause</code>s
+ (NSNumber * _Nullable)fetchCountFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, fetches the <code>NSManagedObjectID</code> for the first <code>NSManagedObject</code> that satisfies the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the <code>NSManagedObjectID</code> for the first <code>NSManagedObject</code> that satisfies the specified <code>CSFetchClause</code>s
+ (NSManagedObjectID * _Nullable)fetchObjectIDFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, fetches the <code>NSManagedObjectID</code> for all <code>NSManagedObject</code>s that satisfy the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>FetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the <code>NSManagedObjectID</code> for all <code>NSManagedObject</code>s that satisfy the specified <code>CSFetchClause</code>s
+ (NSArray<NSManagedObjectID *> * _Nullable)fetchObjectIDsFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, queries aggregate values as specified by the <code>CSQueryClause</code>s. Requires at least a <code>CSSelect</code> clause, and optional <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
/// A “query” differs from a “fetch” in that it only retrieves values already stored in the persistent store. As such, values from unsaved transactions or contexts will not be incorporated in the query result.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param selectClause a <code>CSSelect</code> clause indicating the properties to fetch, and with the generic type indicating the return type.
///
/// \param queryClauses a series of <code>CSQueryClause</code> instances for the query request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the result of the the query. The type of the return value is specified by the generic type of the <code>CSSelect</code> parameter.
+ (id _Nullable)queryValueFrom:(CSFrom * _Nonnull)from selectClause:(CSSelect * _Nonnull)selectClause queryClauses:(NSArray<id <CSQueryClause>> * _Nonnull)queryClauses SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, queries a dictionary of attribute values as specified by the <code>CSQueryClause</code>s. Requires at least a <code>CSSelect</code> clause, and optional <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
/// A “query” differs from a “fetch” in that it only retrieves values already stored in the persistent store. As such, values from unsaved transactions or contexts will not be incorporated in the query result.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param selectClause a <code>CSSelect</code> clause indicating the properties to fetch, and with the generic type indicating the return type.
///
/// \param queryClauses a series of <code>CSQueryClause</code> instances for the query request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the result of the the query. The type of the return value is specified by the generic type of the <code>CSSelect</code> parameter.
+ (NSArray<NSDictionary<NSString *, id> *> * _Nullable)queryAttributesFrom:(CSFrom * _Nonnull)from selectClause:(CSSelect * _Nonnull)selectClause queryClauses:(NSArray<id <CSQueryClause>> * _Nonnull)queryClauses SWIFT_WARN_UNUSED_RESULT;
@end


/// The <code>CSDataStack</code> serves as the Objective-C bridging type for <code>DataStack</code>.
/// seealso:
/// <code>DataStack</code>
SWIFT_CLASS("_TtC9CoreStore11CSDataStack") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSDataStack : NSObject
/// Initializes a <code>CSDataStack</code> with default settings. CoreStore searches for <CFBundleName>.xcdatamodeld from the main <code>NSBundle</code> and loads an <code>NSManagedObjectModel</code> from it. An assertion is raised if the model could not be found.
- (nonnull instancetype)init;
/// Initializes a <code>CSDataStack</code> from the model with the specified <code>modelName</code> in the specified <code>bundle</code>.
/// \param xcodeModelName the name of the (.xcdatamodeld) model file. If not specified, the application name (CFBundleName) will be used if it exists, or “CoreData” if it the bundle name was not set.
///
/// \param bundle an optional bundle to load .xcdatamodeld models from. If not specified, the main bundle will be used.
///
/// \param versionChain the version strings that indicate the sequence of model versions to be used as the order for progressive migrations. If not specified, will default to a non-migrating data stack.
///
- (nonnull instancetype)initWithXcodeModelName:(NSString * _Nullable)xcodeModelName bundle:(NSBundle * _Nullable)bundle versionChain:(NSArray<NSString *> * _Nullable)versionChain;
/// Returns the stack’s model version. The version string is the same as the name of the version-specific .xcdatamodeld file.
@property (nonatomic, readonly, copy) NSString * _Nonnull modelVersion;
/// Returns the entity name-to-class type mapping from the <code>CSDataStack</code>’s model.
- (NSDictionary<NSString *, SWIFT_METATYPE(NSManagedObject)> * _Nonnull)entityTypesByNameForType:(SWIFT_METATYPE(NSManagedObject) _Nonnull)type SWIFT_WARN_UNUSED_RESULT;
/// Returns the <code>NSEntityDescription</code> for the specified <code>NSManagedObject</code> subclass from stack’s model.
- (NSEntityDescription * _Nullable)entityDescriptionForClass:(SWIFT_METATYPE(NSManagedObject) _Nonnull)type SWIFT_WARN_UNUSED_RESULT;
/// Creates an <code>CSInMemoryStore</code> with default parameters and adds it to the stack. This method blocks until completion.
/// \code
/// CSSQLiteStore *storage = [dataStack addInMemoryStorageAndWaitAndReturnError:&error];
///
/// \endcode\param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// the <code>CSInMemoryStore</code> added to the stack
- (CSInMemoryStore * _Nullable)addInMemoryStorageAndWaitAndReturnError:(NSError * _Nullable * _Nullable)error;
/// Creates an <code>CSSQLiteStore</code> with default parameters and adds it to the stack. This method blocks until completion.
/// \code
/// CSSQLiteStore *storage = [dataStack addSQLiteStorageAndWaitAndReturnError:&error];
///
/// \endcode\param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// the <code>CSSQLiteStore</code> added to the stack
- (CSSQLiteStore * _Nullable)addSQLiteStorageAndWaitAndReturnError:(NSError * _Nullable * _Nullable)error;
/// Adds a <code>CSInMemoryStore</code> to the stack and blocks until completion.
/// \code
/// NSError *error;
/// CSInMemoryStore *storage = [dataStack
///     addStorageAndWait: [[CSInMemoryStore alloc] initWithConfiguration: @"Config1"]
///     error: &error];
///
/// \endcode\param storage the <code>CSInMemoryStore</code>
///
/// \param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// the <code>CSInMemoryStore</code> added to the stack
- (CSInMemoryStore * _Nullable)addInMemoryStorageAndWait:(CSInMemoryStore * _Nonnull)storage error:(NSError * _Nullable * _Nullable)error;
/// Adds a <code>CSSQLiteStore</code> to the stack and blocks until completion.
/// \code
/// NSError *error;
/// CSSQLiteStore *storage = [dataStack
///     addStorageAndWait: [[CSSQLiteStore alloc] initWithConfiguration: @"Config1"]
///     error: &error];
///
/// \endcode\param storage the <code>CSSQLiteStore</code>
///
/// \param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// the <code>CSSQLiteStore</code> added to the stack
- (CSSQLiteStore * _Nullable)addSQLiteStorageAndWait:(CSSQLiteStore * _Nonnull)storage error:(NSError * _Nullable * _Nullable)error;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
@end

@class CSSetupResult;

SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSDataStack (SWIFT_EXTENSION(CoreStore))
/// Asynchronously adds a <code>CSInMemoryStore</code> to the stack. Migrations are also initiated by default.
/// \code
/// NSError *error;
/// NSProgress *migrationProgress = [dataStack 
///     addInMemoryStorage:[CSInMemoryStore new]
///     completion:^(CSSetupResult *result) {
///         if (result.isSuccess) {
///             // ...
///         }
///     }
///     error: &error];
///
/// \endcode\param storage the <code>CSInMemoryStore</code> instance
///
/// \param completion the closure to be executed on the main queue when the process completes, either due to success or failure. The closure’s <code>CSSetupResult</code> argument indicates the result. This closure is NOT executed if an error is thrown, but will be executed with a failure <code>CSSetupResult</code> result if an error occurs asynchronously.
///
- (void)addInMemoryStorage:(CSInMemoryStore * _Nonnull)storage completion:(void (^ _Nonnull)(CSSetupResult * _Nonnull))completion;
/// Asynchronously adds a <code>CSSQLiteStore</code> to the stack. Migrations are also initiated by default.
/// \code
/// NSError *error;
/// NSProgress *migrationProgress = [dataStack
///     addInMemoryStorage:[[CSSQLiteStore alloc] 
///         initWithFileName:@"core_data.sqlite"
///         configuration:@"Config1"]
///     completion:^(CSSetupResult *result) {
///         if (result.isSuccess) {
///             // ...
///         }
///     }
///     error: &error];
///
/// \endcode\param storage the <code>CSSQLiteStore</code> instance
///
/// \param completion the closure to be executed on the main queue when the process completes, either due to success or failure. The closure’s <code>CSSetupResult</code> argument indicates the result. This closure is NOT executed if an error is thrown, but will be executed with a failure <code>CSSetupResult</code> result if an error occurs asynchronously. Note that the <code>CSLocalStorage</code> associated to the <code>-[CSSetupResult storage]</code> may not always be the same instance as the parameter argument if a previous <code>CSLocalStorage</code> was already added at the same URL and with the same configuration.
///
/// \param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// an <code>NSProgress</code> instance if a migration has started. <code>nil</code> if no migrations are required or if <code>error</code> was set.
- (NSProgress * _Nullable)addSQLiteStorage:(CSSQLiteStore * _Nonnull)storage completion:(void (^ _Nonnull)(CSSetupResult * _Nonnull))completion error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
/// Migrates a <code>CSSQLiteStore</code> to match the <code>CSDataStack</code>’s managed object model version. This method does NOT add the migrated store to the data stack.
/// \param storage the <code>CSSQLiteStore</code> instance
///
/// \param completion the closure to be executed on the main queue when the migration completes, either due to success or failure. The closure’s <code>CSMigrationResult</code> argument indicates the result. This closure is NOT executed if an error is thrown, but will be executed with a failure <code>CSSetupResult</code> result if an error occurs asynchronously.
///
/// \param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// an <code>NSProgress</code> instance if a migration has started. <code>nil</code> if no migrations are required or if <code>error</code> was set.
- (NSProgress * _Nullable)upgradeStorageIfNeeded:(CSSQLiteStore * _Nonnull)storage completion:(void (^ _Nonnull)(CSMigrationResult * _Nonnull))completion error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
/// Checks the migration steps required for the <code>CSSQLiteStore</code> to match the <code>CSDataStack</code>’s managed object model version.
/// \param storage the <code>CSSQLiteStore</code> instance
///
/// \param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// a <code>CSMigrationType</code> array indicating the migration steps required for the store, or an empty array if the file does not exist yet. Otherwise, <code>nil</code> is returned and the <code>error</code> argument is set if either inspection of the store failed, or if no mapping model was found/inferred.
- (NSArray<CSMigrationType *> * _Nullable)requiredMigrationsForSQLiteStore:(CSSQLiteStore * _Nonnull)storage error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
@end


SWIFT_AVAILABILITY(macos,introduced=10.12) SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSDataStack (SWIFT_EXTENSION(CoreStore))
/// Creates a <code>CSObjectMonitor</code> for the specified <code>NSManagedObject</code>. Multiple <code>ObjectObserver</code>s may then register themselves to be notified when changes are made to the <code>NSManagedObject</code>.
/// \param object the <code>NSManagedObject</code> to observe changes from
///
///
/// returns:
/// an <code>ObjectMonitor</code> that monitors changes to <code>object</code>
- (CSObjectMonitor * _Nonnull)monitorObject:(NSManagedObject * _Nonnull)object SWIFT_WARN_UNUSED_RESULT;
/// Creates a <code>CSListMonitor</code> for a list of <code>NSManagedObject</code>s that satisfy the specified fetch clauses. Multiple <code>CSListObserver</code>s may then register themselves to be notified when changes are made to the list.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>FetchClause</code> instances for fetching the object list. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// a <code>CSListMonitor</code> instance that monitors changes to the list
- (CSListMonitor * _Nonnull)monitorListFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Asynchronously creates a <code>CSListMonitor</code> for a list of <code>NSManagedObject</code>s that satisfy the specified fetch clauses. Multiple <code>CSListObserver</code>s may then register themselves to be notified when changes are made to the list. Since <code>NSFetchedResultsController</code> greedily locks the persistent store on initial fetch, you may prefer this method instead of the synchronous counterpart to avoid deadlocks while background updates/saves are being executed.
/// \param createAsynchronously the closure that receives the created <code>CSListMonitor</code> instance
///
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for fetching the object list. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
- (void)monitorListByCreatingAsynchronously:(void (^ _Nonnull)(CSListMonitor * _Nonnull))createAsynchronously from:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses;
/// Creates a <code>CSListMonitor</code> for a sectioned list of <code>NSManagedObject</code>s that satisfy the specified fetch clauses. Multiple <code>ListObserver</code>s may then register themselves to be notified when changes are made to the list.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param sectionBy a <code>CSSectionBy</code> clause indicating the keyPath for the attribute to use when sorting the list into sections.
///
/// \param fetchClauses a series of <code>FetchClause</code> instances for fetching the object list. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// a <code>CSListMonitor</code> instance that monitors changes to the list
- (CSListMonitor * _Nonnull)monitorSectionedListFrom:(CSFrom * _Nonnull)from sectionBy:(CSSectionBy * _Nonnull)sectionBy fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
@end


SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSDataStack (SWIFT_EXTENSION(CoreStore))
/// Begins a transaction asynchronously where <code>NSManagedObject</code> creates, updates, and deletes can be made.
/// \param closure the block where creates, updates, and deletes can be made to the transaction. Transaction blocks are executed serially in a background queue, and all changes are made from a concurrent <code>NSManagedObjectContext</code>.
///
- (void)beginAsynchronous:(void (^ _Nonnull)(CSAsynchronousDataTransaction * _Nonnull))closure;
/// Begins a transaction synchronously where <code>NSManagedObject</code> creates, updates, and deletes can be made.
/// \param closure the block where creates, updates, and deletes can be made to the transaction. Transaction blocks are executed serially in a background queue, and all changes are made from a concurrent <code>NSManagedObjectContext</code>.
///
/// \param error the <code>CSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// <code>YES</code> if the commit succeeded, <code>NO</code> if the commit failed. If <code>NO</code>, the <code>error</code> argument will hold error information.
- (BOOL)beginSynchronous:(void (^ _Nonnull)(CSSynchronousDataTransaction * _Nonnull))closure error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
/// Begins a child transaction where <code>NSManagedObject</code> creates, updates, and deletes can be made. This is useful for making temporary changes, such as partially filled forms.
/// To support “undo” methods such as <code>-undo</code>, <code>-redo</code>, and <code>-rollback</code>, use the <code>-beginSafeWithSupportsUndo:</code> method passing <code>YES</code> to the argument. Without “undo” support, calling those methods will raise an exception.
///
/// returns:
/// a <code>CSUnsafeDataTransaction</code> instance where creates, updates, and deletes can be made.
- (CSUnsafeDataTransaction * _Nonnull)beginUnsafe SWIFT_WARN_UNUSED_RESULT;
/// Begins a child transaction where <code>NSManagedObject</code> creates, updates, and deletes can be made. This is useful for making temporary changes, such as partially filled forms.
/// <ul>
///   <li>
///     prameter supportsUndo: <code>-undo</code>, <code>-redo</code>, and <code>-rollback</code> methods are only available when this parameter is <code>YES</code>, otherwise those method will raise an exception. Note that turning on Undo support may heavily impact performance especially on iOS or watchOS where memory is limited.
///   </li>
/// </ul>
///
/// returns:
/// a <code>CSUnsafeDataTransaction</code> instance where creates, updates, and deletes can be made.
- (CSUnsafeDataTransaction * _Nonnull)beginUnsafeWithSupportsUndo:(BOOL)supportsUndo SWIFT_WARN_UNUSED_RESULT;
/// Refreshes all registered objects <code>NSManagedObject</code>s in the <code>DataStack</code>.
- (void)refreshAndMergeAllObjects;
@end


SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSDataStack (SWIFT_EXTENSION(CoreStore))
/// Fetches the <code>NSManagedObject</code> instance in the transaction’s context from a reference created from a transaction or from a different managed object context.
/// \param object a reference to the object created/fetched outside the transaction
///
///
/// returns:
/// the <code>NSManagedObject</code> instance if the object exists in the transaction, or <code>nil</code> if not found.
- (id _Nullable)fetchExistingObject:(NSManagedObject * _Nonnull)object SWIFT_WARN_UNUSED_RESULT;
/// Fetches the <code>NSManagedObject</code> instance in the transaction’s context from an <code>NSManagedObjectID</code>.
/// \param objectID the <code>NSManagedObjectID</code> for the object
///
///
/// returns:
/// the <code>NSManagedObject</code> instance if the object exists in the transaction, or <code>nil</code> if not found.
- (id _Nullable)fetchExistingObjectWithID:(NSManagedObjectID * _Nonnull)objectID SWIFT_WARN_UNUSED_RESULT;
/// Fetches the <code>NSManagedObject</code> instances in the transaction’s context from references created from a transaction or from a different managed object context.
/// \param objects an array of <code>NSManagedObject</code>s created/fetched outside the transaction
///
///
/// returns:
/// the <code>NSManagedObject</code> array for objects that exists in the transaction
- (NSArray * _Nonnull)fetchExistingObjects:(NSArray<NSManagedObject *> * _Nonnull)objects SWIFT_WARN_UNUSED_RESULT;
/// Fetches the <code>NSManagedObject</code> instances in the transaction’s context from a list of <code>NSManagedObjectID</code>.
/// \param objectIDs the <code>NSManagedObjectID</code> array for the objects
///
///
/// returns:
/// the <code>NSManagedObject</code> array for objects that exists in the transaction
- (NSArray * _Nonnull)fetchExistingObjectsWithIDs:(NSArray<NSManagedObjectID *> * _Nonnull)objectIDs SWIFT_WARN_UNUSED_RESULT;
/// Fetches the first <code>NSManagedObject</code> instance that satisfies the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>From</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the first <code>NSManagedObject</code> instance that satisfies the specified <code>CSFetchClause</code>s
- (id _Nullable)fetchOneFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Fetches all <code>NSManagedObject</code> instances that satisfy the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// all <code>NSManagedObject</code> instances that satisfy the specified <code>CSFetchClause</code>s
- (NSArray * _Nullable)fetchAllFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Fetches the number of <code>NSManagedObject</code>s that satisfy the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the number <code>NSManagedObject</code>s that satisfy the specified <code>CSFetchClause</code>s
- (NSNumber * _Nullable)fetchCountFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Fetches the <code>NSManagedObjectID</code> for the first <code>NSManagedObject</code> that satisfies the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the <code>NSManagedObjectID</code> for the first <code>NSManagedObject</code> that satisfies the specified <code>CSFetchClause</code>s
- (NSManagedObjectID * _Nullable)fetchObjectIDFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Fetches the <code>NSManagedObjectID</code> for all <code>NSManagedObject</code>s that satisfy the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>FetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the <code>NSManagedObjectID</code> for all <code>NSManagedObject</code>s that satisfy the specified <code>CSFetchClause</code>s
- (NSArray<NSManagedObjectID *> * _Nullable)fetchObjectIDsFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Queries aggregate values as specified by the <code>CSQueryClause</code>s. Requires at least a <code>CSSelect</code> clause, and optional <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
/// A “query” differs from a “fetch” in that it only retrieves values already stored in the persistent store. As such, values from unsaved transactions or contexts will not be incorporated in the query result.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param selectClause a <code>CSSelect</code> clause indicating the properties to fetch, and with the generic type indicating the return type.
///
/// \param queryClauses a series of <code>CSQueryClause</code> instances for the query request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the result of the the query. The type of the return value is specified by the generic type of the <code>CSSelect</code> parameter.
- (id _Nullable)queryValueFrom:(CSFrom * _Nonnull)from selectClause:(CSSelect * _Nonnull)selectClause queryClauses:(NSArray<id <CSQueryClause>> * _Nonnull)queryClauses SWIFT_WARN_UNUSED_RESULT;
/// Queries a dictionary of attribute values as specified by the <code>CSQueryClause</code>s. Requires at least a <code>CSSelect</code> clause, and optional <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
/// A “query” differs from a “fetch” in that it only retrieves values already stored in the persistent store. As such, values from unsaved transactions or contexts will not be incorporated in the query result.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param selectClause a <code>CSSelect</code> clause indicating the properties to fetch, and with the generic type indicating the return type.
///
/// \param queryClauses a series of <code>CSQueryClause</code> instances for the query request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the result of the the query. The type of the return value is specified by the generic type of the <code>CSSelect</code> parameter.
- (NSArray<NSDictionary<NSString *, id> *> * _Nullable)queryAttributesFrom:(CSFrom * _Nonnull)from selectClause:(CSSelect * _Nonnull)selectClause queryClauses:(NSArray<id <CSQueryClause>> * _Nonnull)queryClauses SWIFT_WARN_UNUSED_RESULT;
@end


/// The <code>CSDeleteClause</code> implement clauses used to configure <code>NSFetchRequest</code>s.
/// seealso:
/// <code>DeleteClause</code>
SWIFT_PROTOCOL("_TtP9CoreStore14CSDeleteClause_")
@protocol CSDeleteClause
- (void)applyToFetchRequest:(NSFetchRequest<id <NSFetchRequestResult>> * _Nonnull)fetchRequest;
@end

@class NSManagedObjectModel;

/// The <code>CSDynamicSchema</code> serves as the Objective-C bridging type for <code>DynamicSchema</code>.
/// seealso:
/// <code>DynamicSchema</code>
SWIFT_PROTOCOL("_TtP9CoreStore15CSDynamicSchema_")
@protocol CSDynamicSchema
/// The version string for this model schema.
@property (nonatomic, readonly, copy) NSString * _Nonnull modelVersion;
/// Do not call this directly. The <code>NSManagedObjectModel</code> for this schema may be created lazily and using this method directly may affect the integrity of the model.
- (NSManagedObjectModel * _Nonnull)rawModel SWIFT_WARN_UNUSED_RESULT;
@end

@class NSCoder;

/// All errors thrown from CoreStore are expressed in <code>CSError</code>s.
/// seealso:
/// <code>CoreStoreError</code>
SWIFT_CLASS("_TtC9CoreStore7CSError")
@interface CSError : NSError
/// The <code>NSError</code> error domain for <code>CSError</code>.
/// seealso:
/// <code>CoreStoreErrorErrorDomain</code>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull errorDomain;)
+ (NSString * _Nonnull)errorDomain SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithDomain:(NSString * _Nonnull)domain code:(NSInteger)code userInfo:(NSDictionary<NSString *, id> * _Nullable)dict SWIFT_UNAVAILABLE;
@end



/// The <code>NSError</code> error codes for <code>CSError.Domain</code>.
/// seealso:
/// <code>CSError</code>
/// seealso:
/// <code>CoreStoreError</code>
typedef SWIFT_ENUM(NSInteger, CSErrorCode, closed) {
/// A failure occured because of an unknown error.
  CSErrorCodeUnknownError = 0,
/// The <code>NSPersistentStore</code> could note be initialized because another store existed at the specified <code>NSURL</code>.
  CSErrorCodeDifferentStorageExistsAtURL = 1,
/// An <code>NSMappingModel</code> could not be found for a specific source and destination model versions.
  CSErrorCodeMappingModelNotFound = 2,
/// Progressive migrations are disabled for a store, but an <code>NSMappingModel</code> could not be found for a specific source and destination model versions.
  CSErrorCodeProgressiveMigrationRequired = 3,
/// An internal SDK call failed with the specified “NSError” userInfo key.
  CSErrorCodeInternalError = 4,
/// The transaction was terminated by a user-thrown error with the specified “Error” userInfo key.
  CSErrorCodeUserError = 5,
/// The transaction was cancelled by the user.
  CSErrorCodeUserCancelled = 6,
};


/// The <code>CSFetchClause</code> implement clauses used to configure <code>NSFetchRequest</code>s.
/// seealso:
/// <code>FetchClause</code>
SWIFT_PROTOCOL("_TtP9CoreStore13CSFetchClause_")
@protocol CSFetchClause
- (void)applyToFetchRequest:(NSFetchRequest<id <NSFetchRequestResult>> * _Nonnull)fetchRequest;
@end


/// The <code>CSFrom</code> serves as the Objective-C bridging type for <code>From</code>.
/// seealso:
/// <code>From</code>
SWIFT_CLASS("_TtC9CoreStore6CSFrom")
@interface CSFrom : NSObject
/// The associated <code>NSManagedObject</code> entity class
@property (nonatomic, readonly) Class _Nonnull entityClass;
/// The <code>NSPersistentStore</code> configuration names to associate objects from.
/// May contain <code>NSString</code> instances to pertain to named configurations, or <code>NSNull</code> to pertain to the default configuration
@property (nonatomic, readonly, copy) NSArray * _Nullable configurations;
/// Initializes a <code>CSFrom</code> clause with the specified entity class.
/// \code
/// MyPersonEntity *people = [transaction fetchAllFrom:CSFromClass([MyPersonEntity class])];
///
/// \endcode\param entityClass the <code>NSManagedObject</code> class type to be created
///
- (nonnull instancetype)initWithEntityClass:(SWIFT_METATYPE(NSManagedObject) _Nonnull)entityClass;
/// Initializes a <code>CSFrom</code> clause with the specified configurations.
/// \code
/// MyPersonEntity *people = [transaction fetchAllFrom:
///    CSFromClass([MyPersonEntity class], @"Config1")];
///
/// \endcode\param entityClass the associated <code>NSManagedObject</code> entity class
///
/// \param configuration the <code>NSPersistentStore</code> configuration name to associate objects from. This parameter is required if multiple configurations contain the created <code>NSManagedObject</code>’s entity type. Set to <code>[NSNull null]</code> to use the default configuration.
///
- (nonnull instancetype)initWithEntityClass:(SWIFT_METATYPE(NSManagedObject) _Nonnull)entityClass configuration:(id _Nonnull)configuration;
/// Initializes a <code>CSFrom</code> clause with the specified configurations.
/// \code
/// MyPersonEntity *people = [transaction fetchAllFrom:
///    CSFromClass([MyPersonEntity class],
///                 @[[NSNull null], @"Config1"])];
///
/// \endcode\param entityClass the associated <code>NSManagedObject</code> entity class
///
/// \param configurations an array of the <code>NSPersistentStore</code> configuration names to associate objects from. This parameter is required if multiple configurations contain the created <code>NSManagedObject</code>’s entity type. Set to <code>[NSNull null]</code> to use the default configuration.
///
- (nonnull instancetype)initWithEntityClass:(SWIFT_METATYPE(NSManagedObject) _Nonnull)entityClass configurations:(NSArray * _Nonnull)configurations;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The <code>CSQueryClause</code> implement clauses used to configure <code>NSFetchRequest</code>s.
/// seealso:
/// <code>QueryClause</code>
SWIFT_PROTOCOL("_TtP9CoreStore13CSQueryClause_")
@protocol CSQueryClause
- (void)applyToFetchRequest:(NSFetchRequest<id <NSFetchRequestResult>> * _Nonnull)fetchRequest;
@end


/// The <code>CSGroupBy</code> serves as the Objective-C bridging type for <code>GroupBy</code>.
/// seealso:
/// <code>GroupBy</code>
SWIFT_CLASS("_TtC9CoreStore9CSGroupBy")
@interface CSGroupBy : NSObject <CSQueryClause>
/// The list of key path strings to group results with
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nonnull keyPaths;
/// Initializes a <code>CSGroupBy</code> clause with a key path string
/// \param keyPath a key path string to group results with
///
- (nonnull instancetype)initWithKeyPath:(NSString * _Nonnull)keyPath;
/// Initializes a <code>CSGroupBy</code> clause with a list of key path strings
/// \param keyPaths a list of key path strings to group results with
///
- (nonnull instancetype)initWithKeyPaths:(NSArray<NSString *> * _Nonnull)keyPaths;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (void)applyToFetchRequest:(NSFetchRequest<id <NSFetchRequestResult>> * _Nonnull)fetchRequest;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The <code>CSStorageInterface</code> serves as the Objective-C bridging type for <code>StorageInterface</code>.
/// seealso:
/// <code>StorageInterface</code>
SWIFT_PROTOCOL("_TtP9CoreStore18CSStorageInterface_")
@protocol CSStorageInterface
/// The string identifier for the <code>NSPersistentStore</code>’s <code>type</code> property. This is the same string CoreStore will use to create the <code>NSPersistentStore</code> from the <code>NSPersistentStoreCoordinator</code>’s <code>addPersistentStoreWithType(...)</code> method.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull storeType;)
+ (NSString * _Nonnull)storeType SWIFT_WARN_UNUSED_RESULT;
/// The configuration name in the model file
@property (nonatomic, readonly, copy) NSString * _Nullable configuration;
/// The options dictionary for the <code>NSPersistentStore</code>
@property (nonatomic, readonly, copy) NSDictionary * _Nullable storeOptions;
@end


/// The <code>CSInMemoryStore</code> serves as the Objective-C bridging type for <code>InMemoryStore</code>.
/// seealso:
/// <code>InMemoryStore</code>
SWIFT_CLASS("_TtC9CoreStore15CSInMemoryStore") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSInMemoryStore : NSObject <CSStorageInterface>
/// Initializes a <code>CSInMemoryStore</code> for the specified configuration
/// \param configuration an optional configuration name from the model file. If not specified, defaults to <code>nil</code>, the “Default” configuration.
///
- (nonnull instancetype)initWithConfiguration:(NSString * _Nullable)configuration;
/// Initializes a <code>CSInMemoryStore</code> with the “Default” configuration
- (nonnull instancetype)init;
/// The string identifier for the <code>NSPersistentStore</code>’s <code>type</code> property. For <code>CSInMemoryStore</code>s, this is always set to <code>NSInMemoryStoreType</code>.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull storeType;)
+ (NSString * _Nonnull)storeType SWIFT_WARN_UNUSED_RESULT;
/// The configuration name in the model file
@property (nonatomic, readonly, copy) NSString * _Nullable configuration;
/// The options dictionary for the <code>NSPersistentStore</code>. For <code>CSInMemoryStore</code>s, this is always set to <code>nil</code>.
@property (nonatomic, readonly, copy) NSDictionary * _Nullable storeOptions;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
@end


/// The <code>CSInto</code> serves as the Objective-C bridging type for <code>Into<T></code>.
/// seealso:
/// <code>Into</code>
SWIFT_CLASS("_TtC9CoreStore6CSInto")
@interface CSInto : NSObject
/// The associated <code>NSManagedObject</code> entity class
@property (nonatomic, readonly) SWIFT_METATYPE(NSManagedObject) _Nonnull entityClass;
/// The <code>NSPersistentStore</code> configuration name to associate objects from.
/// May contain a <code>String</code> to pertain to a named configuration, or <code>nil</code> to pertain to the default configuration
@property (nonatomic, readonly, copy) NSString * _Nullable configuration;
/// Initializes a <code>CSInto</code> clause with the specified entity class.
/// \code
/// MyPersonEntity *person = [transaction createInto:
///    CSIntoClass([MyPersonEntity class])];
///
/// \endcode\param entityClass the <code>NSManagedObject</code> class type to be created
///
- (nonnull instancetype)initWithEntityClass:(SWIFT_METATYPE(NSManagedObject) _Nonnull)entityClass;
/// Initializes a <code>CSInto</code> clause with the specified configuration.
/// \code
/// MyPersonEntity *person = [transaction createInto:
///    CSIntoClass([MyPersonEntity class])];
///
/// \endcode\param entityClass the <code>NSManagedObject</code> class type to be created
///
/// \param configuration the <code>NSPersistentStore</code> configuration name to associate the object to. This parameter is required if multiple configurations contain the created <code>NSManagedObject</code>’s entity type. Set to <code>nil</code> to use the default configuration.
///
- (nonnull instancetype)initWithEntityClass:(SWIFT_METATYPE(NSManagedObject) _Nonnull)entityClass configuration:(NSString * _Nullable)configuration;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@protocol NSFetchedResultsSectionInfo;
@protocol CSListObserver;
@protocol CSListSectionObserver;

/// The <code>CSListMonitor</code> serves as the Objective-C bridging type for <code>ListMonitor<T></code>.
/// seealso:
/// <code>ListMonitor</code>
SWIFT_CLASS("_TtC9CoreStore13CSListMonitor") SWIFT_AVAILABILITY(macos,introduced=10.12)
@interface CSListMonitor : NSObject
- (id _Nonnull)objectAtIndexedSubscript:(NSInteger)index SWIFT_WARN_UNUSED_RESULT;
/// Returns the object at the given index, or <code>nil</code> if out of bounds. This indexer is typically used for <code>CSListMonitor</code>s created without section groupings.
/// \param index the index for the object. Using an index above the valid range will return <code>nil</code>.
///
///
/// returns:
/// the <code>NSManagedObject</code> at the specified index, or <code>nil</code> if out of bounds
- (id _Nullable)objectAtSafeIndex:(NSInteger)index SWIFT_WARN_UNUSED_RESULT;
/// Returns the object at the given <code>sectionIndex</code> and <code>itemIndex</code>. This indexer is typically used for <code>CSListMonitor</code>s created as sectioned lists.
/// \param sectionIndex the section index for the object. Using a <code>sectionIndex</code> with an invalid range will raise an exception.
///
/// \param itemIndex the index for the object within the section. Using an <code>itemIndex</code> with an invalid range will raise an exception.
///
///
/// returns:
/// the <code>NSManagedObject</code> at the specified section and item index
- (id _Nonnull)objectAtSectionIndex:(NSInteger)sectionIndex itemIndex:(NSInteger)itemIndex SWIFT_WARN_UNUSED_RESULT;
/// Returns the object at the given section and item index, or <code>nil</code> if out of bounds. This indexer is typically used for <code>CSListMonitor</code>s created as sectioned lists.
/// \param sectionIndex the section index for the object. Using a <code>sectionIndex</code> with an invalid range will return <code>nil</code>.
///
/// \param itemIndex the index for the object within the section. Using an <code>itemIndex</code> with an invalid range will return <code>nil</code>.
///
///
/// returns:
/// the <code>NSManagedObject</code> at the specified section and item index, or <code>nil</code> if out of bounds
- (id _Nullable)objectAtSafeSectionIndex:(NSInteger)sectionIndex safeItemIndex:(NSInteger)itemIndex SWIFT_WARN_UNUSED_RESULT;
/// Returns the object at the given <code>NSIndexPath</code>. This subscript indexer is typically used for <code>CSListMonitor</code>s created as sectioned lists.
/// \param indexPath the <code>NSIndexPath</code> for the object. Using an <code>indexPath</code> with an invalid range will raise an exception.
///
///
/// returns:
/// the <code>NSManagedObject</code> at the specified index path
- (id _Nonnull)objectAtIndexPath:(NSIndexPath * _Nonnull)indexPath SWIFT_WARN_UNUSED_RESULT;
/// Returns the object at the given <code>NSIndexPath</code>, or <code>nil</code> if out of bounds. This subscript indexer is typically used for <code>CSListMonitor</code>s created as sectioned lists.
/// \param indexPath the <code>NSIndexPath</code> for the object. Using an <code>indexPath</code> with an invalid range will return <code>nil</code>.
///
///
/// returns:
/// the <code>NSManagedObject</code> at the specified index path, or <code>nil</code> if out of bounds
- (id _Nullable)objectAtSafeIndexPath:(NSIndexPath * _Nonnull)indexPath SWIFT_WARN_UNUSED_RESULT;
/// Checks if the <code>CSListMonitor</code> has at least one object in any section.
///
/// returns:
/// <code>YES</code> if at least one object in any section exists, <code>NO</code> otherwise
- (BOOL)hasObjects SWIFT_WARN_UNUSED_RESULT;
/// Checks if the <code>CSListMonitor</code> has at least one object the specified section.
/// \param section the section index. Using an index outside the valid range will return <code>NO</code>.
///
///
/// returns:
/// <code>YES</code> if at least one object in the specified section exists, <code>NO</code> otherwise
- (BOOL)hasObjectsInSection:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// Returns all objects in all sections
///
/// returns:
/// all objects in all sections
- (NSArray<NSManagedObject *> * _Nonnull)objectsInAllSections SWIFT_WARN_UNUSED_RESULT;
/// Returns all objects in the specified section
/// \param section the section index. Using an index outside the valid range will raise an exception.
///
///
/// returns:
/// all objects in the specified section
- (NSArray<NSManagedObject *> * _Nonnull)objectsInSection:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// Returns all objects in the specified section, or <code>nil</code> if out of bounds.
/// \param section the section index. Using an index outside the valid range will return <code>nil</code>.
///
///
/// returns:
/// all objects in the specified section, or <code>nil</code> if out of bounds
- (NSArray<NSManagedObject *> * _Nullable)objectsInSafeSectionWithSafeSectionIndex:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// Returns the number of sections
///
/// returns:
/// the number of sections
- (NSInteger)numberOfSections SWIFT_WARN_UNUSED_RESULT;
/// Returns the number of objects in all sections
///
/// returns:
/// the number of objects in all sections
- (NSInteger)numberOfObjects SWIFT_WARN_UNUSED_RESULT;
/// Returns the number of objects in the specified section
/// \param section the section index. Using an index outside the valid range will raise an exception.
///
///
/// returns:
/// the number of objects in the specified section
- (NSInteger)numberOfObjectsInSection:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// Returns the number of objects in the specified section, or <code>nil</code> if out of bounds.
/// \param section the section index. Using an index outside the valid range will return <code>nil</code>.
///
///
/// returns:
/// the number of objects in the specified section, or <code>nil</code> if out of bounds
- (NSNumber * _Nullable)numberOfObjectsInSafeSectionWithSafeSectionIndex:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// Returns the <code>NSFetchedResultsSectionInfo</code> for the specified section
/// \param section the section index. Using an index outside the valid range will raise an exception.
///
///
/// returns:
/// the <code>NSFetchedResultsSectionInfo</code> for the specified section
- (id <NSFetchedResultsSectionInfo> _Nonnull)sectionInfoAtIndex:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// Returns the <code>NSFetchedResultsSectionInfo</code> for the specified section, or <code>nil</code> if out of bounds.
/// \param section the section index. Using an index outside the valid range will return <code>nil</code>.
///
///
/// returns:
/// the <code>NSFetchedResultsSectionInfo</code> for the specified section, or <code>nil</code> if the section index is out of bounds.
- (id <NSFetchedResultsSectionInfo> _Nullable)sectionInfoAtSafeSectionIndexWithSafeSectionIndex:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// Returns the <code>NSFetchedResultsSectionInfo</code>s for all sections
///
/// returns:
/// the <code>NSFetchedResultsSectionInfo</code>s for all sections
- (NSArray<id <NSFetchedResultsSectionInfo>> * _Nonnull)sections SWIFT_WARN_UNUSED_RESULT;
/// Returns the target section for a specified “Section Index” title and index.
/// \param title the title of the Section Index
///
/// \param index the index of the Section Index
///
///
/// returns:
/// the target section for the specified “Section Index” title and index.
- (NSInteger)targetSectionForSectionIndexTitleWithTitle:(NSString * _Nonnull)title index:(NSInteger)index SWIFT_WARN_UNUSED_RESULT;
/// Returns the section index titles for all sections
///
/// returns:
/// the section index titles for all sections
- (NSArray<NSString *> * _Nonnull)sectionIndexTitles SWIFT_WARN_UNUSED_RESULT;
/// Returns the index of the <code>NSManagedObject</code> if it exists in the <code>CSListMonitor</code>’s fetched objects, or <code>nil</code> if not found.
/// \param object the <code>NSManagedObject</code> to search the index of
///
///
/// returns:
/// the index of the <code>NSManagedObject</code> if it exists in the <code>CSListMonitor</code>’s fetched objects, or <code>nil</code> if not found.
- (NSNumber * _Nullable)indexOf:(NSManagedObject * _Nonnull)object SWIFT_WARN_UNUSED_RESULT;
/// Returns the <code>NSIndexPath</code> of the <code>NSManagedObject</code> if it exists in the <code>CSListMonitor</code>’s fetched objects, or <code>nil</code> if not found.
/// \param object the <code>NSManagedObject</code> to search the index of
///
///
/// returns:
/// the <code>NSIndexPath</code> of the <code>NSManagedObject</code> if it exists in the <code>ListMonitor</code>’s fetched objects, or <code>nil</code> if not found.
- (NSIndexPath * _Nullable)indexPathOf:(NSManagedObject * _Nonnull)object SWIFT_WARN_UNUSED_RESULT;
/// Registers a <code>CSListObserver</code> to be notified when changes to the receiver’s list occur.
/// To prevent retain-cycles, <code>CSListMonitor</code> only keeps <code>weak</code> references to its observers.
/// For thread safety, this method needs to be called from the main thread. An assertion failure will occur (on debug builds only) if called from any thread other than the main thread.
/// Calling <code>-addListObserver:</code> multiple times on the same observer is safe, as <code>CSListMonitor</code> unregisters previous notifications to the observer before re-registering them.
/// \param observer a <code>CSListObserver</code> to send change notifications to
///
- (void)addListObserver:(id <CSListObserver> _Nonnull)observer;
/// Registers a <code>CSListSectionObserver</code> to be notified when changes to the receiver’s list occur.
/// To prevent retain-cycles, <code>CSListMonitor</code> only keeps <code>weak</code> references to its observers.
/// For thread safety, this method needs to be called from the main thread. An assertion failure will occur (on debug builds only) if called from any thread other than the main thread.
/// Calling <code>-addListSectionObserver:</code> multiple times on the same observer is safe, as <code>ListMonitor</code> unregisters previous notifications to the observer before re-registering them.
/// \param observer a <code>CSListSectionObserver</code> to send change notifications to
///
- (void)addListSectionObserver:(id <CSListSectionObserver> _Nonnull)observer;
/// Unregisters a <code>CSListObserver</code> from receiving notifications for changes to the receiver’s list.
/// For thread safety, this method needs to be called from the main thread. An assertion failure will occur (on debug builds only) if called from any thread other than the main thread.
/// \param observer a <code>CSListObserver</code> to unregister notifications to
///
- (void)removeListObserver:(id <CSListObserver> _Nonnull)observer;
/// Returns <code>YES</code> if a call to <code>-refetch:</code> was made to the <code>CSListMonitor</code> and is currently waiting for the fetching to complete. Returns <code>NO</code> otherwise.
@property (nonatomic, readonly) BOOL isPendingRefetch;
/// Asks the <code>CSListMonitor</code> to refetch its objects using the specified series of <code>CSFetchClause</code>s. Note that this method does not execute the fetch immediately; the actual fetching will happen after the <code>NSFetchedResultsController</code>’s last <code>controllerDidChangeContent(_:)</code> notification completes.
/// <code>refetch(...)</code> broadcasts <code>listMonitorWillRefetch(...)</code> to its observers immediately, and then <code>listMonitorDidRefetch(...)</code> after the new fetch request completes.
/// important:
/// Starting CoreStore 4.0, all <code>CSFetchClause</code>s required by the <code>CSListMonitor</code> should be provided in the arguments list of <code>refetch(...)</code>.
/// \param fetchClauses a series of <code>FetchClause</code> instances for fetching the object list. Accepts <code>Where</code>, <code>OrderBy</code>, and <code>Tweak</code> clauses.
///
- (void)refetch:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Implement the <code>CSListObserver</code> protocol to observe changes to a list of <code>NSManagedObject</code>s. <code>CSListObserver</code>s may register themselves to a <code>CSListMonitor</code>’s <code>-addListObserver:</code> method:
/// \code
/// CSListMonitor *monitor = [CSCoreStore 
///     monitorListFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     fetchClauses:@[[CSOrderBy sortDescriptor:[CSSortKey withKeyPath:@"lastName" ascending:YES]]]];
/// [monitor addListObserver:self];
///
/// \endcodeseealso:
/// <code>ListObserver</code>
SWIFT_PROTOCOL("_TtP9CoreStore14CSListObserver_") SWIFT_AVAILABILITY(macos,introduced=10.12)
@protocol CSListObserver
@optional
/// Handles processing just before a change to the observed list occurs
/// \param monitor the <code>CSListMonitor</code> monitoring the list being observed
///
- (void)listMonitorWillChange:(CSListMonitor * _Nonnull)monitor;
/// Handles processing right after a change to the observed list occurs
/// \param monitor the <code>CSListMonitor</code> monitoring the object being observed
///
- (void)listMonitorDidChange:(CSListMonitor * _Nonnull)monitor;
/// This method is broadcast from within the <code>CSListMonitor</code>’s <code>-refetchWithFetchClauses:</code> method to let observers prepare for the internal <code>NSFetchedResultsController</code>’s pending change to its predicate, sort descriptors, etc. Note that the actual refetch will happen after the <code>NSFetchedResultsController</code>’s last <code>-controllerDidChangeContent:</code> notification completes.
/// \param monitor the <code>CSListMonitor</code> monitoring the object being observed
///
- (void)listMonitorWillRefetch:(CSListMonitor * _Nonnull)monitor;
/// After the <code>CSListMonitor</code>’s <code>-refetchWithFetchClauses:</code> method is called, this method is broadcast after the <code>NSFetchedResultsController</code>’s last <code>-controllerDidChangeContent:</code> notification completes.
/// \param monitor the <code>CSListMonitor</code> monitoring the object being observed
///
- (void)listMonitorDidRefetch:(CSListMonitor * _Nonnull)monitor;
@end


/// Implement the <code>CSListObjectObserver</code> protocol to observe detailed changes to a list’s object. <code>CSListObjectObserver</code>s may register themselves to a <code>CSListMonitor</code>’s <code>-addListObjectObserver(_:)</code> method:
/// \code
/// CSListMonitor *monitor = [CSCoreStore
///     monitorListFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     fetchClauses:@[[CSOrderBy sortDescriptor:[CSSortKey withKeyPath:@"lastName" ascending:YES]]]];
/// [monitor addListObjectObserver:self];
///
/// \endcodeseealso:
/// <code>ListObjectObserver</code>
SWIFT_PROTOCOL("_TtP9CoreStore20CSListObjectObserver_") SWIFT_AVAILABILITY(macos,introduced=10.12)
@protocol CSListObjectObserver <CSListObserver>
@optional
/// Notifies that an object was inserted to the specified <code>NSIndexPath</code> in the list
/// \param monitor the <code>CSListMonitor</code> monitoring the list being observed
///
/// \param object the entity type for the inserted object
///
/// \param indexPath the new <code>NSIndexPath</code> for the inserted object
///
- (void)listMonitor:(CSListMonitor * _Nonnull)monitor didInsertObject:(id _Nonnull)object toIndexPath:(NSIndexPath * _Nonnull)indexPath;
/// Notifies that an object was deleted from the specified <code>NSIndexPath</code> in the list
/// \param monitor the <code>CSListMonitor</code> monitoring the list being observed
///
/// \param object the entity type for the deleted object
///
/// \param indexPath the <code>NSIndexPath</code> for the deleted object
///
- (void)listMonitor:(CSListMonitor * _Nonnull)monitor didDeleteObject:(id _Nonnull)object fromIndexPath:(NSIndexPath * _Nonnull)indexPath;
/// Notifies that an object at the specified <code>NSIndexPath</code> was updated
/// \param monitor the <code>CSListMonitor</code> monitoring the list being observed
///
/// \param object the entity type for the updated object
///
/// \param indexPath the <code>NSIndexPath</code> for the updated object
///
- (void)listMonitor:(CSListMonitor * _Nonnull)monitor didUpdateObject:(id _Nonnull)object atIndexPath:(NSIndexPath * _Nonnull)indexPath;
/// Notifies that an object’s index changed
/// \param monitor the <code>CSListMonitor</code> monitoring the list being observed
///
/// \param object the entity type for the moved object
///
/// \param fromIndexPath the previous <code>NSIndexPath</code> for the moved object
///
/// \param toIndexPath the new <code>NSIndexPath</code> for the moved object
///
- (void)listMonitor:(CSListMonitor * _Nonnull)monitor didMoveObject:(id _Nonnull)object fromIndexPath:(NSIndexPath * _Nonnull)fromIndexPath toIndexPath:(NSIndexPath * _Nonnull)toIndexPath;
@end



/// Implement the <code>CSListSectionObserver</code> protocol to observe changes to a list’s section info. <code>CSListSectionObserver</code>s may register themselves to a <code>CSListMonitor</code>’s <code>-addListSectionObserver:</code> method:
/// \code
/// CSListMonitor *monitor = [CSCoreStore
///     monitorSectionedListFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     sectionBy:[CSSectionBy keyPath:@"age"]
///     fetchClauses:@[[CSOrderBy sortDescriptor:[CSSortKey withKeyPath:@"lastName" ascending:YES]]]];
/// [monitor addListSectionObserver:self];
///
/// \endcodeseealso:
/// <code>ListSectionObserver</code>
SWIFT_PROTOCOL("_TtP9CoreStore21CSListSectionObserver_") SWIFT_AVAILABILITY(macos,introduced=10.12)
@protocol CSListSectionObserver <CSListObjectObserver>
@optional
/// Notifies that a section was inserted at the specified index
/// \param monitor the <code>CSListMonitor</code> monitoring the list being observed
///
/// \param sectionInfo the <code>NSFetchedResultsSectionInfo</code> for the inserted section
///
/// \param sectionIndex the new section index for the new section
///
- (void)listMonitor:(CSListMonitor * _Nonnull)monitor didInsertSection:(id <NSFetchedResultsSectionInfo> _Nonnull)sectionInfo toSectionIndex:(NSInteger)sectionIndex;
/// Notifies that a section was inserted at the specified index
/// \param monitor the <code>CSListMonitor</code> monitoring the list being observed
///
/// \param sectionInfo the <code>NSFetchedResultsSectionInfo</code> for the deleted section
///
/// \param sectionIndex the previous section index for the deleted section
///
- (void)listMonitor:(CSListMonitor * _Nonnull)monitor didDeleteSection:(id <NSFetchedResultsSectionInfo> _Nonnull)sectionInfo fromSectionIndex:(NSInteger)sectionIndex;
@end

@class NSDictionary;

/// The <code>CSLocalStorage</code> serves as the Objective-C bridging type for <code>LocalStorage</code>.
/// seealso:
/// <code>LocalStorage</code>
SWIFT_PROTOCOL("_TtP9CoreStore14CSLocalStorage_")
@protocol CSLocalStorage <CSStorageInterface>
/// The <code>NSURL</code> that points to the store file
@property (nonatomic, readonly, copy) NSURL * _Nonnull fileURL;
/// An array of <code>SchemaMappingProvider</code>s that provides the complete mapping models for custom migrations. This is currently only supported for Swift code.
@property (nonatomic, readonly, copy) NSArray * _Nonnull migrationMappingProviders;
/// Options that tell the <code>CSDataStack</code> how to setup the persistent store
@property (nonatomic, readonly) NSInteger localStorageOptions;
/// Called by the <code>CSDataStack</code> to perform actual deletion of the store file from disk. Do not call directly! The <code>sourceModel</code> argument is a hint for the existing store’s model version. Implementers can use the <code>sourceModel</code> to perform necessary store operations. (SQLite stores for example, can convert WAL journaling mode to DELETE before deleting)
- (BOOL)cs_eraseStorageAndWaitWithMetadata:(NSDictionary * _Nonnull)metadata soureModelHint:(NSManagedObjectModel * _Nullable)soureModelHint error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
@end

/// The <code>CSLocalStorageOptions</code> provides settings that tells the <code>CSDataStack</code> how to setup the persistent store for <code>CSLocalStorage</code> implementers.
/// seealso:
/// <code>LocalStorageOptions</code>
typedef SWIFT_ENUM(NSInteger, CSLocalStorageOptions, closed) {
/// Tells the <code>DataStack</code> that the store should not be migrated or recreated, and should simply fail on model mismatch
  CSLocalStorageOptionsNone = 0,
/// Tells the <code>DataStack</code> to delete and recreate the store on model mismatch, otherwise exceptions will be thrown on failure instead
  CSLocalStorageOptionsRecreateStoreOnModelMismatch = 1,
/// Tells the <code>DataStack</code> to prevent progressive migrations for the store
  CSLocalStorageOptionsPreventProgressiveMigration = 2,
/// Tells the <code>DataStack</code> to allow lightweight migration for the store when added synchronously
  CSLocalStorageOptionsAllowSynchronousLightweightMigration = 4,
};


/// The <code>CSMigrationResult</code> serves as the Objective-C bridging type for <code>MigrationResult</code>.
/// seealso:
/// <code>MigrationResult</code>
SWIFT_CLASS("_TtC9CoreStore17CSMigrationResult") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSMigrationResult : NSObject
/// <code>YES</code> if the migration succeeded, <code>NO</code> otherwise
@property (nonatomic, readonly) BOOL isSuccess;
/// <code>YES</code> if the migration failed, <code>NO</code> otherwise
@property (nonatomic, readonly) BOOL isFailure;
/// <code>YES</code> if the migration succeeded, <code>NO</code> otherwise
@property (nonatomic, readonly, copy) NSArray<CSMigrationType *> * _Nullable migrationTypes;
/// The <code>NSError</code> for a failed migration, or <code>nil</code> if the migration succeeded
@property (nonatomic, readonly, strong) NSError * _Nullable error;
/// If the result was a success, the <code>success</code> block is executed with an array of <code>CSMigrationType</code>s that indicates the migration steps completed. If the result was a failure, the <code>failure</code> block is executed with an <code>NSError</code> argument pertaining to the actual error.
/// The blocks are executed immediately as <code>@noescape</code> and will not be retained.
/// \param success the block to execute on success. The block passes an array of <code>CSMigrationType</code>s that indicates the migration steps completed.
///
/// \param failure the block to execute on failure. The block passes an <code>NSError</code> argument that pertains to the actual error.
///
- (void)handleSuccess:(SWIFT_NOESCAPE void (^ _Nonnull)(NSArray<CSMigrationType *> * _Nonnull))success failure:(SWIFT_NOESCAPE void (^ _Nonnull)(NSError * _Nonnull))failure;
/// If the result was a success, the <code>success</code> block is executed with an array of <code>CSMigrationType</code>s that indicates the migration steps completed. If the result was a failure, this method does nothing.
/// The block is executed immediately as <code>@noescape</code> and will not be retained.
/// \param success the block to execute on success. The block passes an array of <code>CSMigrationType</code>s that indicates the migration steps completed.
///
- (void)handleSuccess:(SWIFT_NOESCAPE void (^ _Nonnull)(NSArray<CSMigrationType *> * _Nonnull))success;
/// If the result was a failure, the <code>failure</code> block is executed with an <code>NSError</code> argument pertaining to the actual error. If the result was a success, this method does nothing.
/// The block is executed immediately as <code>@noescape</code> and will not be retained.
/// \param failure the block to execute on failure. The block passes an <code>NSError</code> argument that pertains to the actual error.
///
- (void)handleFailure:(SWIFT_NOESCAPE void (^ _Nonnull)(NSError * _Nonnull))failure;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The <code>CSMigrationType</code> serves as the Objective-C bridging type for <code>MigrationType</code>.
/// seealso:
/// <code>MigrationType</code>
SWIFT_CLASS("_TtC9CoreStore15CSMigrationType") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSMigrationType : NSObject
/// Returns <code>YES</code> if the <code>CSMigrationType</code>’s <code>sourceVersion</code> and <code>destinationVersion</code> do not match. Returns <code>NO</code> otherwise.
@property (nonatomic, readonly) BOOL needsMigration;
/// Returns the source model version for the migration type. If no migration is required, <code>sourceVersion</code> will be equal to the <code>destinationVersion</code>.
@property (nonatomic, readonly, copy) NSString * _Nonnull sourceVersion;
/// Returns the destination model version for the migration type. If no migration is required, <code>destinationVersion</code> will be equal to the <code>sourceVersion</code>.
@property (nonatomic, readonly, copy) NSString * _Nonnull destinationVersion;
/// Returns <code>YES</code> if the <code>CSMigrationType</code> is a lightweight migration. Used as syntactic sugar.
@property (nonatomic, readonly) BOOL isLightweightMigration;
/// Returns <code>YES</code> if the <code>CSMigrationType</code> is a heavyweight migration. Used as syntactic sugar.
@property (nonatomic, readonly) BOOL isHeavyweightMigration;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The <code>CSObjectMonitor</code> serves as the Objective-C bridging type for <code>ObjectMonitor<T></code>.
/// seealso:
/// <code>ObjectMonitor</code>
SWIFT_CLASS("_TtC9CoreStore15CSObjectMonitor") SWIFT_AVAILABILITY(macos,introduced=10.12)
@interface CSObjectMonitor : NSObject
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Implement the <code>CSObjectObserver</code> protocol to observe changes  to a single <code>NSManagedObject</code> instance. <code>CSObjectObserver</code>s may register themselves to a <code>CSObjectMonitor</code>’s <code>-addObjectObserver:</code> method:
/// \code
/// CSObjectMonitor *monitor = [CSCoreStore monitorObject:myObject];
/// [monitor addObjectObserver:self];
///
/// \endcodeseealso:
/// <code>ObjectObserver</code>
SWIFT_PROTOCOL("_TtP9CoreStore16CSObjectObserver_") SWIFT_AVAILABILITY(macos,introduced=10.12)
@protocol CSObjectObserver
@optional
/// Handles processing just before a change to the observed <code>object</code> occurs
/// \param monitor the <code>CSObjectMonitor</code> monitoring the object being observed
///
/// \param object the <code>NSManagedObject</code> instance being observed
///
- (void)objectMonitor:(CSObjectMonitor * _Nonnull)monitor willUpdateObject:(id _Nonnull)object;
/// Handles processing right after a change to the observed <code>object</code> occurs
/// \param monitor the <code>CSObjectMonitor</code> monitoring the object being observed
///
/// \param object the <code>NSManagedObject</code> instance being observed
///
/// \param changedPersistentKeys an <code>NSSet</code> of key paths for the attributes that were changed. Note that <code>changedPersistentKeys</code> only contains keys for attributes/relationships present in the persistent store, thus transient properties will not be reported.
///
- (void)objectMonitor:(CSObjectMonitor * _Nonnull)monitor didUpdateObject:(id _Nonnull)object changedPersistentKeys:(NSSet<NSString *> * _Nonnull)changedPersistentKeys;
/// Handles processing right after <code>object</code> is deleted
/// \param monitor the <code>CSObjectMonitor</code> monitoring the object being observed
///
/// \param object the <code>NSManagedObject</code> instance being observed
///
- (void)objectMonitor:(CSObjectMonitor * _Nonnull)monitor didDeleteObject:(id _Nonnull)object;
@end

@class NSSortDescriptor;

/// The <code>CSOrderBy</code> serves as the Objective-C bridging type for <code>OrderBy</code>.
/// seealso:
/// <code>OrderBy</code>
SWIFT_CLASS("_TtC9CoreStore9CSOrderBy")
@interface CSOrderBy : NSObject <CSDeleteClause, CSFetchClause, CSQueryClause>
/// The list of sort descriptors
@property (nonatomic, readonly, copy) NSArray<NSSortDescriptor *> * _Nonnull sortDescriptors;
/// Initializes a <code>CSOrderBy</code> clause with a single sort descriptor
/// \code
/// MyPersonEntity *people = [transaction
///    fetchAllFrom:CSFromClass([MyPersonEntity class])
///    fetchClauses:@[CSOrderByKey(CSSortAscending(@"fullname"))]]];
///
/// \endcode\param sortDescriptor a <code>NSSortDescriptor</code>
///
- (nonnull instancetype)initWithSortDescriptor:(NSSortDescriptor * _Nonnull)sortDescriptor;
/// Initializes a <code>CSOrderBy</code> clause with a list of sort descriptors
/// \code
/// MyPersonEntity *people = [transaction
///    fetchAllFrom:CSFromClass([MyPersonEntity class])
///    fetchClauses:@[CSOrderByKeys(CSSortAscending(@"fullname"), CSSortDescending(@"age"), nil))]]];
///
/// \endcode\param sortDescriptors an array of <code>NSSortDescriptor</code>s
///
- (nonnull instancetype)initWithSortDescriptors:(NSArray<NSSortDescriptor *> * _Nonnull)sortDescriptors;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (void)applyToFetchRequest:(NSFetchRequest<id <NSFetchRequestResult>> * _Nonnull)fetchRequest;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



/// The <code>CSSQLiteStore</code> serves as the Objective-C bridging type for <code>SQLiteStore</code>.
/// seealso:
/// <code>SQLiteStore</code>
SWIFT_CLASS("_TtC9CoreStore13CSSQLiteStore") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSSQLiteStore : NSObject <CSLocalStorage>
/// Initializes an SQLite store interface from the given SQLite file URL. When this instance is passed to the <code>CSDataStack</code>’s <code>-addStorage*:</code> methods, a new SQLite file will be created if it does not exist.
/// important:
/// Initializing <code>CSSQLiteStore</code>s with custom migration mapping models is currently not supported. Create an <code>SQLiteStore</code> instance from Swift code and bridge the instance to Objective-C using its <code>SQLiteStore.bridgeToObjectiveC</code> property.
/// \param fileURL the local file URL for the target SQLite persistent store. Note that if you have multiple configurations, you will need to specify a different <code>fileURL</code> explicitly for each of them.
///
/// \param configuration an optional configuration name from the model file. If not specified, defaults to <code>nil</code>, the “Default” configuration. Note that if you have multiple configurations, you will need to specify a different <code>fileURL</code> explicitly for each of them.
///
/// \param localStorageOptions When the <code>CSSQLiteStore</code> is passed to the <code>CSDataStack</code>’s <code>addStorage()</code> methods, tells the <code>CSDataStack</code> how to setup the persistent store. Defaults to <code>CSLocalStorageOptionsNone</code>.
///
- (nonnull instancetype)initWithFileURL:(NSURL * _Nonnull)fileURL configuration:(NSString * _Nullable)configuration localStorageOptions:(NSInteger)localStorageOptions;
/// Initializes an SQLite store interface from the given SQLite file name. When this instance is passed to the <code>CSDataStack</code>’s <code>-addStorage*:</code> methods, a new SQLite file will be created if it does not exist.
/// important:
/// Initializing <code>CSSQLiteStore</code>s with custom migration mapping models is currently not supported. Create an <code>SQLiteStore</code> instance from Swift code and bridge the instance to Objective-C using its <code>SQLiteStore.bridgeToObjectiveC</code> property.
/// \param fileName the local filename for the SQLite persistent store in the “Application Support/<bundle id>” directory (or the “Caches/<bundle id>” directory on tvOS). Note that if you have multiple configurations, you will need to specify a different <code>fileName</code> explicitly for each of them.
///
/// \param configuration an optional configuration name from the model file. If not specified, defaults to <code>nil</code>, the “Default” configuration. Note that if you have multiple configurations, you will need to specify a different <code>fileName</code> explicitly for each of them.
///
/// \param localStorageOptions When the <code>CSSQLiteStore</code> is passed to the <code>CSDataStack</code>’s <code>addStorage()</code> methods, tells the <code>CSDataStack</code> how to setup the persistent store. Defaults to <code>[CSLocalStorageOptions none]</code>.
///
- (nonnull instancetype)initWithFileName:(NSString * _Nonnull)fileName configuration:(NSString * _Nullable)configuration localStorageOptions:(NSInteger)localStorageOptions;
/// Initializes an <code>CSSQLiteStore</code> with an all-default settings: a <code>fileURL</code> pointing to a “<Application name>.sqlite” file in the “Application Support/<bundle id>” directory (or the “Caches/<bundle id>” directory on tvOS), a <code>nil</code> <code>configuration</code> pertaining to the “Default” configuration, and <code>localStorageOptions</code> set to <code>[CSLocalStorageOptions none]</code>.
/// important:
/// Initializing <code>CSSQLiteStore</code>s with custom migration mapping models is currently not supported. Create an <code>SQLiteStore</code> instance from Swift code and bridge the instance to Objective-C using its <code>SQLiteStore.bridgeToObjectiveC</code> property.
- (nonnull instancetype)init;
/// The <code>NSURL</code> that points to the SQLite file
@property (nonatomic, readonly, copy) NSURL * _Nonnull fileURL;
/// An array of <code>SchemaMappingProvider</code>s that provides the complete mapping models for custom migrations. This is currently only supported for Swift code.
@property (nonatomic, readonly, copy) NSArray * _Nonnull migrationMappingProviders;
/// Options that tell the <code>CSDataStack</code> how to setup the persistent store
@property (nonatomic, readonly) NSInteger localStorageOptions;
/// The string identifier for the <code>NSPersistentStore</code>’s <code>type</code> property. For <code>CSSQLiteStore</code>s, this is always set to <code>NSSQLiteStoreType</code>.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull storeType;)
+ (NSString * _Nonnull)storeType SWIFT_WARN_UNUSED_RESULT;
/// The configuration name in the model file
@property (nonatomic, readonly, copy) NSString * _Nullable configuration;
/// The options dictionary for the <code>NSPersistentStore</code>. For <code>CSSQLiteStore</code>s, this is always set to
/// \code
/// [NSSQLitePragmasOption: ["journal_mode": "WAL"]]
///
/// \endcode
@property (nonatomic, readonly, copy) NSDictionary * _Nullable storeOptions;
/// Called by the <code>CSDataStack</code> to perform actual deletion of the store file from disk. Do not call directly! The <code>sourceModel</code> argument is a hint for the existing store’s model version. For <code>CSSQLiteStore</code>, this converts the database’s WAL journaling mode to DELETE before deleting the file.
- (BOOL)cs_eraseStorageAndWaitWithMetadata:(NSDictionary * _Nonnull)metadata soureModelHint:(NSManagedObjectModel * _Nullable)soureModelHint error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
@end


/// The <code>CSSectionBy</code> serves as the Objective-C bridging type for <code>SectionBy</code>.
/// seealso:
/// <code>SectionBy</code>
SWIFT_CLASS("_TtC9CoreStore11CSSectionBy") SWIFT_AVAILABILITY(macos,introduced=10.12)
@interface CSSectionBy : NSObject
/// Initializes a <code>CSSectionBy</code> clause with the key path to use to group <code>CSListMonitor</code> objects into sections
/// \param sectionKeyPath the key path to use to group the objects into sections
///
///
/// returns:
/// a <code>CSSectionBy</code> clause with the key path to use to group <code>CSListMonitor</code> objects into sections
+ (CSSectionBy * _Nonnull)keyPath:(NSString * _Nonnull)sectionKeyPath SWIFT_WARN_UNUSED_RESULT;
/// Initializes a <code>CSSectionBy</code> clause with the key path to use to group <code>CSListMonitor</code> objects into sections, and a closure to transform the value for the key path to an appropriate section name
/// \param sectionKeyPath the key path to use to group the objects into sections
///
/// \param sectionIndexTransformer a closure to transform the value for the key path to an appropriate section name
///
///
/// returns:
/// a <code>CSSectionBy</code> clause with the key path to use to group <code>CSListMonitor</code> objects into sections
+ (CSSectionBy * _Nonnull)keyPath:(NSString * _Nonnull)sectionKeyPath sectionIndexTransformer:(NSString * _Nullable (^ _Nonnull)(NSString * _Nullable))sectionIndexTransformer SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class CSSelectTerm;

/// The <code>CSSelect</code> serves as the Objective-C bridging type for <code>Select</code>.
/// seealso:
/// <code>Select</code>
SWIFT_CLASS("_TtC9CoreStore8CSSelect")
@interface CSSelect : NSObject
/// Creates a <code>CSSelect</code> clause for querying <code>NSNumber</code> values.
/// \code
/// NSNumber *maxAge = [CSCoreStore
///    queryValueFrom:CSFromClass([MyPersonEntity class])
///    select:CSSelectNumber(CSAggregateMax(@"age"))
///    // ...
///
/// \endcode\param numberTerm the <code>CSSelectTerm</code> specifying the attribute/aggregate value to query
///
- (nonnull instancetype)initWithNumberTerm:(CSSelectTerm * _Nonnull)numberTerm;
/// Creates a <code>CSSelect</code> clause for querying <code>NSDecimalNumber</code> values.
/// \code
/// NSDecimalNumber *averagePrice = [CSCoreStore
///    queryValueFrom:CSFromClass([MyPersonEntity class])
///    select:CSSelectDecimal(CSAggregateAverage(@"price"))
///    // ...
///
/// \endcode\param decimalTerm the <code>CSSelectTerm</code> specifying the attribute/aggregate value to query
///
- (nonnull instancetype)initWithDecimalTerm:(CSSelectTerm * _Nonnull)decimalTerm;
/// Creates a <code>CSSelect</code> clause for querying <code>NSString</code> values.
/// \code
/// NSString *fullname = [CSCoreStore
///    queryValueFrom:CSFromClass([MyPersonEntity class])
///    select:CSSelectString(CSAttribute(@"fullname"))
///    // ...
///
/// \endcode\param stringTerm the <code>CSSelectTerm</code> specifying the attribute/aggregate value to query
///
- (nonnull instancetype)initWithStringTerm:(CSSelectTerm * _Nonnull)stringTerm;
/// Creates a <code>CSSelect</code> clause for querying <code>NSDate</code> values.
/// \code
/// NSDate *lastUpdate = [CSCoreStore
///    queryValueFrom:CSFromClass([MyPersonEntity class])
///    select:CSSelectDate(CSAggregateMax(@"updatedDate"))
///    // ...
///
/// \endcode\param dateTerm the <code>CSSelectTerm</code> specifying the attribute/aggregate value to query
///
- (nonnull instancetype)initWithDateTerm:(CSSelectTerm * _Nonnull)dateTerm;
/// Creates a <code>CSSelect</code> clause for querying <code>NSData</code> values.
/// \code
/// NSData *imageData = [CSCoreStore
///    queryValueFrom:CSFromClass([MyPersonEntity class])
///    select:CSSelectData(CSAttribute(@"imageData"))
///    // ...
///
/// \endcode\param dataTerm the <code>CSSelectTerm</code> specifying the attribute/aggregate value to query
///
- (nonnull instancetype)initWithDataTerm:(CSSelectTerm * _Nonnull)dataTerm;
/// Creates a <code>CSSelect</code> clause for querying <code>NSManagedObjectID</code> values.
/// \code
/// NSManagedObjectID *objectID = [CSCoreStore
///    queryValueFrom:CSFromClass([MyPersonEntity class])
///    select:CSSelectObjectID()
///    // ...
///
/// \endcode
- (nonnull instancetype)initWithObjectIDTerm;
/// Creates a <code>CSSelect</code> clause for querying <code>NSDictionary</code> of an entity’s attribute keys and values.
/// \code
/// NSDictionary *keyValues = [CSCoreStore
///     queryValueFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     select:[CSSelect dictionaryForTerm:[CSSelectTerm maximum:@"age" as:nil]]];
///
/// \endcode\param term the <code>CSSelectTerm</code> specifying the attribute/aggregate value to query
///
///
/// returns:
/// a <code>CSSelect</code> clause for querying an entity attribute
+ (CSSelect * _Nonnull)dictionaryForTerm:(CSSelectTerm * _Nonnull)term SWIFT_WARN_UNUSED_RESULT;
/// Creates a <code>CSSelect</code> clause for querying <code>NSDictionary</code> of an entity’s attribute keys and values.
/// \code
/// NSDictionary *keyValues = [CSCoreStore
///     queryValueFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     select:[CSSelect dictionaryForTerms:@[
///         [CSSelectTerm attribute:@"name" as:nil],
///         [CSSelectTerm attribute:@"age" as:nil]
///     ]]];
///
/// \endcode\param terms the <code>CSSelectTerm</code>s specifying the attribute/aggregate values to query
///
///
/// returns:
/// a <code>CSSelect</code> clause for querying an entity attribute
+ (CSSelect * _Nonnull)dictionaryForTerms:(NSArray<CSSelectTerm *> * _Nonnull)terms SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The <code>CSSelectTerm</code> serves as the Objective-C bridging type for <code>SelectTerm</code>.
/// seealso:
/// <code>SelectTerm</code>
SWIFT_CLASS("_TtC9CoreStore12CSSelectTerm")
@interface CSSelectTerm : NSObject
/// Provides a <code>CSSelectTerm</code> to a <code>CSSelect</code> clause for querying an entity attribute.
/// \code
/// NSString *fullName = [CSCoreStore
///     queryValueFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     select:CSSelectString(CSAttribute(@"fullname"))
///     fetchClauses:@[[CSWhere keyPath:@"employeeID" isEqualTo: @1111]]];
///
/// \endcode\param keyPath the attribute name
///
- (nonnull instancetype)initWithKeyPath:(NSString * _Nonnull)keyPath;
/// Provides a <code>CSSelectTerm</code> to a <code>CSSelect</code> clause for querying the average value of an attribute.
/// \code
/// NSNumber *averageAge = [CSCoreStore
///     queryValueFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     select:[CSSelect numberForTerm:[CSSelectTerm average:@"age" as:nil]]];
///
/// \endcode<ul>
///   <li>
///     <code>as</code>: the dictionary key to use to access the result. Ignored when the query return value is not an <code>NSDictionary</code>. If <code>nil</code>, the default key “average(<attributeName>)” is used
///   </li>
/// </ul>
/// \param keyPath the attribute name
///
///
/// returns:
/// a <code>CSSelectTerm</code> to a <code>CSSelect</code> clause for querying the average value of an attribute
+ (CSSelectTerm * _Nonnull)average:(NSString * _Nonnull)keyPath as:(NSString * _Nullable)alias SWIFT_WARN_UNUSED_RESULT;
/// Provides a <code>CSSelectTerm</code> to a <code>CSSelect</code> clause for a count query.
/// \code
/// NSNumber *numberOfEmployees = [CSCoreStore
///     queryValueFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     select:[CSSelect numberForTerm:[CSSelectTerm count:@"employeeID" as:nil]]];
///
/// \endcode\param keyPath the attribute name
///
/// \param alias the dictionary key to use to access the result. Ignored when the query return value is not an <code>NSDictionary</code>. If <code>nil</code>, the default key “count(<attributeName>)” is used
///
///
/// returns:
/// a <code>SelectTerm</code> to a <code>Select</code> clause for a count query
+ (CSSelectTerm * _Nonnull)count:(NSString * _Nonnull)keyPath as:(NSString * _Nullable)alias SWIFT_WARN_UNUSED_RESULT;
/// Provides a <code>CSSelectTerm</code> to a <code>CSSelect</code> clause for querying the maximum value for an attribute.
/// \code
/// NSNumber *maximumAge = [CSCoreStore
///     queryValueFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     select:[CSSelect numberForTerm:[CSSelectTerm maximum:@"age" as:nil]]];
///
/// \endcode\param keyPath the attribute name
///
/// \param alias the dictionary key to use to access the result. Ignored when the query return value is not an <code>NSDictionary</code>. If <code>nil</code>, the default key “max(<attributeName>)” is used
///
///
/// returns:
/// a <code>CSSelectTerm</code> to a <code>CSSelect</code> clause for querying the maximum value for an attribute
+ (CSSelectTerm * _Nonnull)maximum:(NSString * _Nonnull)keyPath as:(NSString * _Nullable)alias SWIFT_WARN_UNUSED_RESULT;
/// Provides a <code>CSSelectTerm</code> to a <code>CSSelect</code> clause for querying the minimum value for an attribute.
/// \code
/// NSNumber *minimumAge = [CSCoreStore
///     queryValueFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     select:[CSSelect numberForTerm:[CSSelectTerm minimum:@"age" as:nil]]];
///
/// \endcode\param keyPath the attribute name
///
/// \param alias the dictionary key to use to access the result. Ignored when the query return value is not an <code>NSDictionary</code>. If <code>nil</code>, the default key “min(<attributeName>)” is used
///
///
/// returns:
/// a <code>CSSelectTerm</code> to a <code>CSSelect</code> clause for querying the minimum value for an attribute
+ (CSSelectTerm * _Nonnull)minimum:(NSString * _Nonnull)keyPath as:(NSString * _Nullable)alias SWIFT_WARN_UNUSED_RESULT;
/// Provides a <code>CSSelectTerm</code> to a <code>CSSelect</code> clause for querying the sum value for an attribute.
/// \code
/// NSNumber *totalAge = [CSCoreStore
///     queryValueFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     select:[CSSelect numberForTerm:[CSSelectTerm sum:@"age" as:nil]]];
///
/// \endcode\param keyPath the attribute name
///
/// \param alias the dictionary key to use to access the result. Ignored when the query return value is not an <code>NSDictionary</code>. If <code>nil</code>, the default key “sum(<attributeName>)” is used
///
///
/// returns:
/// a <code>CSSelectTerm</code> to a <code>CSSelect</code> clause for querying the sum value for an attribute
+ (CSSelectTerm * _Nonnull)sum:(NSString * _Nonnull)keyPath as:(NSString * _Nullable)alias SWIFT_WARN_UNUSED_RESULT;
/// Provides a <code>CSSelectTerm</code> to a <code>CSSelect</code> clause for querying the <code>NSManagedObjectID</code>.
/// \code
/// NSManagedObjectID *objectID = [CSCoreStore
///     queryValueFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     select:[CSSelect objectIDForTerm:[CSSelectTerm objectIDAs:nil]]
///     fetchClauses:@[[CSWhere keyPath:@"employeeID" isEqualTo: @1111]]];
///
/// \endcode\param alias the dictionary key to use to access the result. Ignored when the query return value is not an <code>NSDictionary</code>. If <code>nil</code>, the default key “objecID” is used
///
///
/// returns:
/// a <code>SelectTerm</code> to a <code>Select</code> clause for querying the sum value for an attribute
+ (CSSelectTerm * _Nonnull)objectIDAs:(NSString * _Nullable)alias SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The <code>CSSetupResult</code> serves as the Objective-C bridging type for <code>SetupResult</code>.
/// seealso:
/// <code>SetupResult</code>
SWIFT_CLASS("_TtC9CoreStore13CSSetupResult") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSSetupResult : NSObject
/// <code>YES</code> if adding the <code>CSStorageInterface</code> to the <code>CSDataStack</code> succeeded, <code>NO</code> otherwise.
@property (nonatomic, readonly) BOOL isSuccess;
/// <code>YES</code> if adding the <code>CSStorageInterface</code> to the <code>CSDataStack</code> failed, <code>NO</code> otherwise. When <code>YES</code>, the <code>error</code> property returns the actual <code>NSError</code> for the failure.
@property (nonatomic, readonly) BOOL isFailure;
/// A <code>CSStorageInterface</code> instance if the <code>commit</code> operation for the transaction succeeded. Returns <code>nil</code> otherwise.
@property (nonatomic, readonly, strong) id <CSStorageInterface> _Nullable storage;
/// The <code>NSError</code> for a failed <code>commit</code> operation, or <code>nil</code> if the <code>commit</code> succeeded
@property (nonatomic, readonly, strong) NSError * _Nullable error;
/// If the result was a success, the <code>success</code> block is executed with the <code>CSStorageInterface</code> instance that was added to the <code>CSDataStack</code>. If the result was a failure, the <code>failure</code> block is executed with an <code>NSError</code> argument pertaining to the actual error.
/// The blocks are executed immediately as <code>@noescape</code> and will not be retained.
/// \param success the block to execute on success. The block passes a <code>CSStorageInterface</code> instance that was added to the <code>CSDataStack</code>.
///
/// \param failure the block to execute on failure. The block passes an <code>NSError</code> argument that pertains to the actual error.
///
- (void)handleSuccess:(SWIFT_NOESCAPE void (^ _Nonnull)(id <CSStorageInterface> _Nonnull))success failure:(SWIFT_NOESCAPE void (^ _Nonnull)(NSError * _Nonnull))failure;
/// If the result was a success, the <code>success</code> block is executed with a <code>BOOL</code> argument that indicates if there were any changes made. If the result was a failure, this method does nothing.
/// The block is executed immediately as <code>@noescape</code> and will not be retained.
/// \param success the block to execute on success. The block passes a <code>BOOL</code> argument that indicates if there were any changes made.
///
- (void)handleSuccess:(SWIFT_NOESCAPE void (^ _Nonnull)(id <CSStorageInterface> _Nonnull))success;
/// If the result was a failure, the <code>failure</code> block is executed with an <code>NSError</code> argument pertaining to the actual error. If the result was a success, this method does nothing.
/// The block is executed immediately as <code>@noescape</code> and will not be retained.
/// \param failure the block to execute on failure. The block passes an <code>NSError</code> argument that pertains to the actual error.
///
- (void)handleFailure:(SWIFT_NOESCAPE void (^ _Nonnull)(NSError * _Nonnull))failure;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



/// The <code>CSSynchronousDataTransaction</code> serves as the Objective-C bridging type for <code>SynchronousDataTransaction</code>.
/// seealso:
/// <code>SynchronousDataTransaction</code>
SWIFT_CLASS("_TtC9CoreStore28CSSynchronousDataTransaction") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSSynchronousDataTransaction : CSBaseDataTransaction
/// Saves the transaction changes and waits for completion synchronously. This method should not be used after the <code>-commitAndWaitWithError:</code> method was already called once.
/// \param error the <code>CSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// <code>YES</code> if the commit succeeded, <code>NO</code> if the commit failed. If <code>NO</code>, the <code>error</code> argument will hold error information.
- (BOOL)commitAndWaitWithError:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
/// Creates a new <code>NSManagedObject</code> with the specified entity type.
/// \param into the <code>CSInto</code> clause indicating the destination <code>NSManagedObject</code> entity type and the destination configuration
///
///
/// returns:
/// a new <code>NSManagedObject</code> instance of the specified entity type.
- (id _Nonnull)createInto:(CSInto * _Nonnull)into SWIFT_WARN_UNUSED_RESULT;
/// Returns an editable proxy of a specified <code>NSManagedObject</code>. This method should not be used after the <code>-commitAndWait</code> method was already called once.
/// \param object the <code>NSManagedObject</code> type to be edited
///
///
/// returns:
/// an editable proxy for the specified <code>NSManagedObject</code>.
- (id _Nullable)editObject:(NSManagedObject * _Nullable)object SWIFT_WARN_UNUSED_RESULT;
/// Returns an editable proxy of the object with the specified <code>NSManagedObjectID</code>. This method should not be used after the <code>-commitAndWait</code> method was already called once.
/// \param into a <code>CSInto</code> clause specifying the entity type
///
/// \param objectID the <code>NSManagedObjectID</code> for the object to be edited
///
///
/// returns:
/// an editable proxy for the specified <code>NSManagedObject</code>.
- (id _Nullable)editInto:(CSInto * _Nonnull)into objectID:(NSManagedObjectID * _Nonnull)objectID SWIFT_WARN_UNUSED_RESULT;
/// Deletes a specified <code>NSManagedObject</code>. This method should not be used after the <code>-commitAndWait</code> method was already called once.
/// \param object the <code>NSManagedObject</code> type to be deleted
///
- (void)deleteObject:(NSManagedObject * _Nullable)object;
/// Deletes the specified <code>NSManagedObject</code>s.
/// \param objects the <code>NSManagedObject</code>s to be deleted
///
- (void)deleteObjects:(NSArray<NSManagedObject *> * _Nonnull)objects;
@end


/// The <code>CSTweak</code> serves as the Objective-C bridging type for <code>Tweak</code>.
/// seealso:
/// <code>Tweak</code>
SWIFT_CLASS("_TtC9CoreStore7CSTweak") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSTweak : NSObject <CSDeleteClause, CSFetchClause, CSQueryClause>
/// The block to customize the <code>NSFetchRequest</code>
@property (nonatomic, readonly, copy) void (^ _Nonnull block)(NSFetchRequest<id <NSFetchRequestResult>> * _Nonnull);
/// Initializes a <code>CSTweak</code> clause with a closure where the <code>NSFetchRequest</code> may be configured.
/// important:
/// <code>CSTweak</code>’s closure is executed only just before the fetch occurs, so make sure that any values captured by the closure is not prone to race conditions. Also, some utilities (such as <code>CSListMonitor</code>s) may keep <code>CSFetchClause</code>s in memory and may thus introduce retain cycles if reference captures are not handled properly.
/// \param block the block to customize the <code>NSFetchRequest</code>
///
- (nonnull instancetype)initWithBlock:(void (^ _Nonnull)(NSFetchRequest<id <NSFetchRequestResult>> * _Nonnull))block;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (void)applyToFetchRequest:(NSFetchRequest<id <NSFetchRequestResult>> * _Nonnull)fetchRequest;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The <code>CSUnsafeDataModelSchema</code> serves as the Objective-C bridging type for <code>UnsafeDataModelSchema</code>.
/// seealso:
/// <code>UnsafeDataModelSchema</code>
SWIFT_CLASS("_TtC9CoreStore23CSUnsafeDataModelSchema") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSUnsafeDataModelSchema : NSObject <CSDynamicSchema>
/// Initializes a <code>CSUnsafeDataModelSchema</code> from an <code>NSManagedObjectModel</code>.
/// \param modelName the model version, typically the file name of an *.xcdatamodeld file (without the file extension)
///
/// \param model the <code>NSManagedObjectModel</code>
///
- (nonnull instancetype)initWithModelName:(NSString * _Nonnull)modelName model:(NSManagedObjectModel * _Nonnull)model OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
@property (nonatomic, readonly, copy) NSString * _Nonnull modelVersion;
- (NSManagedObjectModel * _Nonnull)rawModel SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class NSManagedObjectContext;

/// The <code>CSUnsafeDataTransaction</code> serves as the Objective-C bridging type for <code>UnsafeDataTransaction</code>.
/// seealso:
/// <code>UnsafeDataTransaction</code>
SWIFT_CLASS("_TtC9CoreStore23CSUnsafeDataTransaction") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSUnsafeDataTransaction : CSBaseDataTransaction
/// Saves the transaction changes asynchronously. For a <code>CSUnsafeDataTransaction</code>, multiple commits are allowed, although it is the developer’s responsibility to ensure a reasonable leeway to prevent blocking the main thread.
/// \param success the block executed if the save succeeds.
///
/// \param failure the block executed if the save fails. A <code>CSError</code> is reported as the argument of the block.
///
- (void)commitWithSuccess:(void (^ _Nullable)(void))success :(void (^ _Nullable)(CSError * _Nonnull))failure;
/// Saves the transaction changes and waits for completion synchronously. For a <code>CSUnsafeDataTransaction</code>, multiple commits are allowed, although it is the developer’s responsibility to ensure a reasonable leeway to prevent blocking the main thread.
/// \param error the <code>CSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// <code>YES</code> if the commit succeeded, <code>NO</code> if the commit failed. If <code>NO</code>, the <code>error</code> argument will hold error information.
- (BOOL)commitAndWaitWithError:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
/// Rolls back the transaction.
- (void)rollback;
/// Undo’s the last change made to the transaction.
- (void)undo;
/// Redo’s the last undone change to the transaction.
- (void)redo;
/// Immediately flushes all pending changes to the transaction’s observers. This is useful in conjunction with <code>ListMonitor</code>s and <code>ObjectMonitor</code>s created from <code>UnsafeDataTransaction</code>s used to manage temporary “scratch” data.
/// important:
/// Note that unlike <code>commit()</code>, <code>flush()</code> does not propagate/save updates to the <code>DataStack</code> and the persistent store. However, the flushed changes will be seen by children transactions created further from the current transaction (i.e. through <code>transaction.beginUnsafe()</code>)
- (void)flush;
/// Flushes all pending changes to the transaction’s observers at the end of the <code>closure</code>’s execution. This is useful in conjunction with <code>ListMonitor</code>s and <code>ObjectMonitor</code>s created from <code>UnsafeDataTransaction</code>s used to manage temporary “scratch” data.
/// important:
/// Note that unlike <code>commit()</code>, <code>flush()</code> does not propagate/save updates to the <code>DataStack</code> and the persistent store. However, the flushed changes will be seen by children transactions created further from the current transaction (i.e. through <code>transaction.beginUnsafe()</code>)
/// \param block the block where changes can be made prior to the flush
///
- (void)flush:(SWIFT_NOESCAPE void (^ _Nonnull)(void))block;
/// Begins a child transaction where <code>NSManagedObject</code> creates, updates, and deletes can be made. This is useful for making temporary changes, such as partially filled forms.
/// To support “undo” methods such as <code>-undo</code>, <code>-redo</code>, and <code>-rollback</code>, use the <code>-beginSafeWithSupportsUndo:</code> method passing <code>YES</code> to the argument. Without “undo” support, calling those methods will raise an exception.
///
/// returns:
/// a <code>CSUnsafeDataTransaction</code> instance where creates, updates, and deletes can be made.
- (CSUnsafeDataTransaction * _Nonnull)beginUnsafe SWIFT_WARN_UNUSED_RESULT;
/// Begins a child transaction where <code>NSManagedObject</code> creates, updates, and deletes can be made. This is useful for making temporary changes, such as partially filled forms.
/// <ul>
///   <li>
///     prameter supportsUndo: <code>-undo</code>, <code>-redo</code>, and <code>-rollback</code> methods are only available when this parameter is <code>YES</code>, otherwise those method will raise an exception. Note that turning on Undo support may heavily impact performance especially on iOS or watchOS where memory is limited.
///   </li>
/// </ul>
///
/// returns:
/// a <code>CSUnsafeDataTransaction</code> instance where creates, updates, and deletes can be made.
- (CSUnsafeDataTransaction * _Nonnull)beginUnsafeWithSupportsUndo:(BOOL)supportsUndo SWIFT_WARN_UNUSED_RESULT;
/// Returns the <code>NSManagedObjectContext</code> for this unsafe transaction. Use only for cases where external frameworks need an <code>NSManagedObjectContext</code> instance to work with.
/// Note that it is the developer’s responsibility to ensure the following:
/// <ul>
///   <li>
///     that the <code>CSUnsafeDataTransaction</code> that owns this context should be strongly referenced and prevented from being deallocated during the context’s lifetime
///   </li>
///   <li>
///     that all saves will be done either through the <code>CSUnsafeDataTransaction</code>’s <code>-commit:</code> or <code>-commitAndWait</code> method, or by calling <code>-save:</code> manually on the context, its parent, and all other ancestor contexts if there are any.
///   </li>
/// </ul>
- (NSManagedObjectContext * _Nonnull)unsafeContext SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
@end

@class NSPredicate;
@protocol CoreDataNativeType;

/// The <code>CSWhere</code> serves as the Objective-C bridging type for <code>Where</code>.
/// seealso:
/// <code>Where</code>
SWIFT_CLASS("_TtC9CoreStore7CSWhere")
@interface CSWhere : NSObject <CSDeleteClause, CSFetchClause, CSQueryClause>
/// The internal <code>NSPredicate</code> instance for the <code>Where</code> clause
@property (nonatomic, readonly, strong) NSPredicate * _Nonnull predicate;
/// Initializes a <code>CSWhere</code> clause with a predicate that always evaluates to the specified boolean value
/// \code
/// MyPersonEntity *people = [transaction
///    fetchAllFrom:CSFromClass([MyPersonEntity class])
///    fetchClauses:@[CSWhereValue(YES)]]];
///
/// \endcode\param value the boolean value for the predicate
///
- (nonnull instancetype)initWithValue:(BOOL)value;
/// Initializes a <code>CSWhere</code> clause with a predicate using the specified string format and arguments
/// \code
/// NSPredicate *predicate = // ...
/// MyPersonEntity *people = [transaction
///    fetchAllFrom:CSFromClass([MyPersonEntity class])
///    fetchClauses:@[CSWherePredicate(predicate)]];
///
/// \endcode\param format the format string for the predicate
///
/// \param argumentArray the arguments for <code>format</code>
///
- (nonnull instancetype)initWithFormat:(NSString * _Nonnull)format argumentArray:(NSArray<NSObject *> * _Nullable)argumentArray;
/// Initializes a <code>CSWhere</code> clause that compares equality
/// \param keyPath the keyPath to compare with
///
/// \param value the arguments for the <code>==</code> operator
///
- (nonnull instancetype)initWithKeyPath:(NSString * _Nonnull)keyPath isEqualTo:(id <CoreDataNativeType> _Nullable)value;
/// Initializes a <code>CSWhere</code> clause that compares membership
/// \param keyPath the keyPath to compare with
///
/// \param list the array to check membership of
///
- (nonnull instancetype)initWithKeyPath:(NSString * _Nonnull)keyPath isMemberOf:(NSArray<id <CoreDataNativeType>> * _Nonnull)list;
/// Initializes a <code>CSWhere</code> clause with an <code>NSPredicate</code>
/// \param predicate the <code>NSPredicate</code> for the fetch or query
///
- (nonnull instancetype)initWithPredicate:(NSPredicate * _Nonnull)predicate;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (void)applyToFetchRequest:(NSFetchRequest<id <NSFetchRequestResult>> * _Nonnull)fetchRequest;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The <code>CSXcodeDataModelSchema</code> serves as the Objective-C bridging type for <code>XcodeDataModelSchema</code>.
/// seealso:
/// <code>XcodeDataModelSchema</code>
SWIFT_CLASS("_TtC9CoreStore22CSXcodeDataModelSchema") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSXcodeDataModelSchema : NSObject <CSDynamicSchema>
/// Initializes an <code>CSXcodeDataModelSchema</code> from an *.xcdatamodeld file URL.
/// \param modelName the model version, typically the file name of an *.xcdatamodeld file (without the file extension)
///
/// \param modelVersionFileURL the file URL that points to the .xcdatamodeld’s “momd” file.
///
- (nonnull instancetype)initWithModelName:(NSString * _Nonnull)modelName modelVersionFileURL:(NSURL * _Nonnull)modelVersionFileURL OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
@property (nonatomic, readonly, copy) NSString * _Nonnull modelVersion;
- (NSManagedObjectModel * _Nonnull)rawModel SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Objective-C Foundation types that are natively supported by Core Data managed attributes all conform to <code>CoreDataNativeType</code>.
SWIFT_PROTOCOL("_TtP9CoreStore18CoreDataNativeType_")
@protocol CoreDataNativeType <NSObject>
@end


SWIFT_CLASS("_TtC9CoreStore22CoreStoreManagedObject")
@interface CoreStoreManagedObject : NSManagedObject
- (nonnull instancetype)initWithEntity:(NSEntityDescription * _Nonnull)entity insertIntoManagedObjectContext:(NSManagedObjectContext * _Nullable)context OBJC_DESIGNATED_INITIALIZER;
@end






@interface NSData (SWIFT_EXTENSION(CoreStore)) <CoreDataNativeType>
@end










@interface NSDate (SWIFT_EXTENSION(CoreStore)) <CoreDataNativeType>
@end








@interface NSDecimalNumber (SWIFT_EXTENSION(CoreStore))
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSAttributeType cs_rawAttributeType;)
+ (NSAttributeType)cs_rawAttributeType SWIFT_WARN_UNUSED_RESULT;
@end














@interface NSManagedObject (SWIFT_EXTENSION(CoreStore)) <CoreDataNativeType>
@end












@interface NSManagedObject (SWIFT_EXTENSION(CoreStore))
/// Provides a convenience wrapper for accessing <code>-primitiveValueForKey:</code> with proper calls to <code>-willAccessValueForKey:</code> and <code>-didAccessValueForKey:</code>. This is useful when implementing accessor methods for transient attributes.
/// \param KVCKey the KVC key
///
///
/// returns:
/// the primitive value for the KVC key
- (id _Nullable)cs_accessValueForKVCKey:(NSString * _Nonnull)KVCKey SWIFT_WARN_UNUSED_RESULT;
/// Provides a convenience wrapper for setting <code>-setPrimitiveValue:</code> with proper calls to <code>-willChangeValueForKey:</code> and <code>-didChangeValueForKey:</code>. This is useful when implementing mutator methods for transient attributes.
/// \param value the value to set the KVC key with
///
/// \param KVCKey the KVC key
///
- (void)cs_setValue:(id _Nullable)value forKVCKey:(NSString * _Nonnull)KVCKey;
/// Re-faults the object to use the latest values from the persistent store
- (void)cs_refreshAsFault;
@end






















@interface NSManagedObjectID (SWIFT_EXTENSION(CoreStore)) <CoreDataNativeType>
@end












@interface NSNull (SWIFT_EXTENSION(CoreStore)) <CoreDataNativeType>
@end






@interface NSNumber (SWIFT_EXTENSION(CoreStore)) <CoreDataNativeType>
@end






@interface NSNumber (SWIFT_EXTENSION(CoreStore))
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSAttributeType cs_rawAttributeType;)
+ (NSAttributeType)cs_rawAttributeType SWIFT_WARN_UNUSED_RESULT;
@end






@interface NSOrderedSet<ObjectType> (SWIFT_EXTENSION(CoreStore)) <CoreDataNativeType>
@end














@interface NSSet<ObjectType> (SWIFT_EXTENSION(CoreStore)) <CoreDataNativeType>
@end










@interface NSString (SWIFT_EXTENSION(CoreStore)) <CoreDataNativeType>
@end




























@interface NSProgress (SWIFT_EXTENSION(CoreStore))
/// Sets a closure that the <code>NSProgress</code> calls whenever its <code>fractionCompleted</code> changes. You can use this instead of setting up KVO.
/// \param closure the closure to execute on progress change
///
- (void)cs_setProgressHandler:(void (^ _Nullable)(NSProgress * _Nonnull))closure;
@end



#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop

#endif

#else
#if 0
#elif defined(__arm64__) && __arm64__
// Generated by Apple Swift version 5.1.3 (swiftlang-1100.0.282.1 clang-1100.0.33.15)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if !defined(IBSegueAction)
# define IBSegueAction
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import CoreData;
@import Foundation;
@import ObjectiveC;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="CoreStore",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif



@class CSInto;
@class NSManagedObject;
@class NSManagedObjectID;

/// The <code>CSBaseDataTransaction</code> serves as the Objective-C bridging type for <code>BaseDataTransaction</code>.
/// seealso:
/// <code>BaseDataTransaction</code>
SWIFT_CLASS("_TtC9CoreStore21CSBaseDataTransaction")
@interface CSBaseDataTransaction : NSObject
/// Indicates if the transaction has pending changes
@property (nonatomic, readonly) BOOL hasChanges;
/// Creates a new <code>NSManagedObject</code> with the specified entity type.
/// \param into the <code>CSInto</code> clause indicating the destination <code>NSManagedObject</code> entity type and the destination configuration
///
///
/// returns:
/// a new <code>NSManagedObject</code> instance of the specified entity type.
- (id _Nonnull)createInto:(CSInto * _Nonnull)into SWIFT_WARN_UNUSED_RESULT;
/// Returns an editable proxy of a specified <code>NSManagedObject</code>.
/// \param object the <code>NSManagedObject</code> type to be edited
///
///
/// returns:
/// an editable proxy for the specified <code>NSManagedObject</code>.
- (id _Nullable)editObject:(NSManagedObject * _Nullable)object SWIFT_WARN_UNUSED_RESULT;
/// Returns an editable proxy of the object with the specified <code>NSManagedObjectID</code>.
/// \param into a <code>CSInto</code> clause specifying the entity type
///
/// \param objectID the <code>NSManagedObjectID</code> for the object to be edited
///
///
/// returns:
/// an editable proxy for the specified <code>NSManagedObject</code>.
- (id _Nullable)editInto:(CSInto * _Nonnull)into objectID:(NSManagedObjectID * _Nonnull)objectID SWIFT_WARN_UNUSED_RESULT;
/// Deletes a specified <code>NSManagedObject</code>.
/// \param object the <code>NSManagedObject</code> to be deleted
///
- (void)deleteObject:(NSManagedObject * _Nullable)object;
/// Deletes the specified <code>NSManagedObject</code>s.
/// \param objects the <code>NSManagedObject</code>s to be deleted
///
- (void)deleteObjects:(NSArray<NSManagedObject *> * _Nonnull)objects;
/// Refreshes all registered objects <code>NSManagedObject</code>s in the transaction.
- (void)refreshAndMergeAllObjects;
/// Returns all pending <code>NSManagedObject</code>s of the specified type that were inserted to the transaction. This method should not be called after the <code>-commit*:</code> method was called.
/// \param entity the <code>NSManagedObject</code> subclass to filter
///
///
/// returns:
/// an <code>NSSet</code> of pending <code>NSManagedObject</code>s of the specified type that were inserted to the transaction.
- (NSSet<NSManagedObject *> * _Nonnull)insertedObjectsOfType:(SWIFT_METATYPE(NSManagedObject) _Nonnull)entity SWIFT_WARN_UNUSED_RESULT;
/// Returns all pending <code>NSManagedObjectID</code>s that were inserted to the transaction. This method should not be called after the <code>-commit*:</code> method was called.
///
/// returns:
/// an <code>NSSet</code> of pending <code>NSManagedObjectID</code>s that were inserted to the transaction.
- (NSSet<NSManagedObjectID *> * _Nonnull)insertedObjectIDs SWIFT_WARN_UNUSED_RESULT;
/// Returns all pending <code>NSManagedObjectID</code>s of the specified type that were inserted to the transaction. This method should not be called after the <code>-commit*:</code> method was called.
/// \param entity the <code>NSManagedObject</code> subclass to filter
///
///
/// returns:
/// an <code>NSSet</code> of pending <code>NSManagedObjectID</code>s of the specified type that were inserted to the transaction.
- (NSSet<NSManagedObjectID *> * _Nonnull)insertedObjectIDsOfType:(SWIFT_METATYPE(NSManagedObject) _Nonnull)entity SWIFT_WARN_UNUSED_RESULT;
/// Returns all pending <code>NSManagedObject</code>s of the specified type that were updated in the transaction. This method should not be called after the <code>-commit*:</code> method was called.
/// \param entity the <code>NSManagedObject</code> subclass to filter
///
///
/// returns:
/// an <code>NSSet</code> of pending <code>NSManagedObject</code>s of the specified type that were updated in the transaction.
- (NSSet<NSManagedObject *> * _Nonnull)updatedObjectsOfType:(SWIFT_METATYPE(NSManagedObject) _Nonnull)entity SWIFT_WARN_UNUSED_RESULT;
/// Returns all pending <code>NSManagedObjectID</code>s that were updated in the transaction. This method should not be called after the <code>-commit*:</code> method was called.
///
/// returns:
/// an <code>NSSet</code> of pending <code>NSManagedObjectID</code>s that were updated in the transaction.
- (NSSet<NSManagedObjectID *> * _Nonnull)updatedObjectIDs SWIFT_WARN_UNUSED_RESULT;
/// Returns all pending <code>NSManagedObjectID</code>s of the specified type that were updated in the transaction. This method should not be called after the <code>-commit*:</code> method was called.
/// \param entity the <code>NSManagedObject</code> subclass to filter
///
///
/// returns:
/// an <code>NSSet</code> of pending <code>NSManagedObjectID</code>s of the specified type that were updated in the transaction.
- (NSSet<NSManagedObjectID *> * _Nonnull)updatedObjectIDsOfType:(SWIFT_METATYPE(NSManagedObject) _Nonnull)entity SWIFT_WARN_UNUSED_RESULT;
/// Returns all pending <code>NSManagedObject</code>s of the specified type that were deleted from the transaction. This method should not be called after the <code>-commit*:</code> method was called.
/// \param entity the <code>NSManagedObject</code> subclass to filter
///
///
/// returns:
/// an <code>NSSet</code> of pending <code>NSManagedObject</code>s of the specified type that were deleted from the transaction.
- (NSSet<NSManagedObject *> * _Nonnull)deletedObjectsOfType:(SWIFT_METATYPE(NSManagedObject) _Nonnull)entity SWIFT_WARN_UNUSED_RESULT;
/// Returns all pending <code>NSManagedObjectID</code>s of the specified type that were deleted from the transaction. This method should not be called after the <code>-commit*:</code> method was called.
///
/// returns:
/// an <code>NSSet</code> of pending <code>NSManagedObjectID</code>s of the specified type that were deleted from the transaction.
- (NSSet<NSManagedObjectID *> * _Nonnull)deletedObjectIDs SWIFT_WARN_UNUSED_RESULT;
/// Returns all pending <code>NSManagedObjectID</code>s of the specified type that were deleted from the transaction. This method should not be called after the <code>-commit*:</code> method was called.
/// \param entity the <code>NSManagedObject</code> subclass to filter
///
///
/// returns:
/// a <code>Set</code> of pending <code>NSManagedObjectID</code>s of the specified type that were deleted from the transaction.
- (NSSet<NSManagedObjectID *> * _Nonnull)deletedObjectIDsOfType:(SWIFT_METATYPE(NSManagedObject) _Nonnull)entity SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class CSError;

/// The <code>CSAsynchronousDataTransaction</code> serves as the Objective-C bridging type for <code>AsynchronousDataTransaction</code>.
/// seealso:
/// <code>AsynchronousDataTransaction</code>
SWIFT_CLASS("_TtC9CoreStore29CSAsynchronousDataTransaction") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSAsynchronousDataTransaction : CSBaseDataTransaction
/// Saves the transaction changes. This method should not be used after the <code>-commitWithCompletion:</code> method was already called once.
/// \param success the block executed if the save succeeds.
///
/// \param failure the block executed if the save fails. A <code>CSError</code> is reported as the argument of the block.
///
- (void)commitWithSuccess:(void (^ _Nullable)(void))success failure:(void (^ _Nullable)(CSError * _Nonnull))failure;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
/// Creates a new <code>NSManagedObject</code> with the specified entity type.
/// \param into the <code>CSInto</code> clause indicating the destination <code>NSManagedObject</code> entity type and the destination configuration
///
///
/// returns:
/// a new <code>NSManagedObject</code> instance of the specified entity type.
- (id _Nonnull)createInto:(CSInto * _Nonnull)into SWIFT_WARN_UNUSED_RESULT;
/// Returns an editable proxy of a specified <code>NSManagedObject</code>. This method should not be used after the <code>-commitWithCompletion:</code> method was already called once.
/// \param object the <code>NSManagedObject</code> type to be edited
///
///
/// returns:
/// an editable proxy for the specified <code>NSManagedObject</code>.
- (id _Nullable)editObject:(NSManagedObject * _Nullable)object SWIFT_WARN_UNUSED_RESULT;
/// Returns an editable proxy of the object with the specified <code>NSManagedObjectID</code>. This method should not be used after the <code>-commitWithCompletion:</code> method was already called once.
/// \param into a <code>CSInto</code> clause specifying the entity type
///
/// \param objectID the <code>NSManagedObjectID</code> for the object to be edited
///
///
/// returns:
/// an editable proxy for the specified <code>NSManagedObject</code>.
- (id _Nullable)editInto:(CSInto * _Nonnull)into objectID:(NSManagedObjectID * _Nonnull)objectID SWIFT_WARN_UNUSED_RESULT;
/// Deletes a specified <code>NSManagedObject</code>. This method should not be used after the <code>-commitWithCompletion:</code> method was already called once.
/// \param object the <code>NSManagedObject</code> type to be deleted
///
- (void)deleteObject:(NSManagedObject * _Nullable)object;
/// Deletes the specified <code>NSManagedObject</code>s.
/// \param objects the <code>NSManagedObject</code>s type to be deleted
///
- (void)deleteObjects:(NSArray<NSManagedObject *> * _Nonnull)objects;
@end


@class CSFrom;
@protocol CSFetchClause;
@class NSNumber;
@class CSSelect;
@protocol CSQueryClause;

@interface CSBaseDataTransaction (SWIFT_EXTENSION(CoreStore))
/// Fetches the <code>NSManagedObject</code> instance in the transaction’s context from a reference created from a transaction or from a different managed object context.
/// \param object a reference to the object created/fetched outside the transaction
///
///
/// returns:
/// the <code>NSManagedObject</code> instance if the object exists in the transaction, or <code>nil</code> if not found.
- (id _Nullable)fetchExistingObject:(NSManagedObject * _Nonnull)object SWIFT_WARN_UNUSED_RESULT;
/// Fetches the <code>NSManagedObject</code> instance in the transaction’s context from an <code>NSManagedObjectID</code>.
/// \param objectID the <code>NSManagedObjectID</code> for the object
///
///
/// returns:
/// the <code>NSManagedObject</code> instance if the object exists in the transaction, or <code>nil</code> if not found.
- (id _Nullable)fetchExistingObjectWithID:(NSManagedObjectID * _Nonnull)objectID SWIFT_WARN_UNUSED_RESULT;
/// Fetches the <code>NSManagedObject</code> instances in the transaction’s context from references created from a transaction or from a different managed object context.
/// \param objects an array of <code>NSManagedObject</code>s created/fetched outside the transaction
///
///
/// returns:
/// the <code>NSManagedObject</code> array for objects that exists in the transaction
- (NSArray * _Nonnull)fetchExistingObjects:(NSArray<NSManagedObject *> * _Nonnull)objects SWIFT_WARN_UNUSED_RESULT;
/// Fetches the <code>NSManagedObject</code> instances in the transaction’s context from a list of <code>NSManagedObjectID</code>.
/// \param objectIDs the <code>NSManagedObjectID</code> array for the objects
///
///
/// returns:
/// the <code>NSManagedObject</code> array for objects that exists in the transaction
- (NSArray * _Nonnull)fetchExistingObjectsWithIDs:(NSArray<NSManagedObjectID *> * _Nonnull)objectIDs SWIFT_WARN_UNUSED_RESULT;
/// Fetches the first <code>NSManagedObject</code> instance that satisfies the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>From</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the first <code>NSManagedObject</code> instance that satisfies the specified <code>CSFetchClause</code>s
- (id _Nullable)fetchOneFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Fetches all <code>NSManagedObject</code> instances that satisfy the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// all <code>NSManagedObject</code> instances that satisfy the specified <code>CSFetchClause</code>s
- (NSArray * _Nullable)fetchAllFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Fetches the number of <code>NSManagedObject</code>s that satisfy the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the number <code>NSManagedObject</code>s that satisfy the specified <code>CSFetchClause</code>s
- (NSNumber * _Nullable)fetchCountFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Fetches the <code>NSManagedObjectID</code> for the first <code>NSManagedObject</code> that satisfies the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the <code>NSManagedObjectID</code> for the first <code>NSManagedObject</code> that satisfies the specified <code>CSFetchClause</code>s
- (NSManagedObjectID * _Nullable)fetchObjectIDFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Queries aggregate values as specified by the <code>CSQueryClause</code>s. Requires at least a <code>CSSelect</code> clause, and optional <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
/// A “query” differs from a “fetch” in that it only retrieves values already stored in the persistent store. As such, values from unsaved transactions or contexts will not be incorporated in the query result.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param selectClause a <code>CSSelect</code> clause indicating the properties to fetch, and with the generic type indicating the return type.
///
/// \param queryClauses a series of <code>CSQueryClause</code> instances for the query request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the result of the the query. The type of the return value is specified by the generic type of the <code>CSSelect</code> parameter.
- (id _Nullable)queryValueFrom:(CSFrom * _Nonnull)from selectClause:(CSSelect * _Nonnull)selectClause queryClauses:(NSArray<id <CSQueryClause>> * _Nonnull)queryClauses SWIFT_WARN_UNUSED_RESULT;
/// Queries a dictionary of attribute values as specified by the <code>CSQueryClause</code>s. Requires at least a <code>CSSelect</code> clause, and optional <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
/// A “query” differs from a “fetch” in that it only retrieves values already stored in the persistent store. As such, values from unsaved transactions or contexts will not be incorporated in the query result.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param selectClause a <code>CSSelect</code> clause indicating the properties to fetch, and with the generic type indicating the return type.
///
/// \param queryClauses a series of <code>CSQueryClause</code> instances for the query request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the result of the the query. The type of the return value is specified by the generic type of the <code>CSSelect</code> parameter.
- (NSArray<NSDictionary<NSString *, id> *> * _Nullable)queryAttributesFrom:(CSFrom * _Nonnull)from selectClause:(CSSelect * _Nonnull)selectClause queryClauses:(NSArray<id <CSQueryClause>> * _Nonnull)queryClauses SWIFT_WARN_UNUSED_RESULT;
@end

@class CSDataStack;

/// The <code>CSCoreStore</code> serves as the Objective-C bridging type for <code>CoreStore</code>.
/// seealso:
/// <code>CoreStore</code>
SWIFT_CLASS("_TtC9CoreStore11CSCoreStore") SWIFT_DEPRECATED_MSG("Call methods directly from the CSDataStack instead")
@interface CSCoreStore : NSObject
/// The default <code>CSDataStack</code> instance to be used. If <code>defaultStack</code> is not set before the first time accessed, a default-configured <code>CSDataStack</code> will be created.
/// seealso:
/// <code>CSDataStack</code>
/// note:
/// Changing the <code>defaultStack</code> is thread safe, but it is recommended to setup <code>CSDataStacks</code> on a common queue (e.g. the main queue).
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) CSDataStack * _Nonnull defaultStack;)
+ (CSDataStack * _Nonnull)defaultStack SWIFT_WARN_UNUSED_RESULT;
+ (void)setDefaultStack:(CSDataStack * _Nonnull)newValue;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class CSSQLiteStore;
@class CSMigrationResult;
@class NSError;
@class NSProgress;
@class CSMigrationType;

SWIFT_DEPRECATED_MSG("Call methods directly from the CSDataStack instead")
@interface CSCoreStore (SWIFT_EXTENSION(CoreStore))
/// Migrates a <code>CSSQLiteStore</code> to match the <code>defaultStack</code>’s managed object model version. This method does NOT add the migrated store to the data stack.
/// \param storage the <code>CSSQLiteStore</code> instance
///
/// \param completion the closure to be executed on the main queue when the migration completes, either due to success or failure. The closure’s <code>CSMigrationResult</code> argument indicates the result. This closure is NOT executed if an error is thrown, but will be executed with a failure <code>CSSetupResult</code> result if an error occurs asynchronously.
///
/// \param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// an <code>NSProgress</code> instance if a migration has started. <code>nil</code> if no migrations are required or if <code>error</code> was set.
+ (NSProgress * _Nullable)upgradeStorageIfNeeded:(CSSQLiteStore * _Nonnull)storage completion:(void (^ _Nonnull)(CSMigrationResult * _Nonnull))completion error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
/// Checks the migration steps required for the <code>CSSQLiteStore</code> to match the <code>defaultStack</code>’s managed object model version.
/// \param storage the <code>CSSQLiteStore</code> instance
///
/// \param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// a <code>CSMigrationType</code> array indicating the migration steps required for the store, or an empty array if the file does not exist yet. Otherwise, <code>nil</code> is returned and the <code>error</code> argument is set if either inspection of the store failed, or if no mapping model was found/inferred.
+ (NSArray<CSMigrationType *> * _Nullable)requiredMigrationsForSQLiteStore:(CSSQLiteStore * _Nonnull)storage error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
@end

@class CSObjectMonitor;
@class CSListMonitor;
@class CSSectionBy;

SWIFT_AVAILABILITY(macos,introduced=10.12) SWIFT_DEPRECATED_MSG("Call methods directly from the CSDataStack instead")
@interface CSCoreStore (SWIFT_EXTENSION(CoreStore))
/// Using the <code>defaultStack</code>, creates an <code>CSObjectMonitor</code> for the specified <code>NSManagedObject</code>. Multiple <code>CSObjectObserver</code>s may then register themselves to be notified when changes are made to the <code>NSManagedObject</code>.
/// \param object the <code>NSManagedObject</code> to observe changes from
///
///
/// returns:
/// a <code>CSObjectMonitor</code> that monitors changes to <code>object</code>
+ (CSObjectMonitor * _Nonnull)monitorObject:(NSManagedObject * _Nonnull)object SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, creates a <code>CSListMonitor</code> for a list of <code>NSManagedObject</code>s that satisfy the specified fetch clauses. Multiple <code>CSListObserver</code>s may then register themselves to be notified when changes are made to the list.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for fetching the object list. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// a <code>CSListMonitor</code> instance that monitors changes to the list
+ (CSListMonitor * _Nonnull)monitorListFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, asynchronously creates a <code>CSListMonitor</code> for a list of <code>NSManagedObject</code>s that satisfy the specified fetch clauses. Multiple <code>CSListObserver</code>s may then register themselves to be notified when changes are made to the list. Since <code>NSFetchedResultsController</code> greedily locks the persistent store on initial fetch, you may prefer this method instead of the synchronous counterpart to avoid deadlocks while background updates/saves are being executed.
/// \param createAsynchronously the closure that receives the created <code>CSListMonitor</code> instance
///
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for fetching the object list. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
+ (void)monitorListByCreatingAsynchronously:(void (^ _Nonnull)(CSListMonitor * _Nonnull))createAsynchronously from:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses;
/// Using the <code>defaultStack</code>, creates a <code>CSListMonitor</code> for a sectioned list of <code>NSManagedObject</code>s that satisfy the specified fetch clauses. Multiple <code>CSListObserver</code>s may then register themselves to be notified when changes are made to the list.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param sectionBy a <code>CSSectionBy</code> clause indicating the keyPath for the attribute to use when sorting the list into sections.
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for fetching the object list. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// a <code>CSListMonitor</code> instance that monitors changes to the list
+ (CSListMonitor * _Nonnull)monitorSectionedListFrom:(CSFrom * _Nonnull)from sectionBy:(CSSectionBy * _Nonnull)sectionBy fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, asynchronously creates a <code>CSListMonitor</code> for a sectioned list of <code>NSManagedObject</code>s that satisfy the specified fetch clauses. Multiple <code>CSListObserver</code>s may then register themselves to be notified when changes are made to the list. Since <code>NSFetchedResultsController</code> greedily locks the persistent store on initial fetch, you may prefer this method instead of the synchronous counterpart to avoid deadlocks while background updates/saves are being executed.
/// \param createAsynchronously the closure that receives the created <code>CSListMonitor</code> instance
///
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param sectionBy a <code>CSSectionBy</code> clause indicating the keyPath for the attribute to use when sorting the list into sections.
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for fetching the object list. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
+ (void)monitorSectionedListByCreatingAsynchronously:(void (^ _Nonnull)(CSListMonitor * _Nonnull))createAsynchronously from:(CSFrom * _Nonnull)from sectionBy:(CSSectionBy * _Nonnull)sectionBy fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses;
@end

@class CSSynchronousDataTransaction;
@class CSUnsafeDataTransaction;

SWIFT_DEPRECATED_MSG("Call methods directly from the CSDataStack instead")
@interface CSCoreStore (SWIFT_EXTENSION(CoreStore))
/// Using the <code>defaultStack</code>, begins a transaction asynchronously where <code>NSManagedObject</code> creates, updates, and deletes can be made.
/// \param closure the block where creates, updates, and deletes can be made to the transaction. Transaction blocks are executed serially in a background queue, and all changes are made from a concurrent <code>NSManagedObjectContext</code>.
///
+ (void)beginAsynchronous:(void (^ _Nonnull)(CSAsynchronousDataTransaction * _Nonnull))closure;
/// Using the <code>defaultStack</code>, begins a transaction synchronously where <code>NSManagedObject</code> creates, updates, and deletes can be made.
/// \param closure the block where creates, updates, and deletes can be made to the transaction. Transaction blocks are executed serially in a background queue, and all changes are made from a concurrent <code>NSManagedObjectContext</code>.
///
///
/// returns:
/// <code>YES</code> if the commit succeeded, <code>NO</code> if the commit failed. If <code>NO</code>, the <code>error</code> argument will hold error information.
+ (BOOL)beginSynchronous:(void (^ _Nonnull)(CSSynchronousDataTransaction * _Nonnull))closure error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, begins a child transaction where <code>NSManagedObject</code> creates, updates, and deletes can be made. This is useful for making temporary changes, such as partially filled forms.
/// To support “undo” methods such as <code>-undo</code>, <code>-redo</code>, and <code>-rollback</code>, use the <code>-beginSafeWithSupportsUndo:</code> method passing <code>YES</code> to the argument. Without “undo” support, calling those methods will raise an exception.
///
/// returns:
/// a <code>CSUnsafeDataTransaction</code> instance where creates, updates, and deletes can be made.
+ (CSUnsafeDataTransaction * _Nonnull)beginUnsafe SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, begins a child transaction where <code>NSManagedObject</code> creates, updates, and deletes can be made. This is useful for making temporary changes, such as partially filled forms.
/// <ul>
///   <li>
///     prameter supportsUndo: <code>-undo</code>, <code>-redo</code>, and <code>-rollback</code> methods are only available when this parameter is <code>YES</code>, otherwise those method will raise an exception. Note that turning on Undo support may heavily impact performance especially on iOS or watchOS where memory is limited.
///   </li>
/// </ul>
///
/// returns:
/// a <code>CSUnsafeDataTransaction</code> instance where creates, updates, and deletes can be made.
+ (CSUnsafeDataTransaction * _Nonnull)beginUnsafeWithSupportsUndo:(BOOL)supportsUndo SWIFT_WARN_UNUSED_RESULT;
/// Refreshes all registered objects <code>NSManagedObject</code>s in the <code>defaultStack</code>.
+ (void)refreshAndMergeAllObjects;
@end

@class NSEntityDescription;
@class CSInMemoryStore;

SWIFT_DEPRECATED_MSG("Call methods directly from the CSDataStack instead")
@interface CSCoreStore (SWIFT_EXTENSION(CoreStore))
/// Returns the <code>defaultStack</code>’s model version. The version string is the same as the name of the version-specific .xcdatamodeld file.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull modelVersion;)
+ (NSString * _Nonnull)modelVersion SWIFT_WARN_UNUSED_RESULT;
/// Returns the entity name-to-class type mapping from the <code>defaultStack</code>’s model.
+ (NSDictionary<NSString *, SWIFT_METATYPE(NSManagedObject)> * _Nonnull)entityTypesByNameForType:(SWIFT_METATYPE(NSManagedObject) _Nonnull)type SWIFT_WARN_UNUSED_RESULT;
/// Returns the <code>NSEntityDescription</code> for the specified <code>NSManagedObject</code> subclass from <code>defaultStack</code>’s model.
+ (NSEntityDescription * _Nullable)entityDescriptionForClass:(SWIFT_METATYPE(NSManagedObject) _Nonnull)type SWIFT_WARN_UNUSED_RESULT;
/// Creates an <code>CSInMemoryStore</code> with default parameters and adds it to the <code>defaultStack</code>. This method blocks until completion.
/// \code
/// CSSQLiteStore *storage = [CSCoreStore addInMemoryStorageAndWaitAndReturnError:&error];
///
/// \endcode\param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// the <code>CSInMemoryStore</code> added to the <code>defaultStack</code>
+ (CSInMemoryStore * _Nullable)addInMemoryStorageAndWaitAndReturnError:(NSError * _Nullable * _Nullable)error;
/// Creates an <code>CSSQLiteStore</code> with default parameters and adds it to the <code>defaultStack</code>. This method blocks until completion.
/// \code
/// CSSQLiteStore *storage = [CSCoreStore addSQLiteStorageAndWaitAndReturnError:&error];
///
/// \endcode\param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// the <code>CSSQLiteStore</code> added to the <code>defaultStack</code>
+ (CSSQLiteStore * _Nullable)addSQLiteStorageAndWaitAndReturnError:(NSError * _Nullable * _Nullable)error;
/// Adds a <code>CSInMemoryStore</code> to the <code>defaultStack</code> and blocks until completion.
/// \code
/// NSError *error;
/// CSInMemoryStore *storage = [CSCoreStore
///     addStorageAndWait: [[CSInMemoryStore alloc] initWithConfiguration: @"Config1"]
///     error: &error];
///
/// \endcode\param storage the <code>CSInMemoryStore</code>
///
/// \param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// the <code>CSInMemoryStore</code> added to the <code>defaultStack</code>
+ (CSInMemoryStore * _Nullable)addInMemoryStorageAndWait:(CSInMemoryStore * _Nonnull)storage error:(NSError * _Nullable * _Nullable)error;
/// Adds a <code>CSSQLiteStore</code> to the <code>defaultStack</code> and blocks until completion.
/// \code
/// NSError *error;
/// CSSQLiteStore *storage = [CSCoreStore
///     addStorageAndWait: [[CSSQLiteStore alloc] initWithConfiguration: @"Config1"]
///     error: &error];
///
/// \endcode\param storage the <code>CSSQLiteStore</code>
///
/// \param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// the <code>CSSQLiteStore</code> added to the <code>defaultStack</code>
+ (CSSQLiteStore * _Nullable)addSQLiteStorageAndWait:(CSSQLiteStore * _Nonnull)storage error:(NSError * _Nullable * _Nullable)error;
@end


SWIFT_DEPRECATED_MSG("Call methods directly from the DataStack instead")
@interface CSCoreStore (SWIFT_EXTENSION(CoreStore))
/// Using the <code>defaultStack</code>, fetches the <code>NSManagedObject</code> instance in the transaction’s context from a reference created from a transaction or from a different managed object context.
/// \param object a reference to the object created/fetched outside the transaction
///
///
/// returns:
/// the <code>NSManagedObject</code> instance if the object exists in the transaction, or <code>nil</code> if not found.
+ (id _Nullable)fetchExistingObject:(NSManagedObject * _Nonnull)object SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, fetches the <code>NSManagedObject</code> instance in the transaction’s context from an <code>NSManagedObjectID</code>.
/// \param objectID the <code>NSManagedObjectID</code> for the object
///
///
/// returns:
/// the <code>NSManagedObject</code> instance if the object exists in the transaction, or <code>nil</code> if not found.
+ (id _Nullable)fetchExistingObjectWithID:(NSManagedObjectID * _Nonnull)objectID SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, fetches the <code>NSManagedObject</code> instances in the transaction’s context from references created from a transaction or from a different managed object context.
/// \param objects an array of <code>NSManagedObject</code>s created/fetched outside the transaction
///
///
/// returns:
/// the <code>NSManagedObject</code> array for objects that exists in the transaction
+ (NSArray * _Nonnull)fetchExistingObjects:(NSArray<NSManagedObject *> * _Nonnull)objects SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, fetches the <code>NSManagedObject</code> instances in the transaction’s context from a list of <code>NSManagedObjectID</code>.
/// \param objectIDs the <code>NSManagedObjectID</code> array for the objects
///
///
/// returns:
/// the <code>NSManagedObject</code> array for objects that exists in the transaction
+ (NSArray * _Nonnull)fetchExistingObjectsWithIDs:(NSArray<NSManagedObjectID *> * _Nonnull)objectIDs SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, fetches the first <code>NSManagedObject</code> instance that satisfies the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>From</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the first <code>NSManagedObject</code> instance that satisfies the specified <code>CSFetchClause</code>s
+ (id _Nullable)fetchOneFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, fetches all <code>NSManagedObject</code> instances that satisfy the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// all <code>NSManagedObject</code> instances that satisfy the specified <code>CSFetchClause</code>s
+ (NSArray * _Nullable)fetchAllFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, fetches the number of <code>NSManagedObject</code>s that satisfy the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the number <code>NSManagedObject</code>s that satisfy the specified <code>CSFetchClause</code>s
+ (NSNumber * _Nullable)fetchCountFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, fetches the <code>NSManagedObjectID</code> for the first <code>NSManagedObject</code> that satisfies the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the <code>NSManagedObjectID</code> for the first <code>NSManagedObject</code> that satisfies the specified <code>CSFetchClause</code>s
+ (NSManagedObjectID * _Nullable)fetchObjectIDFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, fetches the <code>NSManagedObjectID</code> for all <code>NSManagedObject</code>s that satisfy the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>FetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the <code>NSManagedObjectID</code> for all <code>NSManagedObject</code>s that satisfy the specified <code>CSFetchClause</code>s
+ (NSArray<NSManagedObjectID *> * _Nullable)fetchObjectIDsFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, queries aggregate values as specified by the <code>CSQueryClause</code>s. Requires at least a <code>CSSelect</code> clause, and optional <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
/// A “query” differs from a “fetch” in that it only retrieves values already stored in the persistent store. As such, values from unsaved transactions or contexts will not be incorporated in the query result.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param selectClause a <code>CSSelect</code> clause indicating the properties to fetch, and with the generic type indicating the return type.
///
/// \param queryClauses a series of <code>CSQueryClause</code> instances for the query request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the result of the the query. The type of the return value is specified by the generic type of the <code>CSSelect</code> parameter.
+ (id _Nullable)queryValueFrom:(CSFrom * _Nonnull)from selectClause:(CSSelect * _Nonnull)selectClause queryClauses:(NSArray<id <CSQueryClause>> * _Nonnull)queryClauses SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, queries a dictionary of attribute values as specified by the <code>CSQueryClause</code>s. Requires at least a <code>CSSelect</code> clause, and optional <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
/// A “query” differs from a “fetch” in that it only retrieves values already stored in the persistent store. As such, values from unsaved transactions or contexts will not be incorporated in the query result.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param selectClause a <code>CSSelect</code> clause indicating the properties to fetch, and with the generic type indicating the return type.
///
/// \param queryClauses a series of <code>CSQueryClause</code> instances for the query request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the result of the the query. The type of the return value is specified by the generic type of the <code>CSSelect</code> parameter.
+ (NSArray<NSDictionary<NSString *, id> *> * _Nullable)queryAttributesFrom:(CSFrom * _Nonnull)from selectClause:(CSSelect * _Nonnull)selectClause queryClauses:(NSArray<id <CSQueryClause>> * _Nonnull)queryClauses SWIFT_WARN_UNUSED_RESULT;
@end


/// The <code>CSDataStack</code> serves as the Objective-C bridging type for <code>DataStack</code>.
/// seealso:
/// <code>DataStack</code>
SWIFT_CLASS("_TtC9CoreStore11CSDataStack") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSDataStack : NSObject
/// Initializes a <code>CSDataStack</code> with default settings. CoreStore searches for <CFBundleName>.xcdatamodeld from the main <code>NSBundle</code> and loads an <code>NSManagedObjectModel</code> from it. An assertion is raised if the model could not be found.
- (nonnull instancetype)init;
/// Initializes a <code>CSDataStack</code> from the model with the specified <code>modelName</code> in the specified <code>bundle</code>.
/// \param xcodeModelName the name of the (.xcdatamodeld) model file. If not specified, the application name (CFBundleName) will be used if it exists, or “CoreData” if it the bundle name was not set.
///
/// \param bundle an optional bundle to load .xcdatamodeld models from. If not specified, the main bundle will be used.
///
/// \param versionChain the version strings that indicate the sequence of model versions to be used as the order for progressive migrations. If not specified, will default to a non-migrating data stack.
///
- (nonnull instancetype)initWithXcodeModelName:(NSString * _Nullable)xcodeModelName bundle:(NSBundle * _Nullable)bundle versionChain:(NSArray<NSString *> * _Nullable)versionChain;
/// Returns the stack’s model version. The version string is the same as the name of the version-specific .xcdatamodeld file.
@property (nonatomic, readonly, copy) NSString * _Nonnull modelVersion;
/// Returns the entity name-to-class type mapping from the <code>CSDataStack</code>’s model.
- (NSDictionary<NSString *, SWIFT_METATYPE(NSManagedObject)> * _Nonnull)entityTypesByNameForType:(SWIFT_METATYPE(NSManagedObject) _Nonnull)type SWIFT_WARN_UNUSED_RESULT;
/// Returns the <code>NSEntityDescription</code> for the specified <code>NSManagedObject</code> subclass from stack’s model.
- (NSEntityDescription * _Nullable)entityDescriptionForClass:(SWIFT_METATYPE(NSManagedObject) _Nonnull)type SWIFT_WARN_UNUSED_RESULT;
/// Creates an <code>CSInMemoryStore</code> with default parameters and adds it to the stack. This method blocks until completion.
/// \code
/// CSSQLiteStore *storage = [dataStack addInMemoryStorageAndWaitAndReturnError:&error];
///
/// \endcode\param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// the <code>CSInMemoryStore</code> added to the stack
- (CSInMemoryStore * _Nullable)addInMemoryStorageAndWaitAndReturnError:(NSError * _Nullable * _Nullable)error;
/// Creates an <code>CSSQLiteStore</code> with default parameters and adds it to the stack. This method blocks until completion.
/// \code
/// CSSQLiteStore *storage = [dataStack addSQLiteStorageAndWaitAndReturnError:&error];
///
/// \endcode\param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// the <code>CSSQLiteStore</code> added to the stack
- (CSSQLiteStore * _Nullable)addSQLiteStorageAndWaitAndReturnError:(NSError * _Nullable * _Nullable)error;
/// Adds a <code>CSInMemoryStore</code> to the stack and blocks until completion.
/// \code
/// NSError *error;
/// CSInMemoryStore *storage = [dataStack
///     addStorageAndWait: [[CSInMemoryStore alloc] initWithConfiguration: @"Config1"]
///     error: &error];
///
/// \endcode\param storage the <code>CSInMemoryStore</code>
///
/// \param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// the <code>CSInMemoryStore</code> added to the stack
- (CSInMemoryStore * _Nullable)addInMemoryStorageAndWait:(CSInMemoryStore * _Nonnull)storage error:(NSError * _Nullable * _Nullable)error;
/// Adds a <code>CSSQLiteStore</code> to the stack and blocks until completion.
/// \code
/// NSError *error;
/// CSSQLiteStore *storage = [dataStack
///     addStorageAndWait: [[CSSQLiteStore alloc] initWithConfiguration: @"Config1"]
///     error: &error];
///
/// \endcode\param storage the <code>CSSQLiteStore</code>
///
/// \param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// the <code>CSSQLiteStore</code> added to the stack
- (CSSQLiteStore * _Nullable)addSQLiteStorageAndWait:(CSSQLiteStore * _Nonnull)storage error:(NSError * _Nullable * _Nullable)error;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
@end

@class CSSetupResult;

SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSDataStack (SWIFT_EXTENSION(CoreStore))
/// Asynchronously adds a <code>CSInMemoryStore</code> to the stack. Migrations are also initiated by default.
/// \code
/// NSError *error;
/// NSProgress *migrationProgress = [dataStack 
///     addInMemoryStorage:[CSInMemoryStore new]
///     completion:^(CSSetupResult *result) {
///         if (result.isSuccess) {
///             // ...
///         }
///     }
///     error: &error];
///
/// \endcode\param storage the <code>CSInMemoryStore</code> instance
///
/// \param completion the closure to be executed on the main queue when the process completes, either due to success or failure. The closure’s <code>CSSetupResult</code> argument indicates the result. This closure is NOT executed if an error is thrown, but will be executed with a failure <code>CSSetupResult</code> result if an error occurs asynchronously.
///
- (void)addInMemoryStorage:(CSInMemoryStore * _Nonnull)storage completion:(void (^ _Nonnull)(CSSetupResult * _Nonnull))completion;
/// Asynchronously adds a <code>CSSQLiteStore</code> to the stack. Migrations are also initiated by default.
/// \code
/// NSError *error;
/// NSProgress *migrationProgress = [dataStack
///     addInMemoryStorage:[[CSSQLiteStore alloc] 
///         initWithFileName:@"core_data.sqlite"
///         configuration:@"Config1"]
///     completion:^(CSSetupResult *result) {
///         if (result.isSuccess) {
///             // ...
///         }
///     }
///     error: &error];
///
/// \endcode\param storage the <code>CSSQLiteStore</code> instance
///
/// \param completion the closure to be executed on the main queue when the process completes, either due to success or failure. The closure’s <code>CSSetupResult</code> argument indicates the result. This closure is NOT executed if an error is thrown, but will be executed with a failure <code>CSSetupResult</code> result if an error occurs asynchronously. Note that the <code>CSLocalStorage</code> associated to the <code>-[CSSetupResult storage]</code> may not always be the same instance as the parameter argument if a previous <code>CSLocalStorage</code> was already added at the same URL and with the same configuration.
///
/// \param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// an <code>NSProgress</code> instance if a migration has started. <code>nil</code> if no migrations are required or if <code>error</code> was set.
- (NSProgress * _Nullable)addSQLiteStorage:(CSSQLiteStore * _Nonnull)storage completion:(void (^ _Nonnull)(CSSetupResult * _Nonnull))completion error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
/// Migrates a <code>CSSQLiteStore</code> to match the <code>CSDataStack</code>’s managed object model version. This method does NOT add the migrated store to the data stack.
/// \param storage the <code>CSSQLiteStore</code> instance
///
/// \param completion the closure to be executed on the main queue when the migration completes, either due to success or failure. The closure’s <code>CSMigrationResult</code> argument indicates the result. This closure is NOT executed if an error is thrown, but will be executed with a failure <code>CSSetupResult</code> result if an error occurs asynchronously.
///
/// \param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// an <code>NSProgress</code> instance if a migration has started. <code>nil</code> if no migrations are required or if <code>error</code> was set.
- (NSProgress * _Nullable)upgradeStorageIfNeeded:(CSSQLiteStore * _Nonnull)storage completion:(void (^ _Nonnull)(CSMigrationResult * _Nonnull))completion error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
/// Checks the migration steps required for the <code>CSSQLiteStore</code> to match the <code>CSDataStack</code>’s managed object model version.
/// \param storage the <code>CSSQLiteStore</code> instance
///
/// \param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// a <code>CSMigrationType</code> array indicating the migration steps required for the store, or an empty array if the file does not exist yet. Otherwise, <code>nil</code> is returned and the <code>error</code> argument is set if either inspection of the store failed, or if no mapping model was found/inferred.
- (NSArray<CSMigrationType *> * _Nullable)requiredMigrationsForSQLiteStore:(CSSQLiteStore * _Nonnull)storage error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
@end


SWIFT_AVAILABILITY(macos,introduced=10.12) SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSDataStack (SWIFT_EXTENSION(CoreStore))
/// Creates a <code>CSObjectMonitor</code> for the specified <code>NSManagedObject</code>. Multiple <code>ObjectObserver</code>s may then register themselves to be notified when changes are made to the <code>NSManagedObject</code>.
/// \param object the <code>NSManagedObject</code> to observe changes from
///
///
/// returns:
/// an <code>ObjectMonitor</code> that monitors changes to <code>object</code>
- (CSObjectMonitor * _Nonnull)monitorObject:(NSManagedObject * _Nonnull)object SWIFT_WARN_UNUSED_RESULT;
/// Creates a <code>CSListMonitor</code> for a list of <code>NSManagedObject</code>s that satisfy the specified fetch clauses. Multiple <code>CSListObserver</code>s may then register themselves to be notified when changes are made to the list.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>FetchClause</code> instances for fetching the object list. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// a <code>CSListMonitor</code> instance that monitors changes to the list
- (CSListMonitor * _Nonnull)monitorListFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Asynchronously creates a <code>CSListMonitor</code> for a list of <code>NSManagedObject</code>s that satisfy the specified fetch clauses. Multiple <code>CSListObserver</code>s may then register themselves to be notified when changes are made to the list. Since <code>NSFetchedResultsController</code> greedily locks the persistent store on initial fetch, you may prefer this method instead of the synchronous counterpart to avoid deadlocks while background updates/saves are being executed.
/// \param createAsynchronously the closure that receives the created <code>CSListMonitor</code> instance
///
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for fetching the object list. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
- (void)monitorListByCreatingAsynchronously:(void (^ _Nonnull)(CSListMonitor * _Nonnull))createAsynchronously from:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses;
/// Creates a <code>CSListMonitor</code> for a sectioned list of <code>NSManagedObject</code>s that satisfy the specified fetch clauses. Multiple <code>ListObserver</code>s may then register themselves to be notified when changes are made to the list.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param sectionBy a <code>CSSectionBy</code> clause indicating the keyPath for the attribute to use when sorting the list into sections.
///
/// \param fetchClauses a series of <code>FetchClause</code> instances for fetching the object list. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// a <code>CSListMonitor</code> instance that monitors changes to the list
- (CSListMonitor * _Nonnull)monitorSectionedListFrom:(CSFrom * _Nonnull)from sectionBy:(CSSectionBy * _Nonnull)sectionBy fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
@end


SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSDataStack (SWIFT_EXTENSION(CoreStore))
/// Begins a transaction asynchronously where <code>NSManagedObject</code> creates, updates, and deletes can be made.
/// \param closure the block where creates, updates, and deletes can be made to the transaction. Transaction blocks are executed serially in a background queue, and all changes are made from a concurrent <code>NSManagedObjectContext</code>.
///
- (void)beginAsynchronous:(void (^ _Nonnull)(CSAsynchronousDataTransaction * _Nonnull))closure;
/// Begins a transaction synchronously where <code>NSManagedObject</code> creates, updates, and deletes can be made.
/// \param closure the block where creates, updates, and deletes can be made to the transaction. Transaction blocks are executed serially in a background queue, and all changes are made from a concurrent <code>NSManagedObjectContext</code>.
///
/// \param error the <code>CSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// <code>YES</code> if the commit succeeded, <code>NO</code> if the commit failed. If <code>NO</code>, the <code>error</code> argument will hold error information.
- (BOOL)beginSynchronous:(void (^ _Nonnull)(CSSynchronousDataTransaction * _Nonnull))closure error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
/// Begins a child transaction where <code>NSManagedObject</code> creates, updates, and deletes can be made. This is useful for making temporary changes, such as partially filled forms.
/// To support “undo” methods such as <code>-undo</code>, <code>-redo</code>, and <code>-rollback</code>, use the <code>-beginSafeWithSupportsUndo:</code> method passing <code>YES</code> to the argument. Without “undo” support, calling those methods will raise an exception.
///
/// returns:
/// a <code>CSUnsafeDataTransaction</code> instance where creates, updates, and deletes can be made.
- (CSUnsafeDataTransaction * _Nonnull)beginUnsafe SWIFT_WARN_UNUSED_RESULT;
/// Begins a child transaction where <code>NSManagedObject</code> creates, updates, and deletes can be made. This is useful for making temporary changes, such as partially filled forms.
/// <ul>
///   <li>
///     prameter supportsUndo: <code>-undo</code>, <code>-redo</code>, and <code>-rollback</code> methods are only available when this parameter is <code>YES</code>, otherwise those method will raise an exception. Note that turning on Undo support may heavily impact performance especially on iOS or watchOS where memory is limited.
///   </li>
/// </ul>
///
/// returns:
/// a <code>CSUnsafeDataTransaction</code> instance where creates, updates, and deletes can be made.
- (CSUnsafeDataTransaction * _Nonnull)beginUnsafeWithSupportsUndo:(BOOL)supportsUndo SWIFT_WARN_UNUSED_RESULT;
/// Refreshes all registered objects <code>NSManagedObject</code>s in the <code>DataStack</code>.
- (void)refreshAndMergeAllObjects;
@end


SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSDataStack (SWIFT_EXTENSION(CoreStore))
/// Fetches the <code>NSManagedObject</code> instance in the transaction’s context from a reference created from a transaction or from a different managed object context.
/// \param object a reference to the object created/fetched outside the transaction
///
///
/// returns:
/// the <code>NSManagedObject</code> instance if the object exists in the transaction, or <code>nil</code> if not found.
- (id _Nullable)fetchExistingObject:(NSManagedObject * _Nonnull)object SWIFT_WARN_UNUSED_RESULT;
/// Fetches the <code>NSManagedObject</code> instance in the transaction’s context from an <code>NSManagedObjectID</code>.
/// \param objectID the <code>NSManagedObjectID</code> for the object
///
///
/// returns:
/// the <code>NSManagedObject</code> instance if the object exists in the transaction, or <code>nil</code> if not found.
- (id _Nullable)fetchExistingObjectWithID:(NSManagedObjectID * _Nonnull)objectID SWIFT_WARN_UNUSED_RESULT;
/// Fetches the <code>NSManagedObject</code> instances in the transaction’s context from references created from a transaction or from a different managed object context.
/// \param objects an array of <code>NSManagedObject</code>s created/fetched outside the transaction
///
///
/// returns:
/// the <code>NSManagedObject</code> array for objects that exists in the transaction
- (NSArray * _Nonnull)fetchExistingObjects:(NSArray<NSManagedObject *> * _Nonnull)objects SWIFT_WARN_UNUSED_RESULT;
/// Fetches the <code>NSManagedObject</code> instances in the transaction’s context from a list of <code>NSManagedObjectID</code>.
/// \param objectIDs the <code>NSManagedObjectID</code> array for the objects
///
///
/// returns:
/// the <code>NSManagedObject</code> array for objects that exists in the transaction
- (NSArray * _Nonnull)fetchExistingObjectsWithIDs:(NSArray<NSManagedObjectID *> * _Nonnull)objectIDs SWIFT_WARN_UNUSED_RESULT;
/// Fetches the first <code>NSManagedObject</code> instance that satisfies the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>From</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the first <code>NSManagedObject</code> instance that satisfies the specified <code>CSFetchClause</code>s
- (id _Nullable)fetchOneFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Fetches all <code>NSManagedObject</code> instances that satisfy the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// all <code>NSManagedObject</code> instances that satisfy the specified <code>CSFetchClause</code>s
- (NSArray * _Nullable)fetchAllFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Fetches the number of <code>NSManagedObject</code>s that satisfy the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the number <code>NSManagedObject</code>s that satisfy the specified <code>CSFetchClause</code>s
- (NSNumber * _Nullable)fetchCountFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Fetches the <code>NSManagedObjectID</code> for the first <code>NSManagedObject</code> that satisfies the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the <code>NSManagedObjectID</code> for the first <code>NSManagedObject</code> that satisfies the specified <code>CSFetchClause</code>s
- (NSManagedObjectID * _Nullable)fetchObjectIDFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Fetches the <code>NSManagedObjectID</code> for all <code>NSManagedObject</code>s that satisfy the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>FetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the <code>NSManagedObjectID</code> for all <code>NSManagedObject</code>s that satisfy the specified <code>CSFetchClause</code>s
- (NSArray<NSManagedObjectID *> * _Nullable)fetchObjectIDsFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Queries aggregate values as specified by the <code>CSQueryClause</code>s. Requires at least a <code>CSSelect</code> clause, and optional <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
/// A “query” differs from a “fetch” in that it only retrieves values already stored in the persistent store. As such, values from unsaved transactions or contexts will not be incorporated in the query result.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param selectClause a <code>CSSelect</code> clause indicating the properties to fetch, and with the generic type indicating the return type.
///
/// \param queryClauses a series of <code>CSQueryClause</code> instances for the query request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the result of the the query. The type of the return value is specified by the generic type of the <code>CSSelect</code> parameter.
- (id _Nullable)queryValueFrom:(CSFrom * _Nonnull)from selectClause:(CSSelect * _Nonnull)selectClause queryClauses:(NSArray<id <CSQueryClause>> * _Nonnull)queryClauses SWIFT_WARN_UNUSED_RESULT;
/// Queries a dictionary of attribute values as specified by the <code>CSQueryClause</code>s. Requires at least a <code>CSSelect</code> clause, and optional <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
/// A “query” differs from a “fetch” in that it only retrieves values already stored in the persistent store. As such, values from unsaved transactions or contexts will not be incorporated in the query result.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param selectClause a <code>CSSelect</code> clause indicating the properties to fetch, and with the generic type indicating the return type.
///
/// \param queryClauses a series of <code>CSQueryClause</code> instances for the query request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the result of the the query. The type of the return value is specified by the generic type of the <code>CSSelect</code> parameter.
- (NSArray<NSDictionary<NSString *, id> *> * _Nullable)queryAttributesFrom:(CSFrom * _Nonnull)from selectClause:(CSSelect * _Nonnull)selectClause queryClauses:(NSArray<id <CSQueryClause>> * _Nonnull)queryClauses SWIFT_WARN_UNUSED_RESULT;
@end


/// The <code>CSDeleteClause</code> implement clauses used to configure <code>NSFetchRequest</code>s.
/// seealso:
/// <code>DeleteClause</code>
SWIFT_PROTOCOL("_TtP9CoreStore14CSDeleteClause_")
@protocol CSDeleteClause
- (void)applyToFetchRequest:(NSFetchRequest<id <NSFetchRequestResult>> * _Nonnull)fetchRequest;
@end

@class NSManagedObjectModel;

/// The <code>CSDynamicSchema</code> serves as the Objective-C bridging type for <code>DynamicSchema</code>.
/// seealso:
/// <code>DynamicSchema</code>
SWIFT_PROTOCOL("_TtP9CoreStore15CSDynamicSchema_")
@protocol CSDynamicSchema
/// The version string for this model schema.
@property (nonatomic, readonly, copy) NSString * _Nonnull modelVersion;
/// Do not call this directly. The <code>NSManagedObjectModel</code> for this schema may be created lazily and using this method directly may affect the integrity of the model.
- (NSManagedObjectModel * _Nonnull)rawModel SWIFT_WARN_UNUSED_RESULT;
@end

@class NSCoder;

/// All errors thrown from CoreStore are expressed in <code>CSError</code>s.
/// seealso:
/// <code>CoreStoreError</code>
SWIFT_CLASS("_TtC9CoreStore7CSError")
@interface CSError : NSError
/// The <code>NSError</code> error domain for <code>CSError</code>.
/// seealso:
/// <code>CoreStoreErrorErrorDomain</code>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull errorDomain;)
+ (NSString * _Nonnull)errorDomain SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithDomain:(NSString * _Nonnull)domain code:(NSInteger)code userInfo:(NSDictionary<NSString *, id> * _Nullable)dict SWIFT_UNAVAILABLE;
@end



/// The <code>NSError</code> error codes for <code>CSError.Domain</code>.
/// seealso:
/// <code>CSError</code>
/// seealso:
/// <code>CoreStoreError</code>
typedef SWIFT_ENUM(NSInteger, CSErrorCode, closed) {
/// A failure occured because of an unknown error.
  CSErrorCodeUnknownError = 0,
/// The <code>NSPersistentStore</code> could note be initialized because another store existed at the specified <code>NSURL</code>.
  CSErrorCodeDifferentStorageExistsAtURL = 1,
/// An <code>NSMappingModel</code> could not be found for a specific source and destination model versions.
  CSErrorCodeMappingModelNotFound = 2,
/// Progressive migrations are disabled for a store, but an <code>NSMappingModel</code> could not be found for a specific source and destination model versions.
  CSErrorCodeProgressiveMigrationRequired = 3,
/// An internal SDK call failed with the specified “NSError” userInfo key.
  CSErrorCodeInternalError = 4,
/// The transaction was terminated by a user-thrown error with the specified “Error” userInfo key.
  CSErrorCodeUserError = 5,
/// The transaction was cancelled by the user.
  CSErrorCodeUserCancelled = 6,
};


/// The <code>CSFetchClause</code> implement clauses used to configure <code>NSFetchRequest</code>s.
/// seealso:
/// <code>FetchClause</code>
SWIFT_PROTOCOL("_TtP9CoreStore13CSFetchClause_")
@protocol CSFetchClause
- (void)applyToFetchRequest:(NSFetchRequest<id <NSFetchRequestResult>> * _Nonnull)fetchRequest;
@end


/// The <code>CSFrom</code> serves as the Objective-C bridging type for <code>From</code>.
/// seealso:
/// <code>From</code>
SWIFT_CLASS("_TtC9CoreStore6CSFrom")
@interface CSFrom : NSObject
/// The associated <code>NSManagedObject</code> entity class
@property (nonatomic, readonly) Class _Nonnull entityClass;
/// The <code>NSPersistentStore</code> configuration names to associate objects from.
/// May contain <code>NSString</code> instances to pertain to named configurations, or <code>NSNull</code> to pertain to the default configuration
@property (nonatomic, readonly, copy) NSArray * _Nullable configurations;
/// Initializes a <code>CSFrom</code> clause with the specified entity class.
/// \code
/// MyPersonEntity *people = [transaction fetchAllFrom:CSFromClass([MyPersonEntity class])];
///
/// \endcode\param entityClass the <code>NSManagedObject</code> class type to be created
///
- (nonnull instancetype)initWithEntityClass:(SWIFT_METATYPE(NSManagedObject) _Nonnull)entityClass;
/// Initializes a <code>CSFrom</code> clause with the specified configurations.
/// \code
/// MyPersonEntity *people = [transaction fetchAllFrom:
///    CSFromClass([MyPersonEntity class], @"Config1")];
///
/// \endcode\param entityClass the associated <code>NSManagedObject</code> entity class
///
/// \param configuration the <code>NSPersistentStore</code> configuration name to associate objects from. This parameter is required if multiple configurations contain the created <code>NSManagedObject</code>’s entity type. Set to <code>[NSNull null]</code> to use the default configuration.
///
- (nonnull instancetype)initWithEntityClass:(SWIFT_METATYPE(NSManagedObject) _Nonnull)entityClass configuration:(id _Nonnull)configuration;
/// Initializes a <code>CSFrom</code> clause with the specified configurations.
/// \code
/// MyPersonEntity *people = [transaction fetchAllFrom:
///    CSFromClass([MyPersonEntity class],
///                 @[[NSNull null], @"Config1"])];
///
/// \endcode\param entityClass the associated <code>NSManagedObject</code> entity class
///
/// \param configurations an array of the <code>NSPersistentStore</code> configuration names to associate objects from. This parameter is required if multiple configurations contain the created <code>NSManagedObject</code>’s entity type. Set to <code>[NSNull null]</code> to use the default configuration.
///
- (nonnull instancetype)initWithEntityClass:(SWIFT_METATYPE(NSManagedObject) _Nonnull)entityClass configurations:(NSArray * _Nonnull)configurations;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The <code>CSQueryClause</code> implement clauses used to configure <code>NSFetchRequest</code>s.
/// seealso:
/// <code>QueryClause</code>
SWIFT_PROTOCOL("_TtP9CoreStore13CSQueryClause_")
@protocol CSQueryClause
- (void)applyToFetchRequest:(NSFetchRequest<id <NSFetchRequestResult>> * _Nonnull)fetchRequest;
@end


/// The <code>CSGroupBy</code> serves as the Objective-C bridging type for <code>GroupBy</code>.
/// seealso:
/// <code>GroupBy</code>
SWIFT_CLASS("_TtC9CoreStore9CSGroupBy")
@interface CSGroupBy : NSObject <CSQueryClause>
/// The list of key path strings to group results with
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nonnull keyPaths;
/// Initializes a <code>CSGroupBy</code> clause with a key path string
/// \param keyPath a key path string to group results with
///
- (nonnull instancetype)initWithKeyPath:(NSString * _Nonnull)keyPath;
/// Initializes a <code>CSGroupBy</code> clause with a list of key path strings
/// \param keyPaths a list of key path strings to group results with
///
- (nonnull instancetype)initWithKeyPaths:(NSArray<NSString *> * _Nonnull)keyPaths;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (void)applyToFetchRequest:(NSFetchRequest<id <NSFetchRequestResult>> * _Nonnull)fetchRequest;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The <code>CSStorageInterface</code> serves as the Objective-C bridging type for <code>StorageInterface</code>.
/// seealso:
/// <code>StorageInterface</code>
SWIFT_PROTOCOL("_TtP9CoreStore18CSStorageInterface_")
@protocol CSStorageInterface
/// The string identifier for the <code>NSPersistentStore</code>’s <code>type</code> property. This is the same string CoreStore will use to create the <code>NSPersistentStore</code> from the <code>NSPersistentStoreCoordinator</code>’s <code>addPersistentStoreWithType(...)</code> method.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull storeType;)
+ (NSString * _Nonnull)storeType SWIFT_WARN_UNUSED_RESULT;
/// The configuration name in the model file
@property (nonatomic, readonly, copy) NSString * _Nullable configuration;
/// The options dictionary for the <code>NSPersistentStore</code>
@property (nonatomic, readonly, copy) NSDictionary * _Nullable storeOptions;
@end


/// The <code>CSInMemoryStore</code> serves as the Objective-C bridging type for <code>InMemoryStore</code>.
/// seealso:
/// <code>InMemoryStore</code>
SWIFT_CLASS("_TtC9CoreStore15CSInMemoryStore") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSInMemoryStore : NSObject <CSStorageInterface>
/// Initializes a <code>CSInMemoryStore</code> for the specified configuration
/// \param configuration an optional configuration name from the model file. If not specified, defaults to <code>nil</code>, the “Default” configuration.
///
- (nonnull instancetype)initWithConfiguration:(NSString * _Nullable)configuration;
/// Initializes a <code>CSInMemoryStore</code> with the “Default” configuration
- (nonnull instancetype)init;
/// The string identifier for the <code>NSPersistentStore</code>’s <code>type</code> property. For <code>CSInMemoryStore</code>s, this is always set to <code>NSInMemoryStoreType</code>.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull storeType;)
+ (NSString * _Nonnull)storeType SWIFT_WARN_UNUSED_RESULT;
/// The configuration name in the model file
@property (nonatomic, readonly, copy) NSString * _Nullable configuration;
/// The options dictionary for the <code>NSPersistentStore</code>. For <code>CSInMemoryStore</code>s, this is always set to <code>nil</code>.
@property (nonatomic, readonly, copy) NSDictionary * _Nullable storeOptions;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
@end


/// The <code>CSInto</code> serves as the Objective-C bridging type for <code>Into<T></code>.
/// seealso:
/// <code>Into</code>
SWIFT_CLASS("_TtC9CoreStore6CSInto")
@interface CSInto : NSObject
/// The associated <code>NSManagedObject</code> entity class
@property (nonatomic, readonly) SWIFT_METATYPE(NSManagedObject) _Nonnull entityClass;
/// The <code>NSPersistentStore</code> configuration name to associate objects from.
/// May contain a <code>String</code> to pertain to a named configuration, or <code>nil</code> to pertain to the default configuration
@property (nonatomic, readonly, copy) NSString * _Nullable configuration;
/// Initializes a <code>CSInto</code> clause with the specified entity class.
/// \code
/// MyPersonEntity *person = [transaction createInto:
///    CSIntoClass([MyPersonEntity class])];
///
/// \endcode\param entityClass the <code>NSManagedObject</code> class type to be created
///
- (nonnull instancetype)initWithEntityClass:(SWIFT_METATYPE(NSManagedObject) _Nonnull)entityClass;
/// Initializes a <code>CSInto</code> clause with the specified configuration.
/// \code
/// MyPersonEntity *person = [transaction createInto:
///    CSIntoClass([MyPersonEntity class])];
///
/// \endcode\param entityClass the <code>NSManagedObject</code> class type to be created
///
/// \param configuration the <code>NSPersistentStore</code> configuration name to associate the object to. This parameter is required if multiple configurations contain the created <code>NSManagedObject</code>’s entity type. Set to <code>nil</code> to use the default configuration.
///
- (nonnull instancetype)initWithEntityClass:(SWIFT_METATYPE(NSManagedObject) _Nonnull)entityClass configuration:(NSString * _Nullable)configuration;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@protocol NSFetchedResultsSectionInfo;
@protocol CSListObserver;
@protocol CSListSectionObserver;

/// The <code>CSListMonitor</code> serves as the Objective-C bridging type for <code>ListMonitor<T></code>.
/// seealso:
/// <code>ListMonitor</code>
SWIFT_CLASS("_TtC9CoreStore13CSListMonitor") SWIFT_AVAILABILITY(macos,introduced=10.12)
@interface CSListMonitor : NSObject
- (id _Nonnull)objectAtIndexedSubscript:(NSInteger)index SWIFT_WARN_UNUSED_RESULT;
/// Returns the object at the given index, or <code>nil</code> if out of bounds. This indexer is typically used for <code>CSListMonitor</code>s created without section groupings.
/// \param index the index for the object. Using an index above the valid range will return <code>nil</code>.
///
///
/// returns:
/// the <code>NSManagedObject</code> at the specified index, or <code>nil</code> if out of bounds
- (id _Nullable)objectAtSafeIndex:(NSInteger)index SWIFT_WARN_UNUSED_RESULT;
/// Returns the object at the given <code>sectionIndex</code> and <code>itemIndex</code>. This indexer is typically used for <code>CSListMonitor</code>s created as sectioned lists.
/// \param sectionIndex the section index for the object. Using a <code>sectionIndex</code> with an invalid range will raise an exception.
///
/// \param itemIndex the index for the object within the section. Using an <code>itemIndex</code> with an invalid range will raise an exception.
///
///
/// returns:
/// the <code>NSManagedObject</code> at the specified section and item index
- (id _Nonnull)objectAtSectionIndex:(NSInteger)sectionIndex itemIndex:(NSInteger)itemIndex SWIFT_WARN_UNUSED_RESULT;
/// Returns the object at the given section and item index, or <code>nil</code> if out of bounds. This indexer is typically used for <code>CSListMonitor</code>s created as sectioned lists.
/// \param sectionIndex the section index for the object. Using a <code>sectionIndex</code> with an invalid range will return <code>nil</code>.
///
/// \param itemIndex the index for the object within the section. Using an <code>itemIndex</code> with an invalid range will return <code>nil</code>.
///
///
/// returns:
/// the <code>NSManagedObject</code> at the specified section and item index, or <code>nil</code> if out of bounds
- (id _Nullable)objectAtSafeSectionIndex:(NSInteger)sectionIndex safeItemIndex:(NSInteger)itemIndex SWIFT_WARN_UNUSED_RESULT;
/// Returns the object at the given <code>NSIndexPath</code>. This subscript indexer is typically used for <code>CSListMonitor</code>s created as sectioned lists.
/// \param indexPath the <code>NSIndexPath</code> for the object. Using an <code>indexPath</code> with an invalid range will raise an exception.
///
///
/// returns:
/// the <code>NSManagedObject</code> at the specified index path
- (id _Nonnull)objectAtIndexPath:(NSIndexPath * _Nonnull)indexPath SWIFT_WARN_UNUSED_RESULT;
/// Returns the object at the given <code>NSIndexPath</code>, or <code>nil</code> if out of bounds. This subscript indexer is typically used for <code>CSListMonitor</code>s created as sectioned lists.
/// \param indexPath the <code>NSIndexPath</code> for the object. Using an <code>indexPath</code> with an invalid range will return <code>nil</code>.
///
///
/// returns:
/// the <code>NSManagedObject</code> at the specified index path, or <code>nil</code> if out of bounds
- (id _Nullable)objectAtSafeIndexPath:(NSIndexPath * _Nonnull)indexPath SWIFT_WARN_UNUSED_RESULT;
/// Checks if the <code>CSListMonitor</code> has at least one object in any section.
///
/// returns:
/// <code>YES</code> if at least one object in any section exists, <code>NO</code> otherwise
- (BOOL)hasObjects SWIFT_WARN_UNUSED_RESULT;
/// Checks if the <code>CSListMonitor</code> has at least one object the specified section.
/// \param section the section index. Using an index outside the valid range will return <code>NO</code>.
///
///
/// returns:
/// <code>YES</code> if at least one object in the specified section exists, <code>NO</code> otherwise
- (BOOL)hasObjectsInSection:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// Returns all objects in all sections
///
/// returns:
/// all objects in all sections
- (NSArray<NSManagedObject *> * _Nonnull)objectsInAllSections SWIFT_WARN_UNUSED_RESULT;
/// Returns all objects in the specified section
/// \param section the section index. Using an index outside the valid range will raise an exception.
///
///
/// returns:
/// all objects in the specified section
- (NSArray<NSManagedObject *> * _Nonnull)objectsInSection:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// Returns all objects in the specified section, or <code>nil</code> if out of bounds.
/// \param section the section index. Using an index outside the valid range will return <code>nil</code>.
///
///
/// returns:
/// all objects in the specified section, or <code>nil</code> if out of bounds
- (NSArray<NSManagedObject *> * _Nullable)objectsInSafeSectionWithSafeSectionIndex:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// Returns the number of sections
///
/// returns:
/// the number of sections
- (NSInteger)numberOfSections SWIFT_WARN_UNUSED_RESULT;
/// Returns the number of objects in all sections
///
/// returns:
/// the number of objects in all sections
- (NSInteger)numberOfObjects SWIFT_WARN_UNUSED_RESULT;
/// Returns the number of objects in the specified section
/// \param section the section index. Using an index outside the valid range will raise an exception.
///
///
/// returns:
/// the number of objects in the specified section
- (NSInteger)numberOfObjectsInSection:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// Returns the number of objects in the specified section, or <code>nil</code> if out of bounds.
/// \param section the section index. Using an index outside the valid range will return <code>nil</code>.
///
///
/// returns:
/// the number of objects in the specified section, or <code>nil</code> if out of bounds
- (NSNumber * _Nullable)numberOfObjectsInSafeSectionWithSafeSectionIndex:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// Returns the <code>NSFetchedResultsSectionInfo</code> for the specified section
/// \param section the section index. Using an index outside the valid range will raise an exception.
///
///
/// returns:
/// the <code>NSFetchedResultsSectionInfo</code> for the specified section
- (id <NSFetchedResultsSectionInfo> _Nonnull)sectionInfoAtIndex:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// Returns the <code>NSFetchedResultsSectionInfo</code> for the specified section, or <code>nil</code> if out of bounds.
/// \param section the section index. Using an index outside the valid range will return <code>nil</code>.
///
///
/// returns:
/// the <code>NSFetchedResultsSectionInfo</code> for the specified section, or <code>nil</code> if the section index is out of bounds.
- (id <NSFetchedResultsSectionInfo> _Nullable)sectionInfoAtSafeSectionIndexWithSafeSectionIndex:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// Returns the <code>NSFetchedResultsSectionInfo</code>s for all sections
///
/// returns:
/// the <code>NSFetchedResultsSectionInfo</code>s for all sections
- (NSArray<id <NSFetchedResultsSectionInfo>> * _Nonnull)sections SWIFT_WARN_UNUSED_RESULT;
/// Returns the target section for a specified “Section Index” title and index.
/// \param title the title of the Section Index
///
/// \param index the index of the Section Index
///
///
/// returns:
/// the target section for the specified “Section Index” title and index.
- (NSInteger)targetSectionForSectionIndexTitleWithTitle:(NSString * _Nonnull)title index:(NSInteger)index SWIFT_WARN_UNUSED_RESULT;
/// Returns the section index titles for all sections
///
/// returns:
/// the section index titles for all sections
- (NSArray<NSString *> * _Nonnull)sectionIndexTitles SWIFT_WARN_UNUSED_RESULT;
/// Returns the index of the <code>NSManagedObject</code> if it exists in the <code>CSListMonitor</code>’s fetched objects, or <code>nil</code> if not found.
/// \param object the <code>NSManagedObject</code> to search the index of
///
///
/// returns:
/// the index of the <code>NSManagedObject</code> if it exists in the <code>CSListMonitor</code>’s fetched objects, or <code>nil</code> if not found.
- (NSNumber * _Nullable)indexOf:(NSManagedObject * _Nonnull)object SWIFT_WARN_UNUSED_RESULT;
/// Returns the <code>NSIndexPath</code> of the <code>NSManagedObject</code> if it exists in the <code>CSListMonitor</code>’s fetched objects, or <code>nil</code> if not found.
/// \param object the <code>NSManagedObject</code> to search the index of
///
///
/// returns:
/// the <code>NSIndexPath</code> of the <code>NSManagedObject</code> if it exists in the <code>ListMonitor</code>’s fetched objects, or <code>nil</code> if not found.
- (NSIndexPath * _Nullable)indexPathOf:(NSManagedObject * _Nonnull)object SWIFT_WARN_UNUSED_RESULT;
/// Registers a <code>CSListObserver</code> to be notified when changes to the receiver’s list occur.
/// To prevent retain-cycles, <code>CSListMonitor</code> only keeps <code>weak</code> references to its observers.
/// For thread safety, this method needs to be called from the main thread. An assertion failure will occur (on debug builds only) if called from any thread other than the main thread.
/// Calling <code>-addListObserver:</code> multiple times on the same observer is safe, as <code>CSListMonitor</code> unregisters previous notifications to the observer before re-registering them.
/// \param observer a <code>CSListObserver</code> to send change notifications to
///
- (void)addListObserver:(id <CSListObserver> _Nonnull)observer;
/// Registers a <code>CSListSectionObserver</code> to be notified when changes to the receiver’s list occur.
/// To prevent retain-cycles, <code>CSListMonitor</code> only keeps <code>weak</code> references to its observers.
/// For thread safety, this method needs to be called from the main thread. An assertion failure will occur (on debug builds only) if called from any thread other than the main thread.
/// Calling <code>-addListSectionObserver:</code> multiple times on the same observer is safe, as <code>ListMonitor</code> unregisters previous notifications to the observer before re-registering them.
/// \param observer a <code>CSListSectionObserver</code> to send change notifications to
///
- (void)addListSectionObserver:(id <CSListSectionObserver> _Nonnull)observer;
/// Unregisters a <code>CSListObserver</code> from receiving notifications for changes to the receiver’s list.
/// For thread safety, this method needs to be called from the main thread. An assertion failure will occur (on debug builds only) if called from any thread other than the main thread.
/// \param observer a <code>CSListObserver</code> to unregister notifications to
///
- (void)removeListObserver:(id <CSListObserver> _Nonnull)observer;
/// Returns <code>YES</code> if a call to <code>-refetch:</code> was made to the <code>CSListMonitor</code> and is currently waiting for the fetching to complete. Returns <code>NO</code> otherwise.
@property (nonatomic, readonly) BOOL isPendingRefetch;
/// Asks the <code>CSListMonitor</code> to refetch its objects using the specified series of <code>CSFetchClause</code>s. Note that this method does not execute the fetch immediately; the actual fetching will happen after the <code>NSFetchedResultsController</code>’s last <code>controllerDidChangeContent(_:)</code> notification completes.
/// <code>refetch(...)</code> broadcasts <code>listMonitorWillRefetch(...)</code> to its observers immediately, and then <code>listMonitorDidRefetch(...)</code> after the new fetch request completes.
/// important:
/// Starting CoreStore 4.0, all <code>CSFetchClause</code>s required by the <code>CSListMonitor</code> should be provided in the arguments list of <code>refetch(...)</code>.
/// \param fetchClauses a series of <code>FetchClause</code> instances for fetching the object list. Accepts <code>Where</code>, <code>OrderBy</code>, and <code>Tweak</code> clauses.
///
- (void)refetch:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Implement the <code>CSListObserver</code> protocol to observe changes to a list of <code>NSManagedObject</code>s. <code>CSListObserver</code>s may register themselves to a <code>CSListMonitor</code>’s <code>-addListObserver:</code> method:
/// \code
/// CSListMonitor *monitor = [CSCoreStore 
///     monitorListFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     fetchClauses:@[[CSOrderBy sortDescriptor:[CSSortKey withKeyPath:@"lastName" ascending:YES]]]];
/// [monitor addListObserver:self];
///
/// \endcodeseealso:
/// <code>ListObserver</code>
SWIFT_PROTOCOL("_TtP9CoreStore14CSListObserver_") SWIFT_AVAILABILITY(macos,introduced=10.12)
@protocol CSListObserver
@optional
/// Handles processing just before a change to the observed list occurs
/// \param monitor the <code>CSListMonitor</code> monitoring the list being observed
///
- (void)listMonitorWillChange:(CSListMonitor * _Nonnull)monitor;
/// Handles processing right after a change to the observed list occurs
/// \param monitor the <code>CSListMonitor</code> monitoring the object being observed
///
- (void)listMonitorDidChange:(CSListMonitor * _Nonnull)monitor;
/// This method is broadcast from within the <code>CSListMonitor</code>’s <code>-refetchWithFetchClauses:</code> method to let observers prepare for the internal <code>NSFetchedResultsController</code>’s pending change to its predicate, sort descriptors, etc. Note that the actual refetch will happen after the <code>NSFetchedResultsController</code>’s last <code>-controllerDidChangeContent:</code> notification completes.
/// \param monitor the <code>CSListMonitor</code> monitoring the object being observed
///
- (void)listMonitorWillRefetch:(CSListMonitor * _Nonnull)monitor;
/// After the <code>CSListMonitor</code>’s <code>-refetchWithFetchClauses:</code> method is called, this method is broadcast after the <code>NSFetchedResultsController</code>’s last <code>-controllerDidChangeContent:</code> notification completes.
/// \param monitor the <code>CSListMonitor</code> monitoring the object being observed
///
- (void)listMonitorDidRefetch:(CSListMonitor * _Nonnull)monitor;
@end


/// Implement the <code>CSListObjectObserver</code> protocol to observe detailed changes to a list’s object. <code>CSListObjectObserver</code>s may register themselves to a <code>CSListMonitor</code>’s <code>-addListObjectObserver(_:)</code> method:
/// \code
/// CSListMonitor *monitor = [CSCoreStore
///     monitorListFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     fetchClauses:@[[CSOrderBy sortDescriptor:[CSSortKey withKeyPath:@"lastName" ascending:YES]]]];
/// [monitor addListObjectObserver:self];
///
/// \endcodeseealso:
/// <code>ListObjectObserver</code>
SWIFT_PROTOCOL("_TtP9CoreStore20CSListObjectObserver_") SWIFT_AVAILABILITY(macos,introduced=10.12)
@protocol CSListObjectObserver <CSListObserver>
@optional
/// Notifies that an object was inserted to the specified <code>NSIndexPath</code> in the list
/// \param monitor the <code>CSListMonitor</code> monitoring the list being observed
///
/// \param object the entity type for the inserted object
///
/// \param indexPath the new <code>NSIndexPath</code> for the inserted object
///
- (void)listMonitor:(CSListMonitor * _Nonnull)monitor didInsertObject:(id _Nonnull)object toIndexPath:(NSIndexPath * _Nonnull)indexPath;
/// Notifies that an object was deleted from the specified <code>NSIndexPath</code> in the list
/// \param monitor the <code>CSListMonitor</code> monitoring the list being observed
///
/// \param object the entity type for the deleted object
///
/// \param indexPath the <code>NSIndexPath</code> for the deleted object
///
- (void)listMonitor:(CSListMonitor * _Nonnull)monitor didDeleteObject:(id _Nonnull)object fromIndexPath:(NSIndexPath * _Nonnull)indexPath;
/// Notifies that an object at the specified <code>NSIndexPath</code> was updated
/// \param monitor the <code>CSListMonitor</code> monitoring the list being observed
///
/// \param object the entity type for the updated object
///
/// \param indexPath the <code>NSIndexPath</code> for the updated object
///
- (void)listMonitor:(CSListMonitor * _Nonnull)monitor didUpdateObject:(id _Nonnull)object atIndexPath:(NSIndexPath * _Nonnull)indexPath;
/// Notifies that an object’s index changed
/// \param monitor the <code>CSListMonitor</code> monitoring the list being observed
///
/// \param object the entity type for the moved object
///
/// \param fromIndexPath the previous <code>NSIndexPath</code> for the moved object
///
/// \param toIndexPath the new <code>NSIndexPath</code> for the moved object
///
- (void)listMonitor:(CSListMonitor * _Nonnull)monitor didMoveObject:(id _Nonnull)object fromIndexPath:(NSIndexPath * _Nonnull)fromIndexPath toIndexPath:(NSIndexPath * _Nonnull)toIndexPath;
@end



/// Implement the <code>CSListSectionObserver</code> protocol to observe changes to a list’s section info. <code>CSListSectionObserver</code>s may register themselves to a <code>CSListMonitor</code>’s <code>-addListSectionObserver:</code> method:
/// \code
/// CSListMonitor *monitor = [CSCoreStore
///     monitorSectionedListFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     sectionBy:[CSSectionBy keyPath:@"age"]
///     fetchClauses:@[[CSOrderBy sortDescriptor:[CSSortKey withKeyPath:@"lastName" ascending:YES]]]];
/// [monitor addListSectionObserver:self];
///
/// \endcodeseealso:
/// <code>ListSectionObserver</code>
SWIFT_PROTOCOL("_TtP9CoreStore21CSListSectionObserver_") SWIFT_AVAILABILITY(macos,introduced=10.12)
@protocol CSListSectionObserver <CSListObjectObserver>
@optional
/// Notifies that a section was inserted at the specified index
/// \param monitor the <code>CSListMonitor</code> monitoring the list being observed
///
/// \param sectionInfo the <code>NSFetchedResultsSectionInfo</code> for the inserted section
///
/// \param sectionIndex the new section index for the new section
///
- (void)listMonitor:(CSListMonitor * _Nonnull)monitor didInsertSection:(id <NSFetchedResultsSectionInfo> _Nonnull)sectionInfo toSectionIndex:(NSInteger)sectionIndex;
/// Notifies that a section was inserted at the specified index
/// \param monitor the <code>CSListMonitor</code> monitoring the list being observed
///
/// \param sectionInfo the <code>NSFetchedResultsSectionInfo</code> for the deleted section
///
/// \param sectionIndex the previous section index for the deleted section
///
- (void)listMonitor:(CSListMonitor * _Nonnull)monitor didDeleteSection:(id <NSFetchedResultsSectionInfo> _Nonnull)sectionInfo fromSectionIndex:(NSInteger)sectionIndex;
@end

@class NSDictionary;

/// The <code>CSLocalStorage</code> serves as the Objective-C bridging type for <code>LocalStorage</code>.
/// seealso:
/// <code>LocalStorage</code>
SWIFT_PROTOCOL("_TtP9CoreStore14CSLocalStorage_")
@protocol CSLocalStorage <CSStorageInterface>
/// The <code>NSURL</code> that points to the store file
@property (nonatomic, readonly, copy) NSURL * _Nonnull fileURL;
/// An array of <code>SchemaMappingProvider</code>s that provides the complete mapping models for custom migrations. This is currently only supported for Swift code.
@property (nonatomic, readonly, copy) NSArray * _Nonnull migrationMappingProviders;
/// Options that tell the <code>CSDataStack</code> how to setup the persistent store
@property (nonatomic, readonly) NSInteger localStorageOptions;
/// Called by the <code>CSDataStack</code> to perform actual deletion of the store file from disk. Do not call directly! The <code>sourceModel</code> argument is a hint for the existing store’s model version. Implementers can use the <code>sourceModel</code> to perform necessary store operations. (SQLite stores for example, can convert WAL journaling mode to DELETE before deleting)
- (BOOL)cs_eraseStorageAndWaitWithMetadata:(NSDictionary * _Nonnull)metadata soureModelHint:(NSManagedObjectModel * _Nullable)soureModelHint error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
@end

/// The <code>CSLocalStorageOptions</code> provides settings that tells the <code>CSDataStack</code> how to setup the persistent store for <code>CSLocalStorage</code> implementers.
/// seealso:
/// <code>LocalStorageOptions</code>
typedef SWIFT_ENUM(NSInteger, CSLocalStorageOptions, closed) {
/// Tells the <code>DataStack</code> that the store should not be migrated or recreated, and should simply fail on model mismatch
  CSLocalStorageOptionsNone = 0,
/// Tells the <code>DataStack</code> to delete and recreate the store on model mismatch, otherwise exceptions will be thrown on failure instead
  CSLocalStorageOptionsRecreateStoreOnModelMismatch = 1,
/// Tells the <code>DataStack</code> to prevent progressive migrations for the store
  CSLocalStorageOptionsPreventProgressiveMigration = 2,
/// Tells the <code>DataStack</code> to allow lightweight migration for the store when added synchronously
  CSLocalStorageOptionsAllowSynchronousLightweightMigration = 4,
};


/// The <code>CSMigrationResult</code> serves as the Objective-C bridging type for <code>MigrationResult</code>.
/// seealso:
/// <code>MigrationResult</code>
SWIFT_CLASS("_TtC9CoreStore17CSMigrationResult") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSMigrationResult : NSObject
/// <code>YES</code> if the migration succeeded, <code>NO</code> otherwise
@property (nonatomic, readonly) BOOL isSuccess;
/// <code>YES</code> if the migration failed, <code>NO</code> otherwise
@property (nonatomic, readonly) BOOL isFailure;
/// <code>YES</code> if the migration succeeded, <code>NO</code> otherwise
@property (nonatomic, readonly, copy) NSArray<CSMigrationType *> * _Nullable migrationTypes;
/// The <code>NSError</code> for a failed migration, or <code>nil</code> if the migration succeeded
@property (nonatomic, readonly, strong) NSError * _Nullable error;
/// If the result was a success, the <code>success</code> block is executed with an array of <code>CSMigrationType</code>s that indicates the migration steps completed. If the result was a failure, the <code>failure</code> block is executed with an <code>NSError</code> argument pertaining to the actual error.
/// The blocks are executed immediately as <code>@noescape</code> and will not be retained.
/// \param success the block to execute on success. The block passes an array of <code>CSMigrationType</code>s that indicates the migration steps completed.
///
/// \param failure the block to execute on failure. The block passes an <code>NSError</code> argument that pertains to the actual error.
///
- (void)handleSuccess:(SWIFT_NOESCAPE void (^ _Nonnull)(NSArray<CSMigrationType *> * _Nonnull))success failure:(SWIFT_NOESCAPE void (^ _Nonnull)(NSError * _Nonnull))failure;
/// If the result was a success, the <code>success</code> block is executed with an array of <code>CSMigrationType</code>s that indicates the migration steps completed. If the result was a failure, this method does nothing.
/// The block is executed immediately as <code>@noescape</code> and will not be retained.
/// \param success the block to execute on success. The block passes an array of <code>CSMigrationType</code>s that indicates the migration steps completed.
///
- (void)handleSuccess:(SWIFT_NOESCAPE void (^ _Nonnull)(NSArray<CSMigrationType *> * _Nonnull))success;
/// If the result was a failure, the <code>failure</code> block is executed with an <code>NSError</code> argument pertaining to the actual error. If the result was a success, this method does nothing.
/// The block is executed immediately as <code>@noescape</code> and will not be retained.
/// \param failure the block to execute on failure. The block passes an <code>NSError</code> argument that pertains to the actual error.
///
- (void)handleFailure:(SWIFT_NOESCAPE void (^ _Nonnull)(NSError * _Nonnull))failure;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The <code>CSMigrationType</code> serves as the Objective-C bridging type for <code>MigrationType</code>.
/// seealso:
/// <code>MigrationType</code>
SWIFT_CLASS("_TtC9CoreStore15CSMigrationType") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSMigrationType : NSObject
/// Returns <code>YES</code> if the <code>CSMigrationType</code>’s <code>sourceVersion</code> and <code>destinationVersion</code> do not match. Returns <code>NO</code> otherwise.
@property (nonatomic, readonly) BOOL needsMigration;
/// Returns the source model version for the migration type. If no migration is required, <code>sourceVersion</code> will be equal to the <code>destinationVersion</code>.
@property (nonatomic, readonly, copy) NSString * _Nonnull sourceVersion;
/// Returns the destination model version for the migration type. If no migration is required, <code>destinationVersion</code> will be equal to the <code>sourceVersion</code>.
@property (nonatomic, readonly, copy) NSString * _Nonnull destinationVersion;
/// Returns <code>YES</code> if the <code>CSMigrationType</code> is a lightweight migration. Used as syntactic sugar.
@property (nonatomic, readonly) BOOL isLightweightMigration;
/// Returns <code>YES</code> if the <code>CSMigrationType</code> is a heavyweight migration. Used as syntactic sugar.
@property (nonatomic, readonly) BOOL isHeavyweightMigration;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The <code>CSObjectMonitor</code> serves as the Objective-C bridging type for <code>ObjectMonitor<T></code>.
/// seealso:
/// <code>ObjectMonitor</code>
SWIFT_CLASS("_TtC9CoreStore15CSObjectMonitor") SWIFT_AVAILABILITY(macos,introduced=10.12)
@interface CSObjectMonitor : NSObject
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Implement the <code>CSObjectObserver</code> protocol to observe changes  to a single <code>NSManagedObject</code> instance. <code>CSObjectObserver</code>s may register themselves to a <code>CSObjectMonitor</code>’s <code>-addObjectObserver:</code> method:
/// \code
/// CSObjectMonitor *monitor = [CSCoreStore monitorObject:myObject];
/// [monitor addObjectObserver:self];
///
/// \endcodeseealso:
/// <code>ObjectObserver</code>
SWIFT_PROTOCOL("_TtP9CoreStore16CSObjectObserver_") SWIFT_AVAILABILITY(macos,introduced=10.12)
@protocol CSObjectObserver
@optional
/// Handles processing just before a change to the observed <code>object</code> occurs
/// \param monitor the <code>CSObjectMonitor</code> monitoring the object being observed
///
/// \param object the <code>NSManagedObject</code> instance being observed
///
- (void)objectMonitor:(CSObjectMonitor * _Nonnull)monitor willUpdateObject:(id _Nonnull)object;
/// Handles processing right after a change to the observed <code>object</code> occurs
/// \param monitor the <code>CSObjectMonitor</code> monitoring the object being observed
///
/// \param object the <code>NSManagedObject</code> instance being observed
///
/// \param changedPersistentKeys an <code>NSSet</code> of key paths for the attributes that were changed. Note that <code>changedPersistentKeys</code> only contains keys for attributes/relationships present in the persistent store, thus transient properties will not be reported.
///
- (void)objectMonitor:(CSObjectMonitor * _Nonnull)monitor didUpdateObject:(id _Nonnull)object changedPersistentKeys:(NSSet<NSString *> * _Nonnull)changedPersistentKeys;
/// Handles processing right after <code>object</code> is deleted
/// \param monitor the <code>CSObjectMonitor</code> monitoring the object being observed
///
/// \param object the <code>NSManagedObject</code> instance being observed
///
- (void)objectMonitor:(CSObjectMonitor * _Nonnull)monitor didDeleteObject:(id _Nonnull)object;
@end

@class NSSortDescriptor;

/// The <code>CSOrderBy</code> serves as the Objective-C bridging type for <code>OrderBy</code>.
/// seealso:
/// <code>OrderBy</code>
SWIFT_CLASS("_TtC9CoreStore9CSOrderBy")
@interface CSOrderBy : NSObject <CSDeleteClause, CSFetchClause, CSQueryClause>
/// The list of sort descriptors
@property (nonatomic, readonly, copy) NSArray<NSSortDescriptor *> * _Nonnull sortDescriptors;
/// Initializes a <code>CSOrderBy</code> clause with a single sort descriptor
/// \code
/// MyPersonEntity *people = [transaction
///    fetchAllFrom:CSFromClass([MyPersonEntity class])
///    fetchClauses:@[CSOrderByKey(CSSortAscending(@"fullname"))]]];
///
/// \endcode\param sortDescriptor a <code>NSSortDescriptor</code>
///
- (nonnull instancetype)initWithSortDescriptor:(NSSortDescriptor * _Nonnull)sortDescriptor;
/// Initializes a <code>CSOrderBy</code> clause with a list of sort descriptors
/// \code
/// MyPersonEntity *people = [transaction
///    fetchAllFrom:CSFromClass([MyPersonEntity class])
///    fetchClauses:@[CSOrderByKeys(CSSortAscending(@"fullname"), CSSortDescending(@"age"), nil))]]];
///
/// \endcode\param sortDescriptors an array of <code>NSSortDescriptor</code>s
///
- (nonnull instancetype)initWithSortDescriptors:(NSArray<NSSortDescriptor *> * _Nonnull)sortDescriptors;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (void)applyToFetchRequest:(NSFetchRequest<id <NSFetchRequestResult>> * _Nonnull)fetchRequest;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



/// The <code>CSSQLiteStore</code> serves as the Objective-C bridging type for <code>SQLiteStore</code>.
/// seealso:
/// <code>SQLiteStore</code>
SWIFT_CLASS("_TtC9CoreStore13CSSQLiteStore") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSSQLiteStore : NSObject <CSLocalStorage>
/// Initializes an SQLite store interface from the given SQLite file URL. When this instance is passed to the <code>CSDataStack</code>’s <code>-addStorage*:</code> methods, a new SQLite file will be created if it does not exist.
/// important:
/// Initializing <code>CSSQLiteStore</code>s with custom migration mapping models is currently not supported. Create an <code>SQLiteStore</code> instance from Swift code and bridge the instance to Objective-C using its <code>SQLiteStore.bridgeToObjectiveC</code> property.
/// \param fileURL the local file URL for the target SQLite persistent store. Note that if you have multiple configurations, you will need to specify a different <code>fileURL</code> explicitly for each of them.
///
/// \param configuration an optional configuration name from the model file. If not specified, defaults to <code>nil</code>, the “Default” configuration. Note that if you have multiple configurations, you will need to specify a different <code>fileURL</code> explicitly for each of them.
///
/// \param localStorageOptions When the <code>CSSQLiteStore</code> is passed to the <code>CSDataStack</code>’s <code>addStorage()</code> methods, tells the <code>CSDataStack</code> how to setup the persistent store. Defaults to <code>CSLocalStorageOptionsNone</code>.
///
- (nonnull instancetype)initWithFileURL:(NSURL * _Nonnull)fileURL configuration:(NSString * _Nullable)configuration localStorageOptions:(NSInteger)localStorageOptions;
/// Initializes an SQLite store interface from the given SQLite file name. When this instance is passed to the <code>CSDataStack</code>’s <code>-addStorage*:</code> methods, a new SQLite file will be created if it does not exist.
/// important:
/// Initializing <code>CSSQLiteStore</code>s with custom migration mapping models is currently not supported. Create an <code>SQLiteStore</code> instance from Swift code and bridge the instance to Objective-C using its <code>SQLiteStore.bridgeToObjectiveC</code> property.
/// \param fileName the local filename for the SQLite persistent store in the “Application Support/<bundle id>” directory (or the “Caches/<bundle id>” directory on tvOS). Note that if you have multiple configurations, you will need to specify a different <code>fileName</code> explicitly for each of them.
///
/// \param configuration an optional configuration name from the model file. If not specified, defaults to <code>nil</code>, the “Default” configuration. Note that if you have multiple configurations, you will need to specify a different <code>fileName</code> explicitly for each of them.
///
/// \param localStorageOptions When the <code>CSSQLiteStore</code> is passed to the <code>CSDataStack</code>’s <code>addStorage()</code> methods, tells the <code>CSDataStack</code> how to setup the persistent store. Defaults to <code>[CSLocalStorageOptions none]</code>.
///
- (nonnull instancetype)initWithFileName:(NSString * _Nonnull)fileName configuration:(NSString * _Nullable)configuration localStorageOptions:(NSInteger)localStorageOptions;
/// Initializes an <code>CSSQLiteStore</code> with an all-default settings: a <code>fileURL</code> pointing to a “<Application name>.sqlite” file in the “Application Support/<bundle id>” directory (or the “Caches/<bundle id>” directory on tvOS), a <code>nil</code> <code>configuration</code> pertaining to the “Default” configuration, and <code>localStorageOptions</code> set to <code>[CSLocalStorageOptions none]</code>.
/// important:
/// Initializing <code>CSSQLiteStore</code>s with custom migration mapping models is currently not supported. Create an <code>SQLiteStore</code> instance from Swift code and bridge the instance to Objective-C using its <code>SQLiteStore.bridgeToObjectiveC</code> property.
- (nonnull instancetype)init;
/// The <code>NSURL</code> that points to the SQLite file
@property (nonatomic, readonly, copy) NSURL * _Nonnull fileURL;
/// An array of <code>SchemaMappingProvider</code>s that provides the complete mapping models for custom migrations. This is currently only supported for Swift code.
@property (nonatomic, readonly, copy) NSArray * _Nonnull migrationMappingProviders;
/// Options that tell the <code>CSDataStack</code> how to setup the persistent store
@property (nonatomic, readonly) NSInteger localStorageOptions;
/// The string identifier for the <code>NSPersistentStore</code>’s <code>type</code> property. For <code>CSSQLiteStore</code>s, this is always set to <code>NSSQLiteStoreType</code>.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull storeType;)
+ (NSString * _Nonnull)storeType SWIFT_WARN_UNUSED_RESULT;
/// The configuration name in the model file
@property (nonatomic, readonly, copy) NSString * _Nullable configuration;
/// The options dictionary for the <code>NSPersistentStore</code>. For <code>CSSQLiteStore</code>s, this is always set to
/// \code
/// [NSSQLitePragmasOption: ["journal_mode": "WAL"]]
///
/// \endcode
@property (nonatomic, readonly, copy) NSDictionary * _Nullable storeOptions;
/// Called by the <code>CSDataStack</code> to perform actual deletion of the store file from disk. Do not call directly! The <code>sourceModel</code> argument is a hint for the existing store’s model version. For <code>CSSQLiteStore</code>, this converts the database’s WAL journaling mode to DELETE before deleting the file.
- (BOOL)cs_eraseStorageAndWaitWithMetadata:(NSDictionary * _Nonnull)metadata soureModelHint:(NSManagedObjectModel * _Nullable)soureModelHint error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
@end


/// The <code>CSSectionBy</code> serves as the Objective-C bridging type for <code>SectionBy</code>.
/// seealso:
/// <code>SectionBy</code>
SWIFT_CLASS("_TtC9CoreStore11CSSectionBy") SWIFT_AVAILABILITY(macos,introduced=10.12)
@interface CSSectionBy : NSObject
/// Initializes a <code>CSSectionBy</code> clause with the key path to use to group <code>CSListMonitor</code> objects into sections
/// \param sectionKeyPath the key path to use to group the objects into sections
///
///
/// returns:
/// a <code>CSSectionBy</code> clause with the key path to use to group <code>CSListMonitor</code> objects into sections
+ (CSSectionBy * _Nonnull)keyPath:(NSString * _Nonnull)sectionKeyPath SWIFT_WARN_UNUSED_RESULT;
/// Initializes a <code>CSSectionBy</code> clause with the key path to use to group <code>CSListMonitor</code> objects into sections, and a closure to transform the value for the key path to an appropriate section name
/// \param sectionKeyPath the key path to use to group the objects into sections
///
/// \param sectionIndexTransformer a closure to transform the value for the key path to an appropriate section name
///
///
/// returns:
/// a <code>CSSectionBy</code> clause with the key path to use to group <code>CSListMonitor</code> objects into sections
+ (CSSectionBy * _Nonnull)keyPath:(NSString * _Nonnull)sectionKeyPath sectionIndexTransformer:(NSString * _Nullable (^ _Nonnull)(NSString * _Nullable))sectionIndexTransformer SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class CSSelectTerm;

/// The <code>CSSelect</code> serves as the Objective-C bridging type for <code>Select</code>.
/// seealso:
/// <code>Select</code>
SWIFT_CLASS("_TtC9CoreStore8CSSelect")
@interface CSSelect : NSObject
/// Creates a <code>CSSelect</code> clause for querying <code>NSNumber</code> values.
/// \code
/// NSNumber *maxAge = [CSCoreStore
///    queryValueFrom:CSFromClass([MyPersonEntity class])
///    select:CSSelectNumber(CSAggregateMax(@"age"))
///    // ...
///
/// \endcode\param numberTerm the <code>CSSelectTerm</code> specifying the attribute/aggregate value to query
///
- (nonnull instancetype)initWithNumberTerm:(CSSelectTerm * _Nonnull)numberTerm;
/// Creates a <code>CSSelect</code> clause for querying <code>NSDecimalNumber</code> values.
/// \code
/// NSDecimalNumber *averagePrice = [CSCoreStore
///    queryValueFrom:CSFromClass([MyPersonEntity class])
///    select:CSSelectDecimal(CSAggregateAverage(@"price"))
///    // ...
///
/// \endcode\param decimalTerm the <code>CSSelectTerm</code> specifying the attribute/aggregate value to query
///
- (nonnull instancetype)initWithDecimalTerm:(CSSelectTerm * _Nonnull)decimalTerm;
/// Creates a <code>CSSelect</code> clause for querying <code>NSString</code> values.
/// \code
/// NSString *fullname = [CSCoreStore
///    queryValueFrom:CSFromClass([MyPersonEntity class])
///    select:CSSelectString(CSAttribute(@"fullname"))
///    // ...
///
/// \endcode\param stringTerm the <code>CSSelectTerm</code> specifying the attribute/aggregate value to query
///
- (nonnull instancetype)initWithStringTerm:(CSSelectTerm * _Nonnull)stringTerm;
/// Creates a <code>CSSelect</code> clause for querying <code>NSDate</code> values.
/// \code
/// NSDate *lastUpdate = [CSCoreStore
///    queryValueFrom:CSFromClass([MyPersonEntity class])
///    select:CSSelectDate(CSAggregateMax(@"updatedDate"))
///    // ...
///
/// \endcode\param dateTerm the <code>CSSelectTerm</code> specifying the attribute/aggregate value to query
///
- (nonnull instancetype)initWithDateTerm:(CSSelectTerm * _Nonnull)dateTerm;
/// Creates a <code>CSSelect</code> clause for querying <code>NSData</code> values.
/// \code
/// NSData *imageData = [CSCoreStore
///    queryValueFrom:CSFromClass([MyPersonEntity class])
///    select:CSSelectData(CSAttribute(@"imageData"))
///    // ...
///
/// \endcode\param dataTerm the <code>CSSelectTerm</code> specifying the attribute/aggregate value to query
///
- (nonnull instancetype)initWithDataTerm:(CSSelectTerm * _Nonnull)dataTerm;
/// Creates a <code>CSSelect</code> clause for querying <code>NSManagedObjectID</code> values.
/// \code
/// NSManagedObjectID *objectID = [CSCoreStore
///    queryValueFrom:CSFromClass([MyPersonEntity class])
///    select:CSSelectObjectID()
///    // ...
///
/// \endcode
- (nonnull instancetype)initWithObjectIDTerm;
/// Creates a <code>CSSelect</code> clause for querying <code>NSDictionary</code> of an entity’s attribute keys and values.
/// \code
/// NSDictionary *keyValues = [CSCoreStore
///     queryValueFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     select:[CSSelect dictionaryForTerm:[CSSelectTerm maximum:@"age" as:nil]]];
///
/// \endcode\param term the <code>CSSelectTerm</code> specifying the attribute/aggregate value to query
///
///
/// returns:
/// a <code>CSSelect</code> clause for querying an entity attribute
+ (CSSelect * _Nonnull)dictionaryForTerm:(CSSelectTerm * _Nonnull)term SWIFT_WARN_UNUSED_RESULT;
/// Creates a <code>CSSelect</code> clause for querying <code>NSDictionary</code> of an entity’s attribute keys and values.
/// \code
/// NSDictionary *keyValues = [CSCoreStore
///     queryValueFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     select:[CSSelect dictionaryForTerms:@[
///         [CSSelectTerm attribute:@"name" as:nil],
///         [CSSelectTerm attribute:@"age" as:nil]
///     ]]];
///
/// \endcode\param terms the <code>CSSelectTerm</code>s specifying the attribute/aggregate values to query
///
///
/// returns:
/// a <code>CSSelect</code> clause for querying an entity attribute
+ (CSSelect * _Nonnull)dictionaryForTerms:(NSArray<CSSelectTerm *> * _Nonnull)terms SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The <code>CSSelectTerm</code> serves as the Objective-C bridging type for <code>SelectTerm</code>.
/// seealso:
/// <code>SelectTerm</code>
SWIFT_CLASS("_TtC9CoreStore12CSSelectTerm")
@interface CSSelectTerm : NSObject
/// Provides a <code>CSSelectTerm</code> to a <code>CSSelect</code> clause for querying an entity attribute.
/// \code
/// NSString *fullName = [CSCoreStore
///     queryValueFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     select:CSSelectString(CSAttribute(@"fullname"))
///     fetchClauses:@[[CSWhere keyPath:@"employeeID" isEqualTo: @1111]]];
///
/// \endcode\param keyPath the attribute name
///
- (nonnull instancetype)initWithKeyPath:(NSString * _Nonnull)keyPath;
/// Provides a <code>CSSelectTerm</code> to a <code>CSSelect</code> clause for querying the average value of an attribute.
/// \code
/// NSNumber *averageAge = [CSCoreStore
///     queryValueFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     select:[CSSelect numberForTerm:[CSSelectTerm average:@"age" as:nil]]];
///
/// \endcode<ul>
///   <li>
///     <code>as</code>: the dictionary key to use to access the result. Ignored when the query return value is not an <code>NSDictionary</code>. If <code>nil</code>, the default key “average(<attributeName>)” is used
///   </li>
/// </ul>
/// \param keyPath the attribute name
///
///
/// returns:
/// a <code>CSSelectTerm</code> to a <code>CSSelect</code> clause for querying the average value of an attribute
+ (CSSelectTerm * _Nonnull)average:(NSString * _Nonnull)keyPath as:(NSString * _Nullable)alias SWIFT_WARN_UNUSED_RESULT;
/// Provides a <code>CSSelectTerm</code> to a <code>CSSelect</code> clause for a count query.
/// \code
/// NSNumber *numberOfEmployees = [CSCoreStore
///     queryValueFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     select:[CSSelect numberForTerm:[CSSelectTerm count:@"employeeID" as:nil]]];
///
/// \endcode\param keyPath the attribute name
///
/// \param alias the dictionary key to use to access the result. Ignored when the query return value is not an <code>NSDictionary</code>. If <code>nil</code>, the default key “count(<attributeName>)” is used
///
///
/// returns:
/// a <code>SelectTerm</code> to a <code>Select</code> clause for a count query
+ (CSSelectTerm * _Nonnull)count:(NSString * _Nonnull)keyPath as:(NSString * _Nullable)alias SWIFT_WARN_UNUSED_RESULT;
/// Provides a <code>CSSelectTerm</code> to a <code>CSSelect</code> clause for querying the maximum value for an attribute.
/// \code
/// NSNumber *maximumAge = [CSCoreStore
///     queryValueFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     select:[CSSelect numberForTerm:[CSSelectTerm maximum:@"age" as:nil]]];
///
/// \endcode\param keyPath the attribute name
///
/// \param alias the dictionary key to use to access the result. Ignored when the query return value is not an <code>NSDictionary</code>. If <code>nil</code>, the default key “max(<attributeName>)” is used
///
///
/// returns:
/// a <code>CSSelectTerm</code> to a <code>CSSelect</code> clause for querying the maximum value for an attribute
+ (CSSelectTerm * _Nonnull)maximum:(NSString * _Nonnull)keyPath as:(NSString * _Nullable)alias SWIFT_WARN_UNUSED_RESULT;
/// Provides a <code>CSSelectTerm</code> to a <code>CSSelect</code> clause for querying the minimum value for an attribute.
/// \code
/// NSNumber *minimumAge = [CSCoreStore
///     queryValueFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     select:[CSSelect numberForTerm:[CSSelectTerm minimum:@"age" as:nil]]];
///
/// \endcode\param keyPath the attribute name
///
/// \param alias the dictionary key to use to access the result. Ignored when the query return value is not an <code>NSDictionary</code>. If <code>nil</code>, the default key “min(<attributeName>)” is used
///
///
/// returns:
/// a <code>CSSelectTerm</code> to a <code>CSSelect</code> clause for querying the minimum value for an attribute
+ (CSSelectTerm * _Nonnull)minimum:(NSString * _Nonnull)keyPath as:(NSString * _Nullable)alias SWIFT_WARN_UNUSED_RESULT;
/// Provides a <code>CSSelectTerm</code> to a <code>CSSelect</code> clause for querying the sum value for an attribute.
/// \code
/// NSNumber *totalAge = [CSCoreStore
///     queryValueFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     select:[CSSelect numberForTerm:[CSSelectTerm sum:@"age" as:nil]]];
///
/// \endcode\param keyPath the attribute name
///
/// \param alias the dictionary key to use to access the result. Ignored when the query return value is not an <code>NSDictionary</code>. If <code>nil</code>, the default key “sum(<attributeName>)” is used
///
///
/// returns:
/// a <code>CSSelectTerm</code> to a <code>CSSelect</code> clause for querying the sum value for an attribute
+ (CSSelectTerm * _Nonnull)sum:(NSString * _Nonnull)keyPath as:(NSString * _Nullable)alias SWIFT_WARN_UNUSED_RESULT;
/// Provides a <code>CSSelectTerm</code> to a <code>CSSelect</code> clause for querying the <code>NSManagedObjectID</code>.
/// \code
/// NSManagedObjectID *objectID = [CSCoreStore
///     queryValueFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     select:[CSSelect objectIDForTerm:[CSSelectTerm objectIDAs:nil]]
///     fetchClauses:@[[CSWhere keyPath:@"employeeID" isEqualTo: @1111]]];
///
/// \endcode\param alias the dictionary key to use to access the result. Ignored when the query return value is not an <code>NSDictionary</code>. If <code>nil</code>, the default key “objecID” is used
///
///
/// returns:
/// a <code>SelectTerm</code> to a <code>Select</code> clause for querying the sum value for an attribute
+ (CSSelectTerm * _Nonnull)objectIDAs:(NSString * _Nullable)alias SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The <code>CSSetupResult</code> serves as the Objective-C bridging type for <code>SetupResult</code>.
/// seealso:
/// <code>SetupResult</code>
SWIFT_CLASS("_TtC9CoreStore13CSSetupResult") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSSetupResult : NSObject
/// <code>YES</code> if adding the <code>CSStorageInterface</code> to the <code>CSDataStack</code> succeeded, <code>NO</code> otherwise.
@property (nonatomic, readonly) BOOL isSuccess;
/// <code>YES</code> if adding the <code>CSStorageInterface</code> to the <code>CSDataStack</code> failed, <code>NO</code> otherwise. When <code>YES</code>, the <code>error</code> property returns the actual <code>NSError</code> for the failure.
@property (nonatomic, readonly) BOOL isFailure;
/// A <code>CSStorageInterface</code> instance if the <code>commit</code> operation for the transaction succeeded. Returns <code>nil</code> otherwise.
@property (nonatomic, readonly, strong) id <CSStorageInterface> _Nullable storage;
/// The <code>NSError</code> for a failed <code>commit</code> operation, or <code>nil</code> if the <code>commit</code> succeeded
@property (nonatomic, readonly, strong) NSError * _Nullable error;
/// If the result was a success, the <code>success</code> block is executed with the <code>CSStorageInterface</code> instance that was added to the <code>CSDataStack</code>. If the result was a failure, the <code>failure</code> block is executed with an <code>NSError</code> argument pertaining to the actual error.
/// The blocks are executed immediately as <code>@noescape</code> and will not be retained.
/// \param success the block to execute on success. The block passes a <code>CSStorageInterface</code> instance that was added to the <code>CSDataStack</code>.
///
/// \param failure the block to execute on failure. The block passes an <code>NSError</code> argument that pertains to the actual error.
///
- (void)handleSuccess:(SWIFT_NOESCAPE void (^ _Nonnull)(id <CSStorageInterface> _Nonnull))success failure:(SWIFT_NOESCAPE void (^ _Nonnull)(NSError * _Nonnull))failure;
/// If the result was a success, the <code>success</code> block is executed with a <code>BOOL</code> argument that indicates if there were any changes made. If the result was a failure, this method does nothing.
/// The block is executed immediately as <code>@noescape</code> and will not be retained.
/// \param success the block to execute on success. The block passes a <code>BOOL</code> argument that indicates if there were any changes made.
///
- (void)handleSuccess:(SWIFT_NOESCAPE void (^ _Nonnull)(id <CSStorageInterface> _Nonnull))success;
/// If the result was a failure, the <code>failure</code> block is executed with an <code>NSError</code> argument pertaining to the actual error. If the result was a success, this method does nothing.
/// The block is executed immediately as <code>@noescape</code> and will not be retained.
/// \param failure the block to execute on failure. The block passes an <code>NSError</code> argument that pertains to the actual error.
///
- (void)handleFailure:(SWIFT_NOESCAPE void (^ _Nonnull)(NSError * _Nonnull))failure;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



/// The <code>CSSynchronousDataTransaction</code> serves as the Objective-C bridging type for <code>SynchronousDataTransaction</code>.
/// seealso:
/// <code>SynchronousDataTransaction</code>
SWIFT_CLASS("_TtC9CoreStore28CSSynchronousDataTransaction") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSSynchronousDataTransaction : CSBaseDataTransaction
/// Saves the transaction changes and waits for completion synchronously. This method should not be used after the <code>-commitAndWaitWithError:</code> method was already called once.
/// \param error the <code>CSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// <code>YES</code> if the commit succeeded, <code>NO</code> if the commit failed. If <code>NO</code>, the <code>error</code> argument will hold error information.
- (BOOL)commitAndWaitWithError:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
/// Creates a new <code>NSManagedObject</code> with the specified entity type.
/// \param into the <code>CSInto</code> clause indicating the destination <code>NSManagedObject</code> entity type and the destination configuration
///
///
/// returns:
/// a new <code>NSManagedObject</code> instance of the specified entity type.
- (id _Nonnull)createInto:(CSInto * _Nonnull)into SWIFT_WARN_UNUSED_RESULT;
/// Returns an editable proxy of a specified <code>NSManagedObject</code>. This method should not be used after the <code>-commitAndWait</code> method was already called once.
/// \param object the <code>NSManagedObject</code> type to be edited
///
///
/// returns:
/// an editable proxy for the specified <code>NSManagedObject</code>.
- (id _Nullable)editObject:(NSManagedObject * _Nullable)object SWIFT_WARN_UNUSED_RESULT;
/// Returns an editable proxy of the object with the specified <code>NSManagedObjectID</code>. This method should not be used after the <code>-commitAndWait</code> method was already called once.
/// \param into a <code>CSInto</code> clause specifying the entity type
///
/// \param objectID the <code>NSManagedObjectID</code> for the object to be edited
///
///
/// returns:
/// an editable proxy for the specified <code>NSManagedObject</code>.
- (id _Nullable)editInto:(CSInto * _Nonnull)into objectID:(NSManagedObjectID * _Nonnull)objectID SWIFT_WARN_UNUSED_RESULT;
/// Deletes a specified <code>NSManagedObject</code>. This method should not be used after the <code>-commitAndWait</code> method was already called once.
/// \param object the <code>NSManagedObject</code> type to be deleted
///
- (void)deleteObject:(NSManagedObject * _Nullable)object;
/// Deletes the specified <code>NSManagedObject</code>s.
/// \param objects the <code>NSManagedObject</code>s to be deleted
///
- (void)deleteObjects:(NSArray<NSManagedObject *> * _Nonnull)objects;
@end


/// The <code>CSTweak</code> serves as the Objective-C bridging type for <code>Tweak</code>.
/// seealso:
/// <code>Tweak</code>
SWIFT_CLASS("_TtC9CoreStore7CSTweak") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSTweak : NSObject <CSDeleteClause, CSFetchClause, CSQueryClause>
/// The block to customize the <code>NSFetchRequest</code>
@property (nonatomic, readonly, copy) void (^ _Nonnull block)(NSFetchRequest<id <NSFetchRequestResult>> * _Nonnull);
/// Initializes a <code>CSTweak</code> clause with a closure where the <code>NSFetchRequest</code> may be configured.
/// important:
/// <code>CSTweak</code>’s closure is executed only just before the fetch occurs, so make sure that any values captured by the closure is not prone to race conditions. Also, some utilities (such as <code>CSListMonitor</code>s) may keep <code>CSFetchClause</code>s in memory and may thus introduce retain cycles if reference captures are not handled properly.
/// \param block the block to customize the <code>NSFetchRequest</code>
///
- (nonnull instancetype)initWithBlock:(void (^ _Nonnull)(NSFetchRequest<id <NSFetchRequestResult>> * _Nonnull))block;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (void)applyToFetchRequest:(NSFetchRequest<id <NSFetchRequestResult>> * _Nonnull)fetchRequest;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The <code>CSUnsafeDataModelSchema</code> serves as the Objective-C bridging type for <code>UnsafeDataModelSchema</code>.
/// seealso:
/// <code>UnsafeDataModelSchema</code>
SWIFT_CLASS("_TtC9CoreStore23CSUnsafeDataModelSchema") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSUnsafeDataModelSchema : NSObject <CSDynamicSchema>
/// Initializes a <code>CSUnsafeDataModelSchema</code> from an <code>NSManagedObjectModel</code>.
/// \param modelName the model version, typically the file name of an *.xcdatamodeld file (without the file extension)
///
/// \param model the <code>NSManagedObjectModel</code>
///
- (nonnull instancetype)initWithModelName:(NSString * _Nonnull)modelName model:(NSManagedObjectModel * _Nonnull)model OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
@property (nonatomic, readonly, copy) NSString * _Nonnull modelVersion;
- (NSManagedObjectModel * _Nonnull)rawModel SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class NSManagedObjectContext;

/// The <code>CSUnsafeDataTransaction</code> serves as the Objective-C bridging type for <code>UnsafeDataTransaction</code>.
/// seealso:
/// <code>UnsafeDataTransaction</code>
SWIFT_CLASS("_TtC9CoreStore23CSUnsafeDataTransaction") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSUnsafeDataTransaction : CSBaseDataTransaction
/// Saves the transaction changes asynchronously. For a <code>CSUnsafeDataTransaction</code>, multiple commits are allowed, although it is the developer’s responsibility to ensure a reasonable leeway to prevent blocking the main thread.
/// \param success the block executed if the save succeeds.
///
/// \param failure the block executed if the save fails. A <code>CSError</code> is reported as the argument of the block.
///
- (void)commitWithSuccess:(void (^ _Nullable)(void))success :(void (^ _Nullable)(CSError * _Nonnull))failure;
/// Saves the transaction changes and waits for completion synchronously. For a <code>CSUnsafeDataTransaction</code>, multiple commits are allowed, although it is the developer’s responsibility to ensure a reasonable leeway to prevent blocking the main thread.
/// \param error the <code>CSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// <code>YES</code> if the commit succeeded, <code>NO</code> if the commit failed. If <code>NO</code>, the <code>error</code> argument will hold error information.
- (BOOL)commitAndWaitWithError:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
/// Rolls back the transaction.
- (void)rollback;
/// Undo’s the last change made to the transaction.
- (void)undo;
/// Redo’s the last undone change to the transaction.
- (void)redo;
/// Immediately flushes all pending changes to the transaction’s observers. This is useful in conjunction with <code>ListMonitor</code>s and <code>ObjectMonitor</code>s created from <code>UnsafeDataTransaction</code>s used to manage temporary “scratch” data.
/// important:
/// Note that unlike <code>commit()</code>, <code>flush()</code> does not propagate/save updates to the <code>DataStack</code> and the persistent store. However, the flushed changes will be seen by children transactions created further from the current transaction (i.e. through <code>transaction.beginUnsafe()</code>)
- (void)flush;
/// Flushes all pending changes to the transaction’s observers at the end of the <code>closure</code>’s execution. This is useful in conjunction with <code>ListMonitor</code>s and <code>ObjectMonitor</code>s created from <code>UnsafeDataTransaction</code>s used to manage temporary “scratch” data.
/// important:
/// Note that unlike <code>commit()</code>, <code>flush()</code> does not propagate/save updates to the <code>DataStack</code> and the persistent store. However, the flushed changes will be seen by children transactions created further from the current transaction (i.e. through <code>transaction.beginUnsafe()</code>)
/// \param block the block where changes can be made prior to the flush
///
- (void)flush:(SWIFT_NOESCAPE void (^ _Nonnull)(void))block;
/// Begins a child transaction where <code>NSManagedObject</code> creates, updates, and deletes can be made. This is useful for making temporary changes, such as partially filled forms.
/// To support “undo” methods such as <code>-undo</code>, <code>-redo</code>, and <code>-rollback</code>, use the <code>-beginSafeWithSupportsUndo:</code> method passing <code>YES</code> to the argument. Without “undo” support, calling those methods will raise an exception.
///
/// returns:
/// a <code>CSUnsafeDataTransaction</code> instance where creates, updates, and deletes can be made.
- (CSUnsafeDataTransaction * _Nonnull)beginUnsafe SWIFT_WARN_UNUSED_RESULT;
/// Begins a child transaction where <code>NSManagedObject</code> creates, updates, and deletes can be made. This is useful for making temporary changes, such as partially filled forms.
/// <ul>
///   <li>
///     prameter supportsUndo: <code>-undo</code>, <code>-redo</code>, and <code>-rollback</code> methods are only available when this parameter is <code>YES</code>, otherwise those method will raise an exception. Note that turning on Undo support may heavily impact performance especially on iOS or watchOS where memory is limited.
///   </li>
/// </ul>
///
/// returns:
/// a <code>CSUnsafeDataTransaction</code> instance where creates, updates, and deletes can be made.
- (CSUnsafeDataTransaction * _Nonnull)beginUnsafeWithSupportsUndo:(BOOL)supportsUndo SWIFT_WARN_UNUSED_RESULT;
/// Returns the <code>NSManagedObjectContext</code> for this unsafe transaction. Use only for cases where external frameworks need an <code>NSManagedObjectContext</code> instance to work with.
/// Note that it is the developer’s responsibility to ensure the following:
/// <ul>
///   <li>
///     that the <code>CSUnsafeDataTransaction</code> that owns this context should be strongly referenced and prevented from being deallocated during the context’s lifetime
///   </li>
///   <li>
///     that all saves will be done either through the <code>CSUnsafeDataTransaction</code>’s <code>-commit:</code> or <code>-commitAndWait</code> method, or by calling <code>-save:</code> manually on the context, its parent, and all other ancestor contexts if there are any.
///   </li>
/// </ul>
- (NSManagedObjectContext * _Nonnull)unsafeContext SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
@end

@class NSPredicate;
@protocol CoreDataNativeType;

/// The <code>CSWhere</code> serves as the Objective-C bridging type for <code>Where</code>.
/// seealso:
/// <code>Where</code>
SWIFT_CLASS("_TtC9CoreStore7CSWhere")
@interface CSWhere : NSObject <CSDeleteClause, CSFetchClause, CSQueryClause>
/// The internal <code>NSPredicate</code> instance for the <code>Where</code> clause
@property (nonatomic, readonly, strong) NSPredicate * _Nonnull predicate;
/// Initializes a <code>CSWhere</code> clause with a predicate that always evaluates to the specified boolean value
/// \code
/// MyPersonEntity *people = [transaction
///    fetchAllFrom:CSFromClass([MyPersonEntity class])
///    fetchClauses:@[CSWhereValue(YES)]]];
///
/// \endcode\param value the boolean value for the predicate
///
- (nonnull instancetype)initWithValue:(BOOL)value;
/// Initializes a <code>CSWhere</code> clause with a predicate using the specified string format and arguments
/// \code
/// NSPredicate *predicate = // ...
/// MyPersonEntity *people = [transaction
///    fetchAllFrom:CSFromClass([MyPersonEntity class])
///    fetchClauses:@[CSWherePredicate(predicate)]];
///
/// \endcode\param format the format string for the predicate
///
/// \param argumentArray the arguments for <code>format</code>
///
- (nonnull instancetype)initWithFormat:(NSString * _Nonnull)format argumentArray:(NSArray<NSObject *> * _Nullable)argumentArray;
/// Initializes a <code>CSWhere</code> clause that compares equality
/// \param keyPath the keyPath to compare with
///
/// \param value the arguments for the <code>==</code> operator
///
- (nonnull instancetype)initWithKeyPath:(NSString * _Nonnull)keyPath isEqualTo:(id <CoreDataNativeType> _Nullable)value;
/// Initializes a <code>CSWhere</code> clause that compares membership
/// \param keyPath the keyPath to compare with
///
/// \param list the array to check membership of
///
- (nonnull instancetype)initWithKeyPath:(NSString * _Nonnull)keyPath isMemberOf:(NSArray<id <CoreDataNativeType>> * _Nonnull)list;
/// Initializes a <code>CSWhere</code> clause with an <code>NSPredicate</code>
/// \param predicate the <code>NSPredicate</code> for the fetch or query
///
- (nonnull instancetype)initWithPredicate:(NSPredicate * _Nonnull)predicate;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (void)applyToFetchRequest:(NSFetchRequest<id <NSFetchRequestResult>> * _Nonnull)fetchRequest;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The <code>CSXcodeDataModelSchema</code> serves as the Objective-C bridging type for <code>XcodeDataModelSchema</code>.
/// seealso:
/// <code>XcodeDataModelSchema</code>
SWIFT_CLASS("_TtC9CoreStore22CSXcodeDataModelSchema") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSXcodeDataModelSchema : NSObject <CSDynamicSchema>
/// Initializes an <code>CSXcodeDataModelSchema</code> from an *.xcdatamodeld file URL.
/// \param modelName the model version, typically the file name of an *.xcdatamodeld file (without the file extension)
///
/// \param modelVersionFileURL the file URL that points to the .xcdatamodeld’s “momd” file.
///
- (nonnull instancetype)initWithModelName:(NSString * _Nonnull)modelName modelVersionFileURL:(NSURL * _Nonnull)modelVersionFileURL OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
@property (nonatomic, readonly, copy) NSString * _Nonnull modelVersion;
- (NSManagedObjectModel * _Nonnull)rawModel SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Objective-C Foundation types that are natively supported by Core Data managed attributes all conform to <code>CoreDataNativeType</code>.
SWIFT_PROTOCOL("_TtP9CoreStore18CoreDataNativeType_")
@protocol CoreDataNativeType <NSObject>
@end


SWIFT_CLASS("_TtC9CoreStore22CoreStoreManagedObject")
@interface CoreStoreManagedObject : NSManagedObject
- (nonnull instancetype)initWithEntity:(NSEntityDescription * _Nonnull)entity insertIntoManagedObjectContext:(NSManagedObjectContext * _Nullable)context OBJC_DESIGNATED_INITIALIZER;
@end






@interface NSData (SWIFT_EXTENSION(CoreStore)) <CoreDataNativeType>
@end










@interface NSDate (SWIFT_EXTENSION(CoreStore)) <CoreDataNativeType>
@end








@interface NSDecimalNumber (SWIFT_EXTENSION(CoreStore))
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSAttributeType cs_rawAttributeType;)
+ (NSAttributeType)cs_rawAttributeType SWIFT_WARN_UNUSED_RESULT;
@end














@interface NSManagedObject (SWIFT_EXTENSION(CoreStore)) <CoreDataNativeType>
@end












@interface NSManagedObject (SWIFT_EXTENSION(CoreStore))
/// Provides a convenience wrapper for accessing <code>-primitiveValueForKey:</code> with proper calls to <code>-willAccessValueForKey:</code> and <code>-didAccessValueForKey:</code>. This is useful when implementing accessor methods for transient attributes.
/// \param KVCKey the KVC key
///
///
/// returns:
/// the primitive value for the KVC key
- (id _Nullable)cs_accessValueForKVCKey:(NSString * _Nonnull)KVCKey SWIFT_WARN_UNUSED_RESULT;
/// Provides a convenience wrapper for setting <code>-setPrimitiveValue:</code> with proper calls to <code>-willChangeValueForKey:</code> and <code>-didChangeValueForKey:</code>. This is useful when implementing mutator methods for transient attributes.
/// \param value the value to set the KVC key with
///
/// \param KVCKey the KVC key
///
- (void)cs_setValue:(id _Nullable)value forKVCKey:(NSString * _Nonnull)KVCKey;
/// Re-faults the object to use the latest values from the persistent store
- (void)cs_refreshAsFault;
@end






















@interface NSManagedObjectID (SWIFT_EXTENSION(CoreStore)) <CoreDataNativeType>
@end












@interface NSNull (SWIFT_EXTENSION(CoreStore)) <CoreDataNativeType>
@end






@interface NSNumber (SWIFT_EXTENSION(CoreStore)) <CoreDataNativeType>
@end






@interface NSNumber (SWIFT_EXTENSION(CoreStore))
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSAttributeType cs_rawAttributeType;)
+ (NSAttributeType)cs_rawAttributeType SWIFT_WARN_UNUSED_RESULT;
@end






@interface NSOrderedSet<ObjectType> (SWIFT_EXTENSION(CoreStore)) <CoreDataNativeType>
@end














@interface NSSet<ObjectType> (SWIFT_EXTENSION(CoreStore)) <CoreDataNativeType>
@end










@interface NSString (SWIFT_EXTENSION(CoreStore)) <CoreDataNativeType>
@end




























@interface NSProgress (SWIFT_EXTENSION(CoreStore))
/// Sets a closure that the <code>NSProgress</code> calls whenever its <code>fractionCompleted</code> changes. You can use this instead of setting up KVO.
/// \param closure the closure to execute on progress change
///
- (void)cs_setProgressHandler:(void (^ _Nullable)(NSProgress * _Nonnull))closure;
@end



#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop

#elif defined(__ARM_ARCH_7A__) && __ARM_ARCH_7A__
// Generated by Apple Swift version 5.1.3 (swiftlang-1100.0.282.1 clang-1100.0.33.15)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if !defined(IBSegueAction)
# define IBSegueAction
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import CoreData;
@import Foundation;
@import ObjectiveC;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="CoreStore",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif



@class CSInto;
@class NSManagedObject;
@class NSManagedObjectID;

/// The <code>CSBaseDataTransaction</code> serves as the Objective-C bridging type for <code>BaseDataTransaction</code>.
/// seealso:
/// <code>BaseDataTransaction</code>
SWIFT_CLASS("_TtC9CoreStore21CSBaseDataTransaction")
@interface CSBaseDataTransaction : NSObject
/// Indicates if the transaction has pending changes
@property (nonatomic, readonly) BOOL hasChanges;
/// Creates a new <code>NSManagedObject</code> with the specified entity type.
/// \param into the <code>CSInto</code> clause indicating the destination <code>NSManagedObject</code> entity type and the destination configuration
///
///
/// returns:
/// a new <code>NSManagedObject</code> instance of the specified entity type.
- (id _Nonnull)createInto:(CSInto * _Nonnull)into SWIFT_WARN_UNUSED_RESULT;
/// Returns an editable proxy of a specified <code>NSManagedObject</code>.
/// \param object the <code>NSManagedObject</code> type to be edited
///
///
/// returns:
/// an editable proxy for the specified <code>NSManagedObject</code>.
- (id _Nullable)editObject:(NSManagedObject * _Nullable)object SWIFT_WARN_UNUSED_RESULT;
/// Returns an editable proxy of the object with the specified <code>NSManagedObjectID</code>.
/// \param into a <code>CSInto</code> clause specifying the entity type
///
/// \param objectID the <code>NSManagedObjectID</code> for the object to be edited
///
///
/// returns:
/// an editable proxy for the specified <code>NSManagedObject</code>.
- (id _Nullable)editInto:(CSInto * _Nonnull)into objectID:(NSManagedObjectID * _Nonnull)objectID SWIFT_WARN_UNUSED_RESULT;
/// Deletes a specified <code>NSManagedObject</code>.
/// \param object the <code>NSManagedObject</code> to be deleted
///
- (void)deleteObject:(NSManagedObject * _Nullable)object;
/// Deletes the specified <code>NSManagedObject</code>s.
/// \param objects the <code>NSManagedObject</code>s to be deleted
///
- (void)deleteObjects:(NSArray<NSManagedObject *> * _Nonnull)objects;
/// Refreshes all registered objects <code>NSManagedObject</code>s in the transaction.
- (void)refreshAndMergeAllObjects;
/// Returns all pending <code>NSManagedObject</code>s of the specified type that were inserted to the transaction. This method should not be called after the <code>-commit*:</code> method was called.
/// \param entity the <code>NSManagedObject</code> subclass to filter
///
///
/// returns:
/// an <code>NSSet</code> of pending <code>NSManagedObject</code>s of the specified type that were inserted to the transaction.
- (NSSet<NSManagedObject *> * _Nonnull)insertedObjectsOfType:(SWIFT_METATYPE(NSManagedObject) _Nonnull)entity SWIFT_WARN_UNUSED_RESULT;
/// Returns all pending <code>NSManagedObjectID</code>s that were inserted to the transaction. This method should not be called after the <code>-commit*:</code> method was called.
///
/// returns:
/// an <code>NSSet</code> of pending <code>NSManagedObjectID</code>s that were inserted to the transaction.
- (NSSet<NSManagedObjectID *> * _Nonnull)insertedObjectIDs SWIFT_WARN_UNUSED_RESULT;
/// Returns all pending <code>NSManagedObjectID</code>s of the specified type that were inserted to the transaction. This method should not be called after the <code>-commit*:</code> method was called.
/// \param entity the <code>NSManagedObject</code> subclass to filter
///
///
/// returns:
/// an <code>NSSet</code> of pending <code>NSManagedObjectID</code>s of the specified type that were inserted to the transaction.
- (NSSet<NSManagedObjectID *> * _Nonnull)insertedObjectIDsOfType:(SWIFT_METATYPE(NSManagedObject) _Nonnull)entity SWIFT_WARN_UNUSED_RESULT;
/// Returns all pending <code>NSManagedObject</code>s of the specified type that were updated in the transaction. This method should not be called after the <code>-commit*:</code> method was called.
/// \param entity the <code>NSManagedObject</code> subclass to filter
///
///
/// returns:
/// an <code>NSSet</code> of pending <code>NSManagedObject</code>s of the specified type that were updated in the transaction.
- (NSSet<NSManagedObject *> * _Nonnull)updatedObjectsOfType:(SWIFT_METATYPE(NSManagedObject) _Nonnull)entity SWIFT_WARN_UNUSED_RESULT;
/// Returns all pending <code>NSManagedObjectID</code>s that were updated in the transaction. This method should not be called after the <code>-commit*:</code> method was called.
///
/// returns:
/// an <code>NSSet</code> of pending <code>NSManagedObjectID</code>s that were updated in the transaction.
- (NSSet<NSManagedObjectID *> * _Nonnull)updatedObjectIDs SWIFT_WARN_UNUSED_RESULT;
/// Returns all pending <code>NSManagedObjectID</code>s of the specified type that were updated in the transaction. This method should not be called after the <code>-commit*:</code> method was called.
/// \param entity the <code>NSManagedObject</code> subclass to filter
///
///
/// returns:
/// an <code>NSSet</code> of pending <code>NSManagedObjectID</code>s of the specified type that were updated in the transaction.
- (NSSet<NSManagedObjectID *> * _Nonnull)updatedObjectIDsOfType:(SWIFT_METATYPE(NSManagedObject) _Nonnull)entity SWIFT_WARN_UNUSED_RESULT;
/// Returns all pending <code>NSManagedObject</code>s of the specified type that were deleted from the transaction. This method should not be called after the <code>-commit*:</code> method was called.
/// \param entity the <code>NSManagedObject</code> subclass to filter
///
///
/// returns:
/// an <code>NSSet</code> of pending <code>NSManagedObject</code>s of the specified type that were deleted from the transaction.
- (NSSet<NSManagedObject *> * _Nonnull)deletedObjectsOfType:(SWIFT_METATYPE(NSManagedObject) _Nonnull)entity SWIFT_WARN_UNUSED_RESULT;
/// Returns all pending <code>NSManagedObjectID</code>s of the specified type that were deleted from the transaction. This method should not be called after the <code>-commit*:</code> method was called.
///
/// returns:
/// an <code>NSSet</code> of pending <code>NSManagedObjectID</code>s of the specified type that were deleted from the transaction.
- (NSSet<NSManagedObjectID *> * _Nonnull)deletedObjectIDs SWIFT_WARN_UNUSED_RESULT;
/// Returns all pending <code>NSManagedObjectID</code>s of the specified type that were deleted from the transaction. This method should not be called after the <code>-commit*:</code> method was called.
/// \param entity the <code>NSManagedObject</code> subclass to filter
///
///
/// returns:
/// a <code>Set</code> of pending <code>NSManagedObjectID</code>s of the specified type that were deleted from the transaction.
- (NSSet<NSManagedObjectID *> * _Nonnull)deletedObjectIDsOfType:(SWIFT_METATYPE(NSManagedObject) _Nonnull)entity SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class CSError;

/// The <code>CSAsynchronousDataTransaction</code> serves as the Objective-C bridging type for <code>AsynchronousDataTransaction</code>.
/// seealso:
/// <code>AsynchronousDataTransaction</code>
SWIFT_CLASS("_TtC9CoreStore29CSAsynchronousDataTransaction") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSAsynchronousDataTransaction : CSBaseDataTransaction
/// Saves the transaction changes. This method should not be used after the <code>-commitWithCompletion:</code> method was already called once.
/// \param success the block executed if the save succeeds.
///
/// \param failure the block executed if the save fails. A <code>CSError</code> is reported as the argument of the block.
///
- (void)commitWithSuccess:(void (^ _Nullable)(void))success failure:(void (^ _Nullable)(CSError * _Nonnull))failure;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
/// Creates a new <code>NSManagedObject</code> with the specified entity type.
/// \param into the <code>CSInto</code> clause indicating the destination <code>NSManagedObject</code> entity type and the destination configuration
///
///
/// returns:
/// a new <code>NSManagedObject</code> instance of the specified entity type.
- (id _Nonnull)createInto:(CSInto * _Nonnull)into SWIFT_WARN_UNUSED_RESULT;
/// Returns an editable proxy of a specified <code>NSManagedObject</code>. This method should not be used after the <code>-commitWithCompletion:</code> method was already called once.
/// \param object the <code>NSManagedObject</code> type to be edited
///
///
/// returns:
/// an editable proxy for the specified <code>NSManagedObject</code>.
- (id _Nullable)editObject:(NSManagedObject * _Nullable)object SWIFT_WARN_UNUSED_RESULT;
/// Returns an editable proxy of the object with the specified <code>NSManagedObjectID</code>. This method should not be used after the <code>-commitWithCompletion:</code> method was already called once.
/// \param into a <code>CSInto</code> clause specifying the entity type
///
/// \param objectID the <code>NSManagedObjectID</code> for the object to be edited
///
///
/// returns:
/// an editable proxy for the specified <code>NSManagedObject</code>.
- (id _Nullable)editInto:(CSInto * _Nonnull)into objectID:(NSManagedObjectID * _Nonnull)objectID SWIFT_WARN_UNUSED_RESULT;
/// Deletes a specified <code>NSManagedObject</code>. This method should not be used after the <code>-commitWithCompletion:</code> method was already called once.
/// \param object the <code>NSManagedObject</code> type to be deleted
///
- (void)deleteObject:(NSManagedObject * _Nullable)object;
/// Deletes the specified <code>NSManagedObject</code>s.
/// \param objects the <code>NSManagedObject</code>s type to be deleted
///
- (void)deleteObjects:(NSArray<NSManagedObject *> * _Nonnull)objects;
@end


@class CSFrom;
@protocol CSFetchClause;
@class NSNumber;
@class CSSelect;
@protocol CSQueryClause;

@interface CSBaseDataTransaction (SWIFT_EXTENSION(CoreStore))
/// Fetches the <code>NSManagedObject</code> instance in the transaction’s context from a reference created from a transaction or from a different managed object context.
/// \param object a reference to the object created/fetched outside the transaction
///
///
/// returns:
/// the <code>NSManagedObject</code> instance if the object exists in the transaction, or <code>nil</code> if not found.
- (id _Nullable)fetchExistingObject:(NSManagedObject * _Nonnull)object SWIFT_WARN_UNUSED_RESULT;
/// Fetches the <code>NSManagedObject</code> instance in the transaction’s context from an <code>NSManagedObjectID</code>.
/// \param objectID the <code>NSManagedObjectID</code> for the object
///
///
/// returns:
/// the <code>NSManagedObject</code> instance if the object exists in the transaction, or <code>nil</code> if not found.
- (id _Nullable)fetchExistingObjectWithID:(NSManagedObjectID * _Nonnull)objectID SWIFT_WARN_UNUSED_RESULT;
/// Fetches the <code>NSManagedObject</code> instances in the transaction’s context from references created from a transaction or from a different managed object context.
/// \param objects an array of <code>NSManagedObject</code>s created/fetched outside the transaction
///
///
/// returns:
/// the <code>NSManagedObject</code> array for objects that exists in the transaction
- (NSArray * _Nonnull)fetchExistingObjects:(NSArray<NSManagedObject *> * _Nonnull)objects SWIFT_WARN_UNUSED_RESULT;
/// Fetches the <code>NSManagedObject</code> instances in the transaction’s context from a list of <code>NSManagedObjectID</code>.
/// \param objectIDs the <code>NSManagedObjectID</code> array for the objects
///
///
/// returns:
/// the <code>NSManagedObject</code> array for objects that exists in the transaction
- (NSArray * _Nonnull)fetchExistingObjectsWithIDs:(NSArray<NSManagedObjectID *> * _Nonnull)objectIDs SWIFT_WARN_UNUSED_RESULT;
/// Fetches the first <code>NSManagedObject</code> instance that satisfies the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>From</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the first <code>NSManagedObject</code> instance that satisfies the specified <code>CSFetchClause</code>s
- (id _Nullable)fetchOneFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Fetches all <code>NSManagedObject</code> instances that satisfy the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// all <code>NSManagedObject</code> instances that satisfy the specified <code>CSFetchClause</code>s
- (NSArray * _Nullable)fetchAllFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Fetches the number of <code>NSManagedObject</code>s that satisfy the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the number <code>NSManagedObject</code>s that satisfy the specified <code>CSFetchClause</code>s
- (NSNumber * _Nullable)fetchCountFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Fetches the <code>NSManagedObjectID</code> for the first <code>NSManagedObject</code> that satisfies the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the <code>NSManagedObjectID</code> for the first <code>NSManagedObject</code> that satisfies the specified <code>CSFetchClause</code>s
- (NSManagedObjectID * _Nullable)fetchObjectIDFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Queries aggregate values as specified by the <code>CSQueryClause</code>s. Requires at least a <code>CSSelect</code> clause, and optional <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
/// A “query” differs from a “fetch” in that it only retrieves values already stored in the persistent store. As such, values from unsaved transactions or contexts will not be incorporated in the query result.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param selectClause a <code>CSSelect</code> clause indicating the properties to fetch, and with the generic type indicating the return type.
///
/// \param queryClauses a series of <code>CSQueryClause</code> instances for the query request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the result of the the query. The type of the return value is specified by the generic type of the <code>CSSelect</code> parameter.
- (id _Nullable)queryValueFrom:(CSFrom * _Nonnull)from selectClause:(CSSelect * _Nonnull)selectClause queryClauses:(NSArray<id <CSQueryClause>> * _Nonnull)queryClauses SWIFT_WARN_UNUSED_RESULT;
/// Queries a dictionary of attribute values as specified by the <code>CSQueryClause</code>s. Requires at least a <code>CSSelect</code> clause, and optional <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
/// A “query” differs from a “fetch” in that it only retrieves values already stored in the persistent store. As such, values from unsaved transactions or contexts will not be incorporated in the query result.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param selectClause a <code>CSSelect</code> clause indicating the properties to fetch, and with the generic type indicating the return type.
///
/// \param queryClauses a series of <code>CSQueryClause</code> instances for the query request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the result of the the query. The type of the return value is specified by the generic type of the <code>CSSelect</code> parameter.
- (NSArray<NSDictionary<NSString *, id> *> * _Nullable)queryAttributesFrom:(CSFrom * _Nonnull)from selectClause:(CSSelect * _Nonnull)selectClause queryClauses:(NSArray<id <CSQueryClause>> * _Nonnull)queryClauses SWIFT_WARN_UNUSED_RESULT;
@end

@class CSDataStack;

/// The <code>CSCoreStore</code> serves as the Objective-C bridging type for <code>CoreStore</code>.
/// seealso:
/// <code>CoreStore</code>
SWIFT_CLASS("_TtC9CoreStore11CSCoreStore") SWIFT_DEPRECATED_MSG("Call methods directly from the CSDataStack instead")
@interface CSCoreStore : NSObject
/// The default <code>CSDataStack</code> instance to be used. If <code>defaultStack</code> is not set before the first time accessed, a default-configured <code>CSDataStack</code> will be created.
/// seealso:
/// <code>CSDataStack</code>
/// note:
/// Changing the <code>defaultStack</code> is thread safe, but it is recommended to setup <code>CSDataStacks</code> on a common queue (e.g. the main queue).
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) CSDataStack * _Nonnull defaultStack;)
+ (CSDataStack * _Nonnull)defaultStack SWIFT_WARN_UNUSED_RESULT;
+ (void)setDefaultStack:(CSDataStack * _Nonnull)newValue;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class CSSQLiteStore;
@class CSMigrationResult;
@class NSError;
@class NSProgress;
@class CSMigrationType;

SWIFT_DEPRECATED_MSG("Call methods directly from the CSDataStack instead")
@interface CSCoreStore (SWIFT_EXTENSION(CoreStore))
/// Migrates a <code>CSSQLiteStore</code> to match the <code>defaultStack</code>’s managed object model version. This method does NOT add the migrated store to the data stack.
/// \param storage the <code>CSSQLiteStore</code> instance
///
/// \param completion the closure to be executed on the main queue when the migration completes, either due to success or failure. The closure’s <code>CSMigrationResult</code> argument indicates the result. This closure is NOT executed if an error is thrown, but will be executed with a failure <code>CSSetupResult</code> result if an error occurs asynchronously.
///
/// \param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// an <code>NSProgress</code> instance if a migration has started. <code>nil</code> if no migrations are required or if <code>error</code> was set.
+ (NSProgress * _Nullable)upgradeStorageIfNeeded:(CSSQLiteStore * _Nonnull)storage completion:(void (^ _Nonnull)(CSMigrationResult * _Nonnull))completion error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
/// Checks the migration steps required for the <code>CSSQLiteStore</code> to match the <code>defaultStack</code>’s managed object model version.
/// \param storage the <code>CSSQLiteStore</code> instance
///
/// \param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// a <code>CSMigrationType</code> array indicating the migration steps required for the store, or an empty array if the file does not exist yet. Otherwise, <code>nil</code> is returned and the <code>error</code> argument is set if either inspection of the store failed, or if no mapping model was found/inferred.
+ (NSArray<CSMigrationType *> * _Nullable)requiredMigrationsForSQLiteStore:(CSSQLiteStore * _Nonnull)storage error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
@end

@class CSObjectMonitor;
@class CSListMonitor;
@class CSSectionBy;

SWIFT_AVAILABILITY(macos,introduced=10.12) SWIFT_DEPRECATED_MSG("Call methods directly from the CSDataStack instead")
@interface CSCoreStore (SWIFT_EXTENSION(CoreStore))
/// Using the <code>defaultStack</code>, creates an <code>CSObjectMonitor</code> for the specified <code>NSManagedObject</code>. Multiple <code>CSObjectObserver</code>s may then register themselves to be notified when changes are made to the <code>NSManagedObject</code>.
/// \param object the <code>NSManagedObject</code> to observe changes from
///
///
/// returns:
/// a <code>CSObjectMonitor</code> that monitors changes to <code>object</code>
+ (CSObjectMonitor * _Nonnull)monitorObject:(NSManagedObject * _Nonnull)object SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, creates a <code>CSListMonitor</code> for a list of <code>NSManagedObject</code>s that satisfy the specified fetch clauses. Multiple <code>CSListObserver</code>s may then register themselves to be notified when changes are made to the list.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for fetching the object list. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// a <code>CSListMonitor</code> instance that monitors changes to the list
+ (CSListMonitor * _Nonnull)monitorListFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, asynchronously creates a <code>CSListMonitor</code> for a list of <code>NSManagedObject</code>s that satisfy the specified fetch clauses. Multiple <code>CSListObserver</code>s may then register themselves to be notified when changes are made to the list. Since <code>NSFetchedResultsController</code> greedily locks the persistent store on initial fetch, you may prefer this method instead of the synchronous counterpart to avoid deadlocks while background updates/saves are being executed.
/// \param createAsynchronously the closure that receives the created <code>CSListMonitor</code> instance
///
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for fetching the object list. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
+ (void)monitorListByCreatingAsynchronously:(void (^ _Nonnull)(CSListMonitor * _Nonnull))createAsynchronously from:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses;
/// Using the <code>defaultStack</code>, creates a <code>CSListMonitor</code> for a sectioned list of <code>NSManagedObject</code>s that satisfy the specified fetch clauses. Multiple <code>CSListObserver</code>s may then register themselves to be notified when changes are made to the list.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param sectionBy a <code>CSSectionBy</code> clause indicating the keyPath for the attribute to use when sorting the list into sections.
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for fetching the object list. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// a <code>CSListMonitor</code> instance that monitors changes to the list
+ (CSListMonitor * _Nonnull)monitorSectionedListFrom:(CSFrom * _Nonnull)from sectionBy:(CSSectionBy * _Nonnull)sectionBy fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, asynchronously creates a <code>CSListMonitor</code> for a sectioned list of <code>NSManagedObject</code>s that satisfy the specified fetch clauses. Multiple <code>CSListObserver</code>s may then register themselves to be notified when changes are made to the list. Since <code>NSFetchedResultsController</code> greedily locks the persistent store on initial fetch, you may prefer this method instead of the synchronous counterpart to avoid deadlocks while background updates/saves are being executed.
/// \param createAsynchronously the closure that receives the created <code>CSListMonitor</code> instance
///
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param sectionBy a <code>CSSectionBy</code> clause indicating the keyPath for the attribute to use when sorting the list into sections.
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for fetching the object list. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
+ (void)monitorSectionedListByCreatingAsynchronously:(void (^ _Nonnull)(CSListMonitor * _Nonnull))createAsynchronously from:(CSFrom * _Nonnull)from sectionBy:(CSSectionBy * _Nonnull)sectionBy fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses;
@end

@class CSSynchronousDataTransaction;
@class CSUnsafeDataTransaction;

SWIFT_DEPRECATED_MSG("Call methods directly from the CSDataStack instead")
@interface CSCoreStore (SWIFT_EXTENSION(CoreStore))
/// Using the <code>defaultStack</code>, begins a transaction asynchronously where <code>NSManagedObject</code> creates, updates, and deletes can be made.
/// \param closure the block where creates, updates, and deletes can be made to the transaction. Transaction blocks are executed serially in a background queue, and all changes are made from a concurrent <code>NSManagedObjectContext</code>.
///
+ (void)beginAsynchronous:(void (^ _Nonnull)(CSAsynchronousDataTransaction * _Nonnull))closure;
/// Using the <code>defaultStack</code>, begins a transaction synchronously where <code>NSManagedObject</code> creates, updates, and deletes can be made.
/// \param closure the block where creates, updates, and deletes can be made to the transaction. Transaction blocks are executed serially in a background queue, and all changes are made from a concurrent <code>NSManagedObjectContext</code>.
///
///
/// returns:
/// <code>YES</code> if the commit succeeded, <code>NO</code> if the commit failed. If <code>NO</code>, the <code>error</code> argument will hold error information.
+ (BOOL)beginSynchronous:(void (^ _Nonnull)(CSSynchronousDataTransaction * _Nonnull))closure error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, begins a child transaction where <code>NSManagedObject</code> creates, updates, and deletes can be made. This is useful for making temporary changes, such as partially filled forms.
/// To support “undo” methods such as <code>-undo</code>, <code>-redo</code>, and <code>-rollback</code>, use the <code>-beginSafeWithSupportsUndo:</code> method passing <code>YES</code> to the argument. Without “undo” support, calling those methods will raise an exception.
///
/// returns:
/// a <code>CSUnsafeDataTransaction</code> instance where creates, updates, and deletes can be made.
+ (CSUnsafeDataTransaction * _Nonnull)beginUnsafe SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, begins a child transaction where <code>NSManagedObject</code> creates, updates, and deletes can be made. This is useful for making temporary changes, such as partially filled forms.
/// <ul>
///   <li>
///     prameter supportsUndo: <code>-undo</code>, <code>-redo</code>, and <code>-rollback</code> methods are only available when this parameter is <code>YES</code>, otherwise those method will raise an exception. Note that turning on Undo support may heavily impact performance especially on iOS or watchOS where memory is limited.
///   </li>
/// </ul>
///
/// returns:
/// a <code>CSUnsafeDataTransaction</code> instance where creates, updates, and deletes can be made.
+ (CSUnsafeDataTransaction * _Nonnull)beginUnsafeWithSupportsUndo:(BOOL)supportsUndo SWIFT_WARN_UNUSED_RESULT;
/// Refreshes all registered objects <code>NSManagedObject</code>s in the <code>defaultStack</code>.
+ (void)refreshAndMergeAllObjects;
@end

@class NSEntityDescription;
@class CSInMemoryStore;

SWIFT_DEPRECATED_MSG("Call methods directly from the CSDataStack instead")
@interface CSCoreStore (SWIFT_EXTENSION(CoreStore))
/// Returns the <code>defaultStack</code>’s model version. The version string is the same as the name of the version-specific .xcdatamodeld file.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull modelVersion;)
+ (NSString * _Nonnull)modelVersion SWIFT_WARN_UNUSED_RESULT;
/// Returns the entity name-to-class type mapping from the <code>defaultStack</code>’s model.
+ (NSDictionary<NSString *, SWIFT_METATYPE(NSManagedObject)> * _Nonnull)entityTypesByNameForType:(SWIFT_METATYPE(NSManagedObject) _Nonnull)type SWIFT_WARN_UNUSED_RESULT;
/// Returns the <code>NSEntityDescription</code> for the specified <code>NSManagedObject</code> subclass from <code>defaultStack</code>’s model.
+ (NSEntityDescription * _Nullable)entityDescriptionForClass:(SWIFT_METATYPE(NSManagedObject) _Nonnull)type SWIFT_WARN_UNUSED_RESULT;
/// Creates an <code>CSInMemoryStore</code> with default parameters and adds it to the <code>defaultStack</code>. This method blocks until completion.
/// \code
/// CSSQLiteStore *storage = [CSCoreStore addInMemoryStorageAndWaitAndReturnError:&error];
///
/// \endcode\param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// the <code>CSInMemoryStore</code> added to the <code>defaultStack</code>
+ (CSInMemoryStore * _Nullable)addInMemoryStorageAndWaitAndReturnError:(NSError * _Nullable * _Nullable)error;
/// Creates an <code>CSSQLiteStore</code> with default parameters and adds it to the <code>defaultStack</code>. This method blocks until completion.
/// \code
/// CSSQLiteStore *storage = [CSCoreStore addSQLiteStorageAndWaitAndReturnError:&error];
///
/// \endcode\param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// the <code>CSSQLiteStore</code> added to the <code>defaultStack</code>
+ (CSSQLiteStore * _Nullable)addSQLiteStorageAndWaitAndReturnError:(NSError * _Nullable * _Nullable)error;
/// Adds a <code>CSInMemoryStore</code> to the <code>defaultStack</code> and blocks until completion.
/// \code
/// NSError *error;
/// CSInMemoryStore *storage = [CSCoreStore
///     addStorageAndWait: [[CSInMemoryStore alloc] initWithConfiguration: @"Config1"]
///     error: &error];
///
/// \endcode\param storage the <code>CSInMemoryStore</code>
///
/// \param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// the <code>CSInMemoryStore</code> added to the <code>defaultStack</code>
+ (CSInMemoryStore * _Nullable)addInMemoryStorageAndWait:(CSInMemoryStore * _Nonnull)storage error:(NSError * _Nullable * _Nullable)error;
/// Adds a <code>CSSQLiteStore</code> to the <code>defaultStack</code> and blocks until completion.
/// \code
/// NSError *error;
/// CSSQLiteStore *storage = [CSCoreStore
///     addStorageAndWait: [[CSSQLiteStore alloc] initWithConfiguration: @"Config1"]
///     error: &error];
///
/// \endcode\param storage the <code>CSSQLiteStore</code>
///
/// \param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// the <code>CSSQLiteStore</code> added to the <code>defaultStack</code>
+ (CSSQLiteStore * _Nullable)addSQLiteStorageAndWait:(CSSQLiteStore * _Nonnull)storage error:(NSError * _Nullable * _Nullable)error;
@end


SWIFT_DEPRECATED_MSG("Call methods directly from the DataStack instead")
@interface CSCoreStore (SWIFT_EXTENSION(CoreStore))
/// Using the <code>defaultStack</code>, fetches the <code>NSManagedObject</code> instance in the transaction’s context from a reference created from a transaction or from a different managed object context.
/// \param object a reference to the object created/fetched outside the transaction
///
///
/// returns:
/// the <code>NSManagedObject</code> instance if the object exists in the transaction, or <code>nil</code> if not found.
+ (id _Nullable)fetchExistingObject:(NSManagedObject * _Nonnull)object SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, fetches the <code>NSManagedObject</code> instance in the transaction’s context from an <code>NSManagedObjectID</code>.
/// \param objectID the <code>NSManagedObjectID</code> for the object
///
///
/// returns:
/// the <code>NSManagedObject</code> instance if the object exists in the transaction, or <code>nil</code> if not found.
+ (id _Nullable)fetchExistingObjectWithID:(NSManagedObjectID * _Nonnull)objectID SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, fetches the <code>NSManagedObject</code> instances in the transaction’s context from references created from a transaction or from a different managed object context.
/// \param objects an array of <code>NSManagedObject</code>s created/fetched outside the transaction
///
///
/// returns:
/// the <code>NSManagedObject</code> array for objects that exists in the transaction
+ (NSArray * _Nonnull)fetchExistingObjects:(NSArray<NSManagedObject *> * _Nonnull)objects SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, fetches the <code>NSManagedObject</code> instances in the transaction’s context from a list of <code>NSManagedObjectID</code>.
/// \param objectIDs the <code>NSManagedObjectID</code> array for the objects
///
///
/// returns:
/// the <code>NSManagedObject</code> array for objects that exists in the transaction
+ (NSArray * _Nonnull)fetchExistingObjectsWithIDs:(NSArray<NSManagedObjectID *> * _Nonnull)objectIDs SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, fetches the first <code>NSManagedObject</code> instance that satisfies the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>From</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the first <code>NSManagedObject</code> instance that satisfies the specified <code>CSFetchClause</code>s
+ (id _Nullable)fetchOneFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, fetches all <code>NSManagedObject</code> instances that satisfy the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// all <code>NSManagedObject</code> instances that satisfy the specified <code>CSFetchClause</code>s
+ (NSArray * _Nullable)fetchAllFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, fetches the number of <code>NSManagedObject</code>s that satisfy the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the number <code>NSManagedObject</code>s that satisfy the specified <code>CSFetchClause</code>s
+ (NSNumber * _Nullable)fetchCountFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, fetches the <code>NSManagedObjectID</code> for the first <code>NSManagedObject</code> that satisfies the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the <code>NSManagedObjectID</code> for the first <code>NSManagedObject</code> that satisfies the specified <code>CSFetchClause</code>s
+ (NSManagedObjectID * _Nullable)fetchObjectIDFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, fetches the <code>NSManagedObjectID</code> for all <code>NSManagedObject</code>s that satisfy the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>FetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the <code>NSManagedObjectID</code> for all <code>NSManagedObject</code>s that satisfy the specified <code>CSFetchClause</code>s
+ (NSArray<NSManagedObjectID *> * _Nullable)fetchObjectIDsFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, queries aggregate values as specified by the <code>CSQueryClause</code>s. Requires at least a <code>CSSelect</code> clause, and optional <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
/// A “query” differs from a “fetch” in that it only retrieves values already stored in the persistent store. As such, values from unsaved transactions or contexts will not be incorporated in the query result.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param selectClause a <code>CSSelect</code> clause indicating the properties to fetch, and with the generic type indicating the return type.
///
/// \param queryClauses a series of <code>CSQueryClause</code> instances for the query request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the result of the the query. The type of the return value is specified by the generic type of the <code>CSSelect</code> parameter.
+ (id _Nullable)queryValueFrom:(CSFrom * _Nonnull)from selectClause:(CSSelect * _Nonnull)selectClause queryClauses:(NSArray<id <CSQueryClause>> * _Nonnull)queryClauses SWIFT_WARN_UNUSED_RESULT;
/// Using the <code>defaultStack</code>, queries a dictionary of attribute values as specified by the <code>CSQueryClause</code>s. Requires at least a <code>CSSelect</code> clause, and optional <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
/// A “query” differs from a “fetch” in that it only retrieves values already stored in the persistent store. As such, values from unsaved transactions or contexts will not be incorporated in the query result.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param selectClause a <code>CSSelect</code> clause indicating the properties to fetch, and with the generic type indicating the return type.
///
/// \param queryClauses a series of <code>CSQueryClause</code> instances for the query request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the result of the the query. The type of the return value is specified by the generic type of the <code>CSSelect</code> parameter.
+ (NSArray<NSDictionary<NSString *, id> *> * _Nullable)queryAttributesFrom:(CSFrom * _Nonnull)from selectClause:(CSSelect * _Nonnull)selectClause queryClauses:(NSArray<id <CSQueryClause>> * _Nonnull)queryClauses SWIFT_WARN_UNUSED_RESULT;
@end


/// The <code>CSDataStack</code> serves as the Objective-C bridging type for <code>DataStack</code>.
/// seealso:
/// <code>DataStack</code>
SWIFT_CLASS("_TtC9CoreStore11CSDataStack") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSDataStack : NSObject
/// Initializes a <code>CSDataStack</code> with default settings. CoreStore searches for <CFBundleName>.xcdatamodeld from the main <code>NSBundle</code> and loads an <code>NSManagedObjectModel</code> from it. An assertion is raised if the model could not be found.
- (nonnull instancetype)init;
/// Initializes a <code>CSDataStack</code> from the model with the specified <code>modelName</code> in the specified <code>bundle</code>.
/// \param xcodeModelName the name of the (.xcdatamodeld) model file. If not specified, the application name (CFBundleName) will be used if it exists, or “CoreData” if it the bundle name was not set.
///
/// \param bundle an optional bundle to load .xcdatamodeld models from. If not specified, the main bundle will be used.
///
/// \param versionChain the version strings that indicate the sequence of model versions to be used as the order for progressive migrations. If not specified, will default to a non-migrating data stack.
///
- (nonnull instancetype)initWithXcodeModelName:(NSString * _Nullable)xcodeModelName bundle:(NSBundle * _Nullable)bundle versionChain:(NSArray<NSString *> * _Nullable)versionChain;
/// Returns the stack’s model version. The version string is the same as the name of the version-specific .xcdatamodeld file.
@property (nonatomic, readonly, copy) NSString * _Nonnull modelVersion;
/// Returns the entity name-to-class type mapping from the <code>CSDataStack</code>’s model.
- (NSDictionary<NSString *, SWIFT_METATYPE(NSManagedObject)> * _Nonnull)entityTypesByNameForType:(SWIFT_METATYPE(NSManagedObject) _Nonnull)type SWIFT_WARN_UNUSED_RESULT;
/// Returns the <code>NSEntityDescription</code> for the specified <code>NSManagedObject</code> subclass from stack’s model.
- (NSEntityDescription * _Nullable)entityDescriptionForClass:(SWIFT_METATYPE(NSManagedObject) _Nonnull)type SWIFT_WARN_UNUSED_RESULT;
/// Creates an <code>CSInMemoryStore</code> with default parameters and adds it to the stack. This method blocks until completion.
/// \code
/// CSSQLiteStore *storage = [dataStack addInMemoryStorageAndWaitAndReturnError:&error];
///
/// \endcode\param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// the <code>CSInMemoryStore</code> added to the stack
- (CSInMemoryStore * _Nullable)addInMemoryStorageAndWaitAndReturnError:(NSError * _Nullable * _Nullable)error;
/// Creates an <code>CSSQLiteStore</code> with default parameters and adds it to the stack. This method blocks until completion.
/// \code
/// CSSQLiteStore *storage = [dataStack addSQLiteStorageAndWaitAndReturnError:&error];
///
/// \endcode\param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// the <code>CSSQLiteStore</code> added to the stack
- (CSSQLiteStore * _Nullable)addSQLiteStorageAndWaitAndReturnError:(NSError * _Nullable * _Nullable)error;
/// Adds a <code>CSInMemoryStore</code> to the stack and blocks until completion.
/// \code
/// NSError *error;
/// CSInMemoryStore *storage = [dataStack
///     addStorageAndWait: [[CSInMemoryStore alloc] initWithConfiguration: @"Config1"]
///     error: &error];
///
/// \endcode\param storage the <code>CSInMemoryStore</code>
///
/// \param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// the <code>CSInMemoryStore</code> added to the stack
- (CSInMemoryStore * _Nullable)addInMemoryStorageAndWait:(CSInMemoryStore * _Nonnull)storage error:(NSError * _Nullable * _Nullable)error;
/// Adds a <code>CSSQLiteStore</code> to the stack and blocks until completion.
/// \code
/// NSError *error;
/// CSSQLiteStore *storage = [dataStack
///     addStorageAndWait: [[CSSQLiteStore alloc] initWithConfiguration: @"Config1"]
///     error: &error];
///
/// \endcode\param storage the <code>CSSQLiteStore</code>
///
/// \param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// the <code>CSSQLiteStore</code> added to the stack
- (CSSQLiteStore * _Nullable)addSQLiteStorageAndWait:(CSSQLiteStore * _Nonnull)storage error:(NSError * _Nullable * _Nullable)error;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
@end

@class CSSetupResult;

SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSDataStack (SWIFT_EXTENSION(CoreStore))
/// Asynchronously adds a <code>CSInMemoryStore</code> to the stack. Migrations are also initiated by default.
/// \code
/// NSError *error;
/// NSProgress *migrationProgress = [dataStack 
///     addInMemoryStorage:[CSInMemoryStore new]
///     completion:^(CSSetupResult *result) {
///         if (result.isSuccess) {
///             // ...
///         }
///     }
///     error: &error];
///
/// \endcode\param storage the <code>CSInMemoryStore</code> instance
///
/// \param completion the closure to be executed on the main queue when the process completes, either due to success or failure. The closure’s <code>CSSetupResult</code> argument indicates the result. This closure is NOT executed if an error is thrown, but will be executed with a failure <code>CSSetupResult</code> result if an error occurs asynchronously.
///
- (void)addInMemoryStorage:(CSInMemoryStore * _Nonnull)storage completion:(void (^ _Nonnull)(CSSetupResult * _Nonnull))completion;
/// Asynchronously adds a <code>CSSQLiteStore</code> to the stack. Migrations are also initiated by default.
/// \code
/// NSError *error;
/// NSProgress *migrationProgress = [dataStack
///     addInMemoryStorage:[[CSSQLiteStore alloc] 
///         initWithFileName:@"core_data.sqlite"
///         configuration:@"Config1"]
///     completion:^(CSSetupResult *result) {
///         if (result.isSuccess) {
///             // ...
///         }
///     }
///     error: &error];
///
/// \endcode\param storage the <code>CSSQLiteStore</code> instance
///
/// \param completion the closure to be executed on the main queue when the process completes, either due to success or failure. The closure’s <code>CSSetupResult</code> argument indicates the result. This closure is NOT executed if an error is thrown, but will be executed with a failure <code>CSSetupResult</code> result if an error occurs asynchronously. Note that the <code>CSLocalStorage</code> associated to the <code>-[CSSetupResult storage]</code> may not always be the same instance as the parameter argument if a previous <code>CSLocalStorage</code> was already added at the same URL and with the same configuration.
///
/// \param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// an <code>NSProgress</code> instance if a migration has started. <code>nil</code> if no migrations are required or if <code>error</code> was set.
- (NSProgress * _Nullable)addSQLiteStorage:(CSSQLiteStore * _Nonnull)storage completion:(void (^ _Nonnull)(CSSetupResult * _Nonnull))completion error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
/// Migrates a <code>CSSQLiteStore</code> to match the <code>CSDataStack</code>’s managed object model version. This method does NOT add the migrated store to the data stack.
/// \param storage the <code>CSSQLiteStore</code> instance
///
/// \param completion the closure to be executed on the main queue when the migration completes, either due to success or failure. The closure’s <code>CSMigrationResult</code> argument indicates the result. This closure is NOT executed if an error is thrown, but will be executed with a failure <code>CSSetupResult</code> result if an error occurs asynchronously.
///
/// \param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// an <code>NSProgress</code> instance if a migration has started. <code>nil</code> if no migrations are required or if <code>error</code> was set.
- (NSProgress * _Nullable)upgradeStorageIfNeeded:(CSSQLiteStore * _Nonnull)storage completion:(void (^ _Nonnull)(CSMigrationResult * _Nonnull))completion error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
/// Checks the migration steps required for the <code>CSSQLiteStore</code> to match the <code>CSDataStack</code>’s managed object model version.
/// \param storage the <code>CSSQLiteStore</code> instance
///
/// \param error the <code>NSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// a <code>CSMigrationType</code> array indicating the migration steps required for the store, or an empty array if the file does not exist yet. Otherwise, <code>nil</code> is returned and the <code>error</code> argument is set if either inspection of the store failed, or if no mapping model was found/inferred.
- (NSArray<CSMigrationType *> * _Nullable)requiredMigrationsForSQLiteStore:(CSSQLiteStore * _Nonnull)storage error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
@end


SWIFT_AVAILABILITY(macos,introduced=10.12) SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSDataStack (SWIFT_EXTENSION(CoreStore))
/// Creates a <code>CSObjectMonitor</code> for the specified <code>NSManagedObject</code>. Multiple <code>ObjectObserver</code>s may then register themselves to be notified when changes are made to the <code>NSManagedObject</code>.
/// \param object the <code>NSManagedObject</code> to observe changes from
///
///
/// returns:
/// an <code>ObjectMonitor</code> that monitors changes to <code>object</code>
- (CSObjectMonitor * _Nonnull)monitorObject:(NSManagedObject * _Nonnull)object SWIFT_WARN_UNUSED_RESULT;
/// Creates a <code>CSListMonitor</code> for a list of <code>NSManagedObject</code>s that satisfy the specified fetch clauses. Multiple <code>CSListObserver</code>s may then register themselves to be notified when changes are made to the list.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>FetchClause</code> instances for fetching the object list. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// a <code>CSListMonitor</code> instance that monitors changes to the list
- (CSListMonitor * _Nonnull)monitorListFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Asynchronously creates a <code>CSListMonitor</code> for a list of <code>NSManagedObject</code>s that satisfy the specified fetch clauses. Multiple <code>CSListObserver</code>s may then register themselves to be notified when changes are made to the list. Since <code>NSFetchedResultsController</code> greedily locks the persistent store on initial fetch, you may prefer this method instead of the synchronous counterpart to avoid deadlocks while background updates/saves are being executed.
/// \param createAsynchronously the closure that receives the created <code>CSListMonitor</code> instance
///
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for fetching the object list. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
- (void)monitorListByCreatingAsynchronously:(void (^ _Nonnull)(CSListMonitor * _Nonnull))createAsynchronously from:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses;
/// Creates a <code>CSListMonitor</code> for a sectioned list of <code>NSManagedObject</code>s that satisfy the specified fetch clauses. Multiple <code>ListObserver</code>s may then register themselves to be notified when changes are made to the list.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param sectionBy a <code>CSSectionBy</code> clause indicating the keyPath for the attribute to use when sorting the list into sections.
///
/// \param fetchClauses a series of <code>FetchClause</code> instances for fetching the object list. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// a <code>CSListMonitor</code> instance that monitors changes to the list
- (CSListMonitor * _Nonnull)monitorSectionedListFrom:(CSFrom * _Nonnull)from sectionBy:(CSSectionBy * _Nonnull)sectionBy fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
@end


SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSDataStack (SWIFT_EXTENSION(CoreStore))
/// Begins a transaction asynchronously where <code>NSManagedObject</code> creates, updates, and deletes can be made.
/// \param closure the block where creates, updates, and deletes can be made to the transaction. Transaction blocks are executed serially in a background queue, and all changes are made from a concurrent <code>NSManagedObjectContext</code>.
///
- (void)beginAsynchronous:(void (^ _Nonnull)(CSAsynchronousDataTransaction * _Nonnull))closure;
/// Begins a transaction synchronously where <code>NSManagedObject</code> creates, updates, and deletes can be made.
/// \param closure the block where creates, updates, and deletes can be made to the transaction. Transaction blocks are executed serially in a background queue, and all changes are made from a concurrent <code>NSManagedObjectContext</code>.
///
/// \param error the <code>CSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// <code>YES</code> if the commit succeeded, <code>NO</code> if the commit failed. If <code>NO</code>, the <code>error</code> argument will hold error information.
- (BOOL)beginSynchronous:(void (^ _Nonnull)(CSSynchronousDataTransaction * _Nonnull))closure error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
/// Begins a child transaction where <code>NSManagedObject</code> creates, updates, and deletes can be made. This is useful for making temporary changes, such as partially filled forms.
/// To support “undo” methods such as <code>-undo</code>, <code>-redo</code>, and <code>-rollback</code>, use the <code>-beginSafeWithSupportsUndo:</code> method passing <code>YES</code> to the argument. Without “undo” support, calling those methods will raise an exception.
///
/// returns:
/// a <code>CSUnsafeDataTransaction</code> instance where creates, updates, and deletes can be made.
- (CSUnsafeDataTransaction * _Nonnull)beginUnsafe SWIFT_WARN_UNUSED_RESULT;
/// Begins a child transaction where <code>NSManagedObject</code> creates, updates, and deletes can be made. This is useful for making temporary changes, such as partially filled forms.
/// <ul>
///   <li>
///     prameter supportsUndo: <code>-undo</code>, <code>-redo</code>, and <code>-rollback</code> methods are only available when this parameter is <code>YES</code>, otherwise those method will raise an exception. Note that turning on Undo support may heavily impact performance especially on iOS or watchOS where memory is limited.
///   </li>
/// </ul>
///
/// returns:
/// a <code>CSUnsafeDataTransaction</code> instance where creates, updates, and deletes can be made.
- (CSUnsafeDataTransaction * _Nonnull)beginUnsafeWithSupportsUndo:(BOOL)supportsUndo SWIFT_WARN_UNUSED_RESULT;
/// Refreshes all registered objects <code>NSManagedObject</code>s in the <code>DataStack</code>.
- (void)refreshAndMergeAllObjects;
@end


SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSDataStack (SWIFT_EXTENSION(CoreStore))
/// Fetches the <code>NSManagedObject</code> instance in the transaction’s context from a reference created from a transaction or from a different managed object context.
/// \param object a reference to the object created/fetched outside the transaction
///
///
/// returns:
/// the <code>NSManagedObject</code> instance if the object exists in the transaction, or <code>nil</code> if not found.
- (id _Nullable)fetchExistingObject:(NSManagedObject * _Nonnull)object SWIFT_WARN_UNUSED_RESULT;
/// Fetches the <code>NSManagedObject</code> instance in the transaction’s context from an <code>NSManagedObjectID</code>.
/// \param objectID the <code>NSManagedObjectID</code> for the object
///
///
/// returns:
/// the <code>NSManagedObject</code> instance if the object exists in the transaction, or <code>nil</code> if not found.
- (id _Nullable)fetchExistingObjectWithID:(NSManagedObjectID * _Nonnull)objectID SWIFT_WARN_UNUSED_RESULT;
/// Fetches the <code>NSManagedObject</code> instances in the transaction’s context from references created from a transaction or from a different managed object context.
/// \param objects an array of <code>NSManagedObject</code>s created/fetched outside the transaction
///
///
/// returns:
/// the <code>NSManagedObject</code> array for objects that exists in the transaction
- (NSArray * _Nonnull)fetchExistingObjects:(NSArray<NSManagedObject *> * _Nonnull)objects SWIFT_WARN_UNUSED_RESULT;
/// Fetches the <code>NSManagedObject</code> instances in the transaction’s context from a list of <code>NSManagedObjectID</code>.
/// \param objectIDs the <code>NSManagedObjectID</code> array for the objects
///
///
/// returns:
/// the <code>NSManagedObject</code> array for objects that exists in the transaction
- (NSArray * _Nonnull)fetchExistingObjectsWithIDs:(NSArray<NSManagedObjectID *> * _Nonnull)objectIDs SWIFT_WARN_UNUSED_RESULT;
/// Fetches the first <code>NSManagedObject</code> instance that satisfies the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>From</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the first <code>NSManagedObject</code> instance that satisfies the specified <code>CSFetchClause</code>s
- (id _Nullable)fetchOneFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Fetches all <code>NSManagedObject</code> instances that satisfy the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// all <code>NSManagedObject</code> instances that satisfy the specified <code>CSFetchClause</code>s
- (NSArray * _Nullable)fetchAllFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Fetches the number of <code>NSManagedObject</code>s that satisfy the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the number <code>NSManagedObject</code>s that satisfy the specified <code>CSFetchClause</code>s
- (NSNumber * _Nullable)fetchCountFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Fetches the <code>NSManagedObjectID</code> for the first <code>NSManagedObject</code> that satisfies the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>CSFetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the <code>NSManagedObjectID</code> for the first <code>NSManagedObject</code> that satisfies the specified <code>CSFetchClause</code>s
- (NSManagedObjectID * _Nullable)fetchObjectIDFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Fetches the <code>NSManagedObjectID</code> for all <code>NSManagedObject</code>s that satisfy the specified <code>CSFetchClause</code>s. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param fetchClauses a series of <code>FetchClause</code> instances for the fetch request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the <code>NSManagedObjectID</code> for all <code>NSManagedObject</code>s that satisfy the specified <code>CSFetchClause</code>s
- (NSArray<NSManagedObjectID *> * _Nullable)fetchObjectIDsFrom:(CSFrom * _Nonnull)from fetchClauses:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses SWIFT_WARN_UNUSED_RESULT;
/// Queries aggregate values as specified by the <code>CSQueryClause</code>s. Requires at least a <code>CSSelect</code> clause, and optional <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
/// A “query” differs from a “fetch” in that it only retrieves values already stored in the persistent store. As such, values from unsaved transactions or contexts will not be incorporated in the query result.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param selectClause a <code>CSSelect</code> clause indicating the properties to fetch, and with the generic type indicating the return type.
///
/// \param queryClauses a series of <code>CSQueryClause</code> instances for the query request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the result of the the query. The type of the return value is specified by the generic type of the <code>CSSelect</code> parameter.
- (id _Nullable)queryValueFrom:(CSFrom * _Nonnull)from selectClause:(CSSelect * _Nonnull)selectClause queryClauses:(NSArray<id <CSQueryClause>> * _Nonnull)queryClauses SWIFT_WARN_UNUSED_RESULT;
/// Queries a dictionary of attribute values as specified by the <code>CSQueryClause</code>s. Requires at least a <code>CSSelect</code> clause, and optional <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
/// A “query” differs from a “fetch” in that it only retrieves values already stored in the persistent store. As such, values from unsaved transactions or contexts will not be incorporated in the query result.
/// \param from a <code>CSFrom</code> clause indicating the entity type
///
/// \param selectClause a <code>CSSelect</code> clause indicating the properties to fetch, and with the generic type indicating the return type.
///
/// \param queryClauses a series of <code>CSQueryClause</code> instances for the query request. Accepts <code>CSWhere</code>, <code>CSOrderBy</code>, <code>CSGroupBy</code>, and <code>CSTweak</code> clauses.
///
///
/// returns:
/// the result of the the query. The type of the return value is specified by the generic type of the <code>CSSelect</code> parameter.
- (NSArray<NSDictionary<NSString *, id> *> * _Nullable)queryAttributesFrom:(CSFrom * _Nonnull)from selectClause:(CSSelect * _Nonnull)selectClause queryClauses:(NSArray<id <CSQueryClause>> * _Nonnull)queryClauses SWIFT_WARN_UNUSED_RESULT;
@end


/// The <code>CSDeleteClause</code> implement clauses used to configure <code>NSFetchRequest</code>s.
/// seealso:
/// <code>DeleteClause</code>
SWIFT_PROTOCOL("_TtP9CoreStore14CSDeleteClause_")
@protocol CSDeleteClause
- (void)applyToFetchRequest:(NSFetchRequest<id <NSFetchRequestResult>> * _Nonnull)fetchRequest;
@end

@class NSManagedObjectModel;

/// The <code>CSDynamicSchema</code> serves as the Objective-C bridging type for <code>DynamicSchema</code>.
/// seealso:
/// <code>DynamicSchema</code>
SWIFT_PROTOCOL("_TtP9CoreStore15CSDynamicSchema_")
@protocol CSDynamicSchema
/// The version string for this model schema.
@property (nonatomic, readonly, copy) NSString * _Nonnull modelVersion;
/// Do not call this directly. The <code>NSManagedObjectModel</code> for this schema may be created lazily and using this method directly may affect the integrity of the model.
- (NSManagedObjectModel * _Nonnull)rawModel SWIFT_WARN_UNUSED_RESULT;
@end

@class NSCoder;

/// All errors thrown from CoreStore are expressed in <code>CSError</code>s.
/// seealso:
/// <code>CoreStoreError</code>
SWIFT_CLASS("_TtC9CoreStore7CSError")
@interface CSError : NSError
/// The <code>NSError</code> error domain for <code>CSError</code>.
/// seealso:
/// <code>CoreStoreErrorErrorDomain</code>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull errorDomain;)
+ (NSString * _Nonnull)errorDomain SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithDomain:(NSString * _Nonnull)domain code:(NSInteger)code userInfo:(NSDictionary<NSString *, id> * _Nullable)dict SWIFT_UNAVAILABLE;
@end



/// The <code>NSError</code> error codes for <code>CSError.Domain</code>.
/// seealso:
/// <code>CSError</code>
/// seealso:
/// <code>CoreStoreError</code>
typedef SWIFT_ENUM(NSInteger, CSErrorCode, closed) {
/// A failure occured because of an unknown error.
  CSErrorCodeUnknownError = 0,
/// The <code>NSPersistentStore</code> could note be initialized because another store existed at the specified <code>NSURL</code>.
  CSErrorCodeDifferentStorageExistsAtURL = 1,
/// An <code>NSMappingModel</code> could not be found for a specific source and destination model versions.
  CSErrorCodeMappingModelNotFound = 2,
/// Progressive migrations are disabled for a store, but an <code>NSMappingModel</code> could not be found for a specific source and destination model versions.
  CSErrorCodeProgressiveMigrationRequired = 3,
/// An internal SDK call failed with the specified “NSError” userInfo key.
  CSErrorCodeInternalError = 4,
/// The transaction was terminated by a user-thrown error with the specified “Error” userInfo key.
  CSErrorCodeUserError = 5,
/// The transaction was cancelled by the user.
  CSErrorCodeUserCancelled = 6,
};


/// The <code>CSFetchClause</code> implement clauses used to configure <code>NSFetchRequest</code>s.
/// seealso:
/// <code>FetchClause</code>
SWIFT_PROTOCOL("_TtP9CoreStore13CSFetchClause_")
@protocol CSFetchClause
- (void)applyToFetchRequest:(NSFetchRequest<id <NSFetchRequestResult>> * _Nonnull)fetchRequest;
@end


/// The <code>CSFrom</code> serves as the Objective-C bridging type for <code>From</code>.
/// seealso:
/// <code>From</code>
SWIFT_CLASS("_TtC9CoreStore6CSFrom")
@interface CSFrom : NSObject
/// The associated <code>NSManagedObject</code> entity class
@property (nonatomic, readonly) Class _Nonnull entityClass;
/// The <code>NSPersistentStore</code> configuration names to associate objects from.
/// May contain <code>NSString</code> instances to pertain to named configurations, or <code>NSNull</code> to pertain to the default configuration
@property (nonatomic, readonly, copy) NSArray * _Nullable configurations;
/// Initializes a <code>CSFrom</code> clause with the specified entity class.
/// \code
/// MyPersonEntity *people = [transaction fetchAllFrom:CSFromClass([MyPersonEntity class])];
///
/// \endcode\param entityClass the <code>NSManagedObject</code> class type to be created
///
- (nonnull instancetype)initWithEntityClass:(SWIFT_METATYPE(NSManagedObject) _Nonnull)entityClass;
/// Initializes a <code>CSFrom</code> clause with the specified configurations.
/// \code
/// MyPersonEntity *people = [transaction fetchAllFrom:
///    CSFromClass([MyPersonEntity class], @"Config1")];
///
/// \endcode\param entityClass the associated <code>NSManagedObject</code> entity class
///
/// \param configuration the <code>NSPersistentStore</code> configuration name to associate objects from. This parameter is required if multiple configurations contain the created <code>NSManagedObject</code>’s entity type. Set to <code>[NSNull null]</code> to use the default configuration.
///
- (nonnull instancetype)initWithEntityClass:(SWIFT_METATYPE(NSManagedObject) _Nonnull)entityClass configuration:(id _Nonnull)configuration;
/// Initializes a <code>CSFrom</code> clause with the specified configurations.
/// \code
/// MyPersonEntity *people = [transaction fetchAllFrom:
///    CSFromClass([MyPersonEntity class],
///                 @[[NSNull null], @"Config1"])];
///
/// \endcode\param entityClass the associated <code>NSManagedObject</code> entity class
///
/// \param configurations an array of the <code>NSPersistentStore</code> configuration names to associate objects from. This parameter is required if multiple configurations contain the created <code>NSManagedObject</code>’s entity type. Set to <code>[NSNull null]</code> to use the default configuration.
///
- (nonnull instancetype)initWithEntityClass:(SWIFT_METATYPE(NSManagedObject) _Nonnull)entityClass configurations:(NSArray * _Nonnull)configurations;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The <code>CSQueryClause</code> implement clauses used to configure <code>NSFetchRequest</code>s.
/// seealso:
/// <code>QueryClause</code>
SWIFT_PROTOCOL("_TtP9CoreStore13CSQueryClause_")
@protocol CSQueryClause
- (void)applyToFetchRequest:(NSFetchRequest<id <NSFetchRequestResult>> * _Nonnull)fetchRequest;
@end


/// The <code>CSGroupBy</code> serves as the Objective-C bridging type for <code>GroupBy</code>.
/// seealso:
/// <code>GroupBy</code>
SWIFT_CLASS("_TtC9CoreStore9CSGroupBy")
@interface CSGroupBy : NSObject <CSQueryClause>
/// The list of key path strings to group results with
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nonnull keyPaths;
/// Initializes a <code>CSGroupBy</code> clause with a key path string
/// \param keyPath a key path string to group results with
///
- (nonnull instancetype)initWithKeyPath:(NSString * _Nonnull)keyPath;
/// Initializes a <code>CSGroupBy</code> clause with a list of key path strings
/// \param keyPaths a list of key path strings to group results with
///
- (nonnull instancetype)initWithKeyPaths:(NSArray<NSString *> * _Nonnull)keyPaths;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (void)applyToFetchRequest:(NSFetchRequest<id <NSFetchRequestResult>> * _Nonnull)fetchRequest;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The <code>CSStorageInterface</code> serves as the Objective-C bridging type for <code>StorageInterface</code>.
/// seealso:
/// <code>StorageInterface</code>
SWIFT_PROTOCOL("_TtP9CoreStore18CSStorageInterface_")
@protocol CSStorageInterface
/// The string identifier for the <code>NSPersistentStore</code>’s <code>type</code> property. This is the same string CoreStore will use to create the <code>NSPersistentStore</code> from the <code>NSPersistentStoreCoordinator</code>’s <code>addPersistentStoreWithType(...)</code> method.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull storeType;)
+ (NSString * _Nonnull)storeType SWIFT_WARN_UNUSED_RESULT;
/// The configuration name in the model file
@property (nonatomic, readonly, copy) NSString * _Nullable configuration;
/// The options dictionary for the <code>NSPersistentStore</code>
@property (nonatomic, readonly, copy) NSDictionary * _Nullable storeOptions;
@end


/// The <code>CSInMemoryStore</code> serves as the Objective-C bridging type for <code>InMemoryStore</code>.
/// seealso:
/// <code>InMemoryStore</code>
SWIFT_CLASS("_TtC9CoreStore15CSInMemoryStore") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSInMemoryStore : NSObject <CSStorageInterface>
/// Initializes a <code>CSInMemoryStore</code> for the specified configuration
/// \param configuration an optional configuration name from the model file. If not specified, defaults to <code>nil</code>, the “Default” configuration.
///
- (nonnull instancetype)initWithConfiguration:(NSString * _Nullable)configuration;
/// Initializes a <code>CSInMemoryStore</code> with the “Default” configuration
- (nonnull instancetype)init;
/// The string identifier for the <code>NSPersistentStore</code>’s <code>type</code> property. For <code>CSInMemoryStore</code>s, this is always set to <code>NSInMemoryStoreType</code>.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull storeType;)
+ (NSString * _Nonnull)storeType SWIFT_WARN_UNUSED_RESULT;
/// The configuration name in the model file
@property (nonatomic, readonly, copy) NSString * _Nullable configuration;
/// The options dictionary for the <code>NSPersistentStore</code>. For <code>CSInMemoryStore</code>s, this is always set to <code>nil</code>.
@property (nonatomic, readonly, copy) NSDictionary * _Nullable storeOptions;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
@end


/// The <code>CSInto</code> serves as the Objective-C bridging type for <code>Into<T></code>.
/// seealso:
/// <code>Into</code>
SWIFT_CLASS("_TtC9CoreStore6CSInto")
@interface CSInto : NSObject
/// The associated <code>NSManagedObject</code> entity class
@property (nonatomic, readonly) SWIFT_METATYPE(NSManagedObject) _Nonnull entityClass;
/// The <code>NSPersistentStore</code> configuration name to associate objects from.
/// May contain a <code>String</code> to pertain to a named configuration, or <code>nil</code> to pertain to the default configuration
@property (nonatomic, readonly, copy) NSString * _Nullable configuration;
/// Initializes a <code>CSInto</code> clause with the specified entity class.
/// \code
/// MyPersonEntity *person = [transaction createInto:
///    CSIntoClass([MyPersonEntity class])];
///
/// \endcode\param entityClass the <code>NSManagedObject</code> class type to be created
///
- (nonnull instancetype)initWithEntityClass:(SWIFT_METATYPE(NSManagedObject) _Nonnull)entityClass;
/// Initializes a <code>CSInto</code> clause with the specified configuration.
/// \code
/// MyPersonEntity *person = [transaction createInto:
///    CSIntoClass([MyPersonEntity class])];
///
/// \endcode\param entityClass the <code>NSManagedObject</code> class type to be created
///
/// \param configuration the <code>NSPersistentStore</code> configuration name to associate the object to. This parameter is required if multiple configurations contain the created <code>NSManagedObject</code>’s entity type. Set to <code>nil</code> to use the default configuration.
///
- (nonnull instancetype)initWithEntityClass:(SWIFT_METATYPE(NSManagedObject) _Nonnull)entityClass configuration:(NSString * _Nullable)configuration;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@protocol NSFetchedResultsSectionInfo;
@protocol CSListObserver;
@protocol CSListSectionObserver;

/// The <code>CSListMonitor</code> serves as the Objective-C bridging type for <code>ListMonitor<T></code>.
/// seealso:
/// <code>ListMonitor</code>
SWIFT_CLASS("_TtC9CoreStore13CSListMonitor") SWIFT_AVAILABILITY(macos,introduced=10.12)
@interface CSListMonitor : NSObject
- (id _Nonnull)objectAtIndexedSubscript:(NSInteger)index SWIFT_WARN_UNUSED_RESULT;
/// Returns the object at the given index, or <code>nil</code> if out of bounds. This indexer is typically used for <code>CSListMonitor</code>s created without section groupings.
/// \param index the index for the object. Using an index above the valid range will return <code>nil</code>.
///
///
/// returns:
/// the <code>NSManagedObject</code> at the specified index, or <code>nil</code> if out of bounds
- (id _Nullable)objectAtSafeIndex:(NSInteger)index SWIFT_WARN_UNUSED_RESULT;
/// Returns the object at the given <code>sectionIndex</code> and <code>itemIndex</code>. This indexer is typically used for <code>CSListMonitor</code>s created as sectioned lists.
/// \param sectionIndex the section index for the object. Using a <code>sectionIndex</code> with an invalid range will raise an exception.
///
/// \param itemIndex the index for the object within the section. Using an <code>itemIndex</code> with an invalid range will raise an exception.
///
///
/// returns:
/// the <code>NSManagedObject</code> at the specified section and item index
- (id _Nonnull)objectAtSectionIndex:(NSInteger)sectionIndex itemIndex:(NSInteger)itemIndex SWIFT_WARN_UNUSED_RESULT;
/// Returns the object at the given section and item index, or <code>nil</code> if out of bounds. This indexer is typically used for <code>CSListMonitor</code>s created as sectioned lists.
/// \param sectionIndex the section index for the object. Using a <code>sectionIndex</code> with an invalid range will return <code>nil</code>.
///
/// \param itemIndex the index for the object within the section. Using an <code>itemIndex</code> with an invalid range will return <code>nil</code>.
///
///
/// returns:
/// the <code>NSManagedObject</code> at the specified section and item index, or <code>nil</code> if out of bounds
- (id _Nullable)objectAtSafeSectionIndex:(NSInteger)sectionIndex safeItemIndex:(NSInteger)itemIndex SWIFT_WARN_UNUSED_RESULT;
/// Returns the object at the given <code>NSIndexPath</code>. This subscript indexer is typically used for <code>CSListMonitor</code>s created as sectioned lists.
/// \param indexPath the <code>NSIndexPath</code> for the object. Using an <code>indexPath</code> with an invalid range will raise an exception.
///
///
/// returns:
/// the <code>NSManagedObject</code> at the specified index path
- (id _Nonnull)objectAtIndexPath:(NSIndexPath * _Nonnull)indexPath SWIFT_WARN_UNUSED_RESULT;
/// Returns the object at the given <code>NSIndexPath</code>, or <code>nil</code> if out of bounds. This subscript indexer is typically used for <code>CSListMonitor</code>s created as sectioned lists.
/// \param indexPath the <code>NSIndexPath</code> for the object. Using an <code>indexPath</code> with an invalid range will return <code>nil</code>.
///
///
/// returns:
/// the <code>NSManagedObject</code> at the specified index path, or <code>nil</code> if out of bounds
- (id _Nullable)objectAtSafeIndexPath:(NSIndexPath * _Nonnull)indexPath SWIFT_WARN_UNUSED_RESULT;
/// Checks if the <code>CSListMonitor</code> has at least one object in any section.
///
/// returns:
/// <code>YES</code> if at least one object in any section exists, <code>NO</code> otherwise
- (BOOL)hasObjects SWIFT_WARN_UNUSED_RESULT;
/// Checks if the <code>CSListMonitor</code> has at least one object the specified section.
/// \param section the section index. Using an index outside the valid range will return <code>NO</code>.
///
///
/// returns:
/// <code>YES</code> if at least one object in the specified section exists, <code>NO</code> otherwise
- (BOOL)hasObjectsInSection:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// Returns all objects in all sections
///
/// returns:
/// all objects in all sections
- (NSArray<NSManagedObject *> * _Nonnull)objectsInAllSections SWIFT_WARN_UNUSED_RESULT;
/// Returns all objects in the specified section
/// \param section the section index. Using an index outside the valid range will raise an exception.
///
///
/// returns:
/// all objects in the specified section
- (NSArray<NSManagedObject *> * _Nonnull)objectsInSection:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// Returns all objects in the specified section, or <code>nil</code> if out of bounds.
/// \param section the section index. Using an index outside the valid range will return <code>nil</code>.
///
///
/// returns:
/// all objects in the specified section, or <code>nil</code> if out of bounds
- (NSArray<NSManagedObject *> * _Nullable)objectsInSafeSectionWithSafeSectionIndex:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// Returns the number of sections
///
/// returns:
/// the number of sections
- (NSInteger)numberOfSections SWIFT_WARN_UNUSED_RESULT;
/// Returns the number of objects in all sections
///
/// returns:
/// the number of objects in all sections
- (NSInteger)numberOfObjects SWIFT_WARN_UNUSED_RESULT;
/// Returns the number of objects in the specified section
/// \param section the section index. Using an index outside the valid range will raise an exception.
///
///
/// returns:
/// the number of objects in the specified section
- (NSInteger)numberOfObjectsInSection:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// Returns the number of objects in the specified section, or <code>nil</code> if out of bounds.
/// \param section the section index. Using an index outside the valid range will return <code>nil</code>.
///
///
/// returns:
/// the number of objects in the specified section, or <code>nil</code> if out of bounds
- (NSNumber * _Nullable)numberOfObjectsInSafeSectionWithSafeSectionIndex:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// Returns the <code>NSFetchedResultsSectionInfo</code> for the specified section
/// \param section the section index. Using an index outside the valid range will raise an exception.
///
///
/// returns:
/// the <code>NSFetchedResultsSectionInfo</code> for the specified section
- (id <NSFetchedResultsSectionInfo> _Nonnull)sectionInfoAtIndex:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// Returns the <code>NSFetchedResultsSectionInfo</code> for the specified section, or <code>nil</code> if out of bounds.
/// \param section the section index. Using an index outside the valid range will return <code>nil</code>.
///
///
/// returns:
/// the <code>NSFetchedResultsSectionInfo</code> for the specified section, or <code>nil</code> if the section index is out of bounds.
- (id <NSFetchedResultsSectionInfo> _Nullable)sectionInfoAtSafeSectionIndexWithSafeSectionIndex:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
/// Returns the <code>NSFetchedResultsSectionInfo</code>s for all sections
///
/// returns:
/// the <code>NSFetchedResultsSectionInfo</code>s for all sections
- (NSArray<id <NSFetchedResultsSectionInfo>> * _Nonnull)sections SWIFT_WARN_UNUSED_RESULT;
/// Returns the target section for a specified “Section Index” title and index.
/// \param title the title of the Section Index
///
/// \param index the index of the Section Index
///
///
/// returns:
/// the target section for the specified “Section Index” title and index.
- (NSInteger)targetSectionForSectionIndexTitleWithTitle:(NSString * _Nonnull)title index:(NSInteger)index SWIFT_WARN_UNUSED_RESULT;
/// Returns the section index titles for all sections
///
/// returns:
/// the section index titles for all sections
- (NSArray<NSString *> * _Nonnull)sectionIndexTitles SWIFT_WARN_UNUSED_RESULT;
/// Returns the index of the <code>NSManagedObject</code> if it exists in the <code>CSListMonitor</code>’s fetched objects, or <code>nil</code> if not found.
/// \param object the <code>NSManagedObject</code> to search the index of
///
///
/// returns:
/// the index of the <code>NSManagedObject</code> if it exists in the <code>CSListMonitor</code>’s fetched objects, or <code>nil</code> if not found.
- (NSNumber * _Nullable)indexOf:(NSManagedObject * _Nonnull)object SWIFT_WARN_UNUSED_RESULT;
/// Returns the <code>NSIndexPath</code> of the <code>NSManagedObject</code> if it exists in the <code>CSListMonitor</code>’s fetched objects, or <code>nil</code> if not found.
/// \param object the <code>NSManagedObject</code> to search the index of
///
///
/// returns:
/// the <code>NSIndexPath</code> of the <code>NSManagedObject</code> if it exists in the <code>ListMonitor</code>’s fetched objects, or <code>nil</code> if not found.
- (NSIndexPath * _Nullable)indexPathOf:(NSManagedObject * _Nonnull)object SWIFT_WARN_UNUSED_RESULT;
/// Registers a <code>CSListObserver</code> to be notified when changes to the receiver’s list occur.
/// To prevent retain-cycles, <code>CSListMonitor</code> only keeps <code>weak</code> references to its observers.
/// For thread safety, this method needs to be called from the main thread. An assertion failure will occur (on debug builds only) if called from any thread other than the main thread.
/// Calling <code>-addListObserver:</code> multiple times on the same observer is safe, as <code>CSListMonitor</code> unregisters previous notifications to the observer before re-registering them.
/// \param observer a <code>CSListObserver</code> to send change notifications to
///
- (void)addListObserver:(id <CSListObserver> _Nonnull)observer;
/// Registers a <code>CSListSectionObserver</code> to be notified when changes to the receiver’s list occur.
/// To prevent retain-cycles, <code>CSListMonitor</code> only keeps <code>weak</code> references to its observers.
/// For thread safety, this method needs to be called from the main thread. An assertion failure will occur (on debug builds only) if called from any thread other than the main thread.
/// Calling <code>-addListSectionObserver:</code> multiple times on the same observer is safe, as <code>ListMonitor</code> unregisters previous notifications to the observer before re-registering them.
/// \param observer a <code>CSListSectionObserver</code> to send change notifications to
///
- (void)addListSectionObserver:(id <CSListSectionObserver> _Nonnull)observer;
/// Unregisters a <code>CSListObserver</code> from receiving notifications for changes to the receiver’s list.
/// For thread safety, this method needs to be called from the main thread. An assertion failure will occur (on debug builds only) if called from any thread other than the main thread.
/// \param observer a <code>CSListObserver</code> to unregister notifications to
///
- (void)removeListObserver:(id <CSListObserver> _Nonnull)observer;
/// Returns <code>YES</code> if a call to <code>-refetch:</code> was made to the <code>CSListMonitor</code> and is currently waiting for the fetching to complete. Returns <code>NO</code> otherwise.
@property (nonatomic, readonly) BOOL isPendingRefetch;
/// Asks the <code>CSListMonitor</code> to refetch its objects using the specified series of <code>CSFetchClause</code>s. Note that this method does not execute the fetch immediately; the actual fetching will happen after the <code>NSFetchedResultsController</code>’s last <code>controllerDidChangeContent(_:)</code> notification completes.
/// <code>refetch(...)</code> broadcasts <code>listMonitorWillRefetch(...)</code> to its observers immediately, and then <code>listMonitorDidRefetch(...)</code> after the new fetch request completes.
/// important:
/// Starting CoreStore 4.0, all <code>CSFetchClause</code>s required by the <code>CSListMonitor</code> should be provided in the arguments list of <code>refetch(...)</code>.
/// \param fetchClauses a series of <code>FetchClause</code> instances for fetching the object list. Accepts <code>Where</code>, <code>OrderBy</code>, and <code>Tweak</code> clauses.
///
- (void)refetch:(NSArray<id <CSFetchClause>> * _Nonnull)fetchClauses;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Implement the <code>CSListObserver</code> protocol to observe changes to a list of <code>NSManagedObject</code>s. <code>CSListObserver</code>s may register themselves to a <code>CSListMonitor</code>’s <code>-addListObserver:</code> method:
/// \code
/// CSListMonitor *monitor = [CSCoreStore 
///     monitorListFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     fetchClauses:@[[CSOrderBy sortDescriptor:[CSSortKey withKeyPath:@"lastName" ascending:YES]]]];
/// [monitor addListObserver:self];
///
/// \endcodeseealso:
/// <code>ListObserver</code>
SWIFT_PROTOCOL("_TtP9CoreStore14CSListObserver_") SWIFT_AVAILABILITY(macos,introduced=10.12)
@protocol CSListObserver
@optional
/// Handles processing just before a change to the observed list occurs
/// \param monitor the <code>CSListMonitor</code> monitoring the list being observed
///
- (void)listMonitorWillChange:(CSListMonitor * _Nonnull)monitor;
/// Handles processing right after a change to the observed list occurs
/// \param monitor the <code>CSListMonitor</code> monitoring the object being observed
///
- (void)listMonitorDidChange:(CSListMonitor * _Nonnull)monitor;
/// This method is broadcast from within the <code>CSListMonitor</code>’s <code>-refetchWithFetchClauses:</code> method to let observers prepare for the internal <code>NSFetchedResultsController</code>’s pending change to its predicate, sort descriptors, etc. Note that the actual refetch will happen after the <code>NSFetchedResultsController</code>’s last <code>-controllerDidChangeContent:</code> notification completes.
/// \param monitor the <code>CSListMonitor</code> monitoring the object being observed
///
- (void)listMonitorWillRefetch:(CSListMonitor * _Nonnull)monitor;
/// After the <code>CSListMonitor</code>’s <code>-refetchWithFetchClauses:</code> method is called, this method is broadcast after the <code>NSFetchedResultsController</code>’s last <code>-controllerDidChangeContent:</code> notification completes.
/// \param monitor the <code>CSListMonitor</code> monitoring the object being observed
///
- (void)listMonitorDidRefetch:(CSListMonitor * _Nonnull)monitor;
@end


/// Implement the <code>CSListObjectObserver</code> protocol to observe detailed changes to a list’s object. <code>CSListObjectObserver</code>s may register themselves to a <code>CSListMonitor</code>’s <code>-addListObjectObserver(_:)</code> method:
/// \code
/// CSListMonitor *monitor = [CSCoreStore
///     monitorListFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     fetchClauses:@[[CSOrderBy sortDescriptor:[CSSortKey withKeyPath:@"lastName" ascending:YES]]]];
/// [monitor addListObjectObserver:self];
///
/// \endcodeseealso:
/// <code>ListObjectObserver</code>
SWIFT_PROTOCOL("_TtP9CoreStore20CSListObjectObserver_") SWIFT_AVAILABILITY(macos,introduced=10.12)
@protocol CSListObjectObserver <CSListObserver>
@optional
/// Notifies that an object was inserted to the specified <code>NSIndexPath</code> in the list
/// \param monitor the <code>CSListMonitor</code> monitoring the list being observed
///
/// \param object the entity type for the inserted object
///
/// \param indexPath the new <code>NSIndexPath</code> for the inserted object
///
- (void)listMonitor:(CSListMonitor * _Nonnull)monitor didInsertObject:(id _Nonnull)object toIndexPath:(NSIndexPath * _Nonnull)indexPath;
/// Notifies that an object was deleted from the specified <code>NSIndexPath</code> in the list
/// \param monitor the <code>CSListMonitor</code> monitoring the list being observed
///
/// \param object the entity type for the deleted object
///
/// \param indexPath the <code>NSIndexPath</code> for the deleted object
///
- (void)listMonitor:(CSListMonitor * _Nonnull)monitor didDeleteObject:(id _Nonnull)object fromIndexPath:(NSIndexPath * _Nonnull)indexPath;
/// Notifies that an object at the specified <code>NSIndexPath</code> was updated
/// \param monitor the <code>CSListMonitor</code> monitoring the list being observed
///
/// \param object the entity type for the updated object
///
/// \param indexPath the <code>NSIndexPath</code> for the updated object
///
- (void)listMonitor:(CSListMonitor * _Nonnull)monitor didUpdateObject:(id _Nonnull)object atIndexPath:(NSIndexPath * _Nonnull)indexPath;
/// Notifies that an object’s index changed
/// \param monitor the <code>CSListMonitor</code> monitoring the list being observed
///
/// \param object the entity type for the moved object
///
/// \param fromIndexPath the previous <code>NSIndexPath</code> for the moved object
///
/// \param toIndexPath the new <code>NSIndexPath</code> for the moved object
///
- (void)listMonitor:(CSListMonitor * _Nonnull)monitor didMoveObject:(id _Nonnull)object fromIndexPath:(NSIndexPath * _Nonnull)fromIndexPath toIndexPath:(NSIndexPath * _Nonnull)toIndexPath;
@end



/// Implement the <code>CSListSectionObserver</code> protocol to observe changes to a list’s section info. <code>CSListSectionObserver</code>s may register themselves to a <code>CSListMonitor</code>’s <code>-addListSectionObserver:</code> method:
/// \code
/// CSListMonitor *monitor = [CSCoreStore
///     monitorSectionedListFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     sectionBy:[CSSectionBy keyPath:@"age"]
///     fetchClauses:@[[CSOrderBy sortDescriptor:[CSSortKey withKeyPath:@"lastName" ascending:YES]]]];
/// [monitor addListSectionObserver:self];
///
/// \endcodeseealso:
/// <code>ListSectionObserver</code>
SWIFT_PROTOCOL("_TtP9CoreStore21CSListSectionObserver_") SWIFT_AVAILABILITY(macos,introduced=10.12)
@protocol CSListSectionObserver <CSListObjectObserver>
@optional
/// Notifies that a section was inserted at the specified index
/// \param monitor the <code>CSListMonitor</code> monitoring the list being observed
///
/// \param sectionInfo the <code>NSFetchedResultsSectionInfo</code> for the inserted section
///
/// \param sectionIndex the new section index for the new section
///
- (void)listMonitor:(CSListMonitor * _Nonnull)monitor didInsertSection:(id <NSFetchedResultsSectionInfo> _Nonnull)sectionInfo toSectionIndex:(NSInteger)sectionIndex;
/// Notifies that a section was inserted at the specified index
/// \param monitor the <code>CSListMonitor</code> monitoring the list being observed
///
/// \param sectionInfo the <code>NSFetchedResultsSectionInfo</code> for the deleted section
///
/// \param sectionIndex the previous section index for the deleted section
///
- (void)listMonitor:(CSListMonitor * _Nonnull)monitor didDeleteSection:(id <NSFetchedResultsSectionInfo> _Nonnull)sectionInfo fromSectionIndex:(NSInteger)sectionIndex;
@end

@class NSDictionary;

/// The <code>CSLocalStorage</code> serves as the Objective-C bridging type for <code>LocalStorage</code>.
/// seealso:
/// <code>LocalStorage</code>
SWIFT_PROTOCOL("_TtP9CoreStore14CSLocalStorage_")
@protocol CSLocalStorage <CSStorageInterface>
/// The <code>NSURL</code> that points to the store file
@property (nonatomic, readonly, copy) NSURL * _Nonnull fileURL;
/// An array of <code>SchemaMappingProvider</code>s that provides the complete mapping models for custom migrations. This is currently only supported for Swift code.
@property (nonatomic, readonly, copy) NSArray * _Nonnull migrationMappingProviders;
/// Options that tell the <code>CSDataStack</code> how to setup the persistent store
@property (nonatomic, readonly) NSInteger localStorageOptions;
/// Called by the <code>CSDataStack</code> to perform actual deletion of the store file from disk. Do not call directly! The <code>sourceModel</code> argument is a hint for the existing store’s model version. Implementers can use the <code>sourceModel</code> to perform necessary store operations. (SQLite stores for example, can convert WAL journaling mode to DELETE before deleting)
- (BOOL)cs_eraseStorageAndWaitWithMetadata:(NSDictionary * _Nonnull)metadata soureModelHint:(NSManagedObjectModel * _Nullable)soureModelHint error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
@end

/// The <code>CSLocalStorageOptions</code> provides settings that tells the <code>CSDataStack</code> how to setup the persistent store for <code>CSLocalStorage</code> implementers.
/// seealso:
/// <code>LocalStorageOptions</code>
typedef SWIFT_ENUM(NSInteger, CSLocalStorageOptions, closed) {
/// Tells the <code>DataStack</code> that the store should not be migrated or recreated, and should simply fail on model mismatch
  CSLocalStorageOptionsNone = 0,
/// Tells the <code>DataStack</code> to delete and recreate the store on model mismatch, otherwise exceptions will be thrown on failure instead
  CSLocalStorageOptionsRecreateStoreOnModelMismatch = 1,
/// Tells the <code>DataStack</code> to prevent progressive migrations for the store
  CSLocalStorageOptionsPreventProgressiveMigration = 2,
/// Tells the <code>DataStack</code> to allow lightweight migration for the store when added synchronously
  CSLocalStorageOptionsAllowSynchronousLightweightMigration = 4,
};


/// The <code>CSMigrationResult</code> serves as the Objective-C bridging type for <code>MigrationResult</code>.
/// seealso:
/// <code>MigrationResult</code>
SWIFT_CLASS("_TtC9CoreStore17CSMigrationResult") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSMigrationResult : NSObject
/// <code>YES</code> if the migration succeeded, <code>NO</code> otherwise
@property (nonatomic, readonly) BOOL isSuccess;
/// <code>YES</code> if the migration failed, <code>NO</code> otherwise
@property (nonatomic, readonly) BOOL isFailure;
/// <code>YES</code> if the migration succeeded, <code>NO</code> otherwise
@property (nonatomic, readonly, copy) NSArray<CSMigrationType *> * _Nullable migrationTypes;
/// The <code>NSError</code> for a failed migration, or <code>nil</code> if the migration succeeded
@property (nonatomic, readonly, strong) NSError * _Nullable error;
/// If the result was a success, the <code>success</code> block is executed with an array of <code>CSMigrationType</code>s that indicates the migration steps completed. If the result was a failure, the <code>failure</code> block is executed with an <code>NSError</code> argument pertaining to the actual error.
/// The blocks are executed immediately as <code>@noescape</code> and will not be retained.
/// \param success the block to execute on success. The block passes an array of <code>CSMigrationType</code>s that indicates the migration steps completed.
///
/// \param failure the block to execute on failure. The block passes an <code>NSError</code> argument that pertains to the actual error.
///
- (void)handleSuccess:(SWIFT_NOESCAPE void (^ _Nonnull)(NSArray<CSMigrationType *> * _Nonnull))success failure:(SWIFT_NOESCAPE void (^ _Nonnull)(NSError * _Nonnull))failure;
/// If the result was a success, the <code>success</code> block is executed with an array of <code>CSMigrationType</code>s that indicates the migration steps completed. If the result was a failure, this method does nothing.
/// The block is executed immediately as <code>@noescape</code> and will not be retained.
/// \param success the block to execute on success. The block passes an array of <code>CSMigrationType</code>s that indicates the migration steps completed.
///
- (void)handleSuccess:(SWIFT_NOESCAPE void (^ _Nonnull)(NSArray<CSMigrationType *> * _Nonnull))success;
/// If the result was a failure, the <code>failure</code> block is executed with an <code>NSError</code> argument pertaining to the actual error. If the result was a success, this method does nothing.
/// The block is executed immediately as <code>@noescape</code> and will not be retained.
/// \param failure the block to execute on failure. The block passes an <code>NSError</code> argument that pertains to the actual error.
///
- (void)handleFailure:(SWIFT_NOESCAPE void (^ _Nonnull)(NSError * _Nonnull))failure;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The <code>CSMigrationType</code> serves as the Objective-C bridging type for <code>MigrationType</code>.
/// seealso:
/// <code>MigrationType</code>
SWIFT_CLASS("_TtC9CoreStore15CSMigrationType") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSMigrationType : NSObject
/// Returns <code>YES</code> if the <code>CSMigrationType</code>’s <code>sourceVersion</code> and <code>destinationVersion</code> do not match. Returns <code>NO</code> otherwise.
@property (nonatomic, readonly) BOOL needsMigration;
/// Returns the source model version for the migration type. If no migration is required, <code>sourceVersion</code> will be equal to the <code>destinationVersion</code>.
@property (nonatomic, readonly, copy) NSString * _Nonnull sourceVersion;
/// Returns the destination model version for the migration type. If no migration is required, <code>destinationVersion</code> will be equal to the <code>sourceVersion</code>.
@property (nonatomic, readonly, copy) NSString * _Nonnull destinationVersion;
/// Returns <code>YES</code> if the <code>CSMigrationType</code> is a lightweight migration. Used as syntactic sugar.
@property (nonatomic, readonly) BOOL isLightweightMigration;
/// Returns <code>YES</code> if the <code>CSMigrationType</code> is a heavyweight migration. Used as syntactic sugar.
@property (nonatomic, readonly) BOOL isHeavyweightMigration;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The <code>CSObjectMonitor</code> serves as the Objective-C bridging type for <code>ObjectMonitor<T></code>.
/// seealso:
/// <code>ObjectMonitor</code>
SWIFT_CLASS("_TtC9CoreStore15CSObjectMonitor") SWIFT_AVAILABILITY(macos,introduced=10.12)
@interface CSObjectMonitor : NSObject
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Implement the <code>CSObjectObserver</code> protocol to observe changes  to a single <code>NSManagedObject</code> instance. <code>CSObjectObserver</code>s may register themselves to a <code>CSObjectMonitor</code>’s <code>-addObjectObserver:</code> method:
/// \code
/// CSObjectMonitor *monitor = [CSCoreStore monitorObject:myObject];
/// [monitor addObjectObserver:self];
///
/// \endcodeseealso:
/// <code>ObjectObserver</code>
SWIFT_PROTOCOL("_TtP9CoreStore16CSObjectObserver_") SWIFT_AVAILABILITY(macos,introduced=10.12)
@protocol CSObjectObserver
@optional
/// Handles processing just before a change to the observed <code>object</code> occurs
/// \param monitor the <code>CSObjectMonitor</code> monitoring the object being observed
///
/// \param object the <code>NSManagedObject</code> instance being observed
///
- (void)objectMonitor:(CSObjectMonitor * _Nonnull)monitor willUpdateObject:(id _Nonnull)object;
/// Handles processing right after a change to the observed <code>object</code> occurs
/// \param monitor the <code>CSObjectMonitor</code> monitoring the object being observed
///
/// \param object the <code>NSManagedObject</code> instance being observed
///
/// \param changedPersistentKeys an <code>NSSet</code> of key paths for the attributes that were changed. Note that <code>changedPersistentKeys</code> only contains keys for attributes/relationships present in the persistent store, thus transient properties will not be reported.
///
- (void)objectMonitor:(CSObjectMonitor * _Nonnull)monitor didUpdateObject:(id _Nonnull)object changedPersistentKeys:(NSSet<NSString *> * _Nonnull)changedPersistentKeys;
/// Handles processing right after <code>object</code> is deleted
/// \param monitor the <code>CSObjectMonitor</code> monitoring the object being observed
///
/// \param object the <code>NSManagedObject</code> instance being observed
///
- (void)objectMonitor:(CSObjectMonitor * _Nonnull)monitor didDeleteObject:(id _Nonnull)object;
@end

@class NSSortDescriptor;

/// The <code>CSOrderBy</code> serves as the Objective-C bridging type for <code>OrderBy</code>.
/// seealso:
/// <code>OrderBy</code>
SWIFT_CLASS("_TtC9CoreStore9CSOrderBy")
@interface CSOrderBy : NSObject <CSDeleteClause, CSFetchClause, CSQueryClause>
/// The list of sort descriptors
@property (nonatomic, readonly, copy) NSArray<NSSortDescriptor *> * _Nonnull sortDescriptors;
/// Initializes a <code>CSOrderBy</code> clause with a single sort descriptor
/// \code
/// MyPersonEntity *people = [transaction
///    fetchAllFrom:CSFromClass([MyPersonEntity class])
///    fetchClauses:@[CSOrderByKey(CSSortAscending(@"fullname"))]]];
///
/// \endcode\param sortDescriptor a <code>NSSortDescriptor</code>
///
- (nonnull instancetype)initWithSortDescriptor:(NSSortDescriptor * _Nonnull)sortDescriptor;
/// Initializes a <code>CSOrderBy</code> clause with a list of sort descriptors
/// \code
/// MyPersonEntity *people = [transaction
///    fetchAllFrom:CSFromClass([MyPersonEntity class])
///    fetchClauses:@[CSOrderByKeys(CSSortAscending(@"fullname"), CSSortDescending(@"age"), nil))]]];
///
/// \endcode\param sortDescriptors an array of <code>NSSortDescriptor</code>s
///
- (nonnull instancetype)initWithSortDescriptors:(NSArray<NSSortDescriptor *> * _Nonnull)sortDescriptors;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (void)applyToFetchRequest:(NSFetchRequest<id <NSFetchRequestResult>> * _Nonnull)fetchRequest;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



/// The <code>CSSQLiteStore</code> serves as the Objective-C bridging type for <code>SQLiteStore</code>.
/// seealso:
/// <code>SQLiteStore</code>
SWIFT_CLASS("_TtC9CoreStore13CSSQLiteStore") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSSQLiteStore : NSObject <CSLocalStorage>
/// Initializes an SQLite store interface from the given SQLite file URL. When this instance is passed to the <code>CSDataStack</code>’s <code>-addStorage*:</code> methods, a new SQLite file will be created if it does not exist.
/// important:
/// Initializing <code>CSSQLiteStore</code>s with custom migration mapping models is currently not supported. Create an <code>SQLiteStore</code> instance from Swift code and bridge the instance to Objective-C using its <code>SQLiteStore.bridgeToObjectiveC</code> property.
/// \param fileURL the local file URL for the target SQLite persistent store. Note that if you have multiple configurations, you will need to specify a different <code>fileURL</code> explicitly for each of them.
///
/// \param configuration an optional configuration name from the model file. If not specified, defaults to <code>nil</code>, the “Default” configuration. Note that if you have multiple configurations, you will need to specify a different <code>fileURL</code> explicitly for each of them.
///
/// \param localStorageOptions When the <code>CSSQLiteStore</code> is passed to the <code>CSDataStack</code>’s <code>addStorage()</code> methods, tells the <code>CSDataStack</code> how to setup the persistent store. Defaults to <code>CSLocalStorageOptionsNone</code>.
///
- (nonnull instancetype)initWithFileURL:(NSURL * _Nonnull)fileURL configuration:(NSString * _Nullable)configuration localStorageOptions:(NSInteger)localStorageOptions;
/// Initializes an SQLite store interface from the given SQLite file name. When this instance is passed to the <code>CSDataStack</code>’s <code>-addStorage*:</code> methods, a new SQLite file will be created if it does not exist.
/// important:
/// Initializing <code>CSSQLiteStore</code>s with custom migration mapping models is currently not supported. Create an <code>SQLiteStore</code> instance from Swift code and bridge the instance to Objective-C using its <code>SQLiteStore.bridgeToObjectiveC</code> property.
/// \param fileName the local filename for the SQLite persistent store in the “Application Support/<bundle id>” directory (or the “Caches/<bundle id>” directory on tvOS). Note that if you have multiple configurations, you will need to specify a different <code>fileName</code> explicitly for each of them.
///
/// \param configuration an optional configuration name from the model file. If not specified, defaults to <code>nil</code>, the “Default” configuration. Note that if you have multiple configurations, you will need to specify a different <code>fileName</code> explicitly for each of them.
///
/// \param localStorageOptions When the <code>CSSQLiteStore</code> is passed to the <code>CSDataStack</code>’s <code>addStorage()</code> methods, tells the <code>CSDataStack</code> how to setup the persistent store. Defaults to <code>[CSLocalStorageOptions none]</code>.
///
- (nonnull instancetype)initWithFileName:(NSString * _Nonnull)fileName configuration:(NSString * _Nullable)configuration localStorageOptions:(NSInteger)localStorageOptions;
/// Initializes an <code>CSSQLiteStore</code> with an all-default settings: a <code>fileURL</code> pointing to a “<Application name>.sqlite” file in the “Application Support/<bundle id>” directory (or the “Caches/<bundle id>” directory on tvOS), a <code>nil</code> <code>configuration</code> pertaining to the “Default” configuration, and <code>localStorageOptions</code> set to <code>[CSLocalStorageOptions none]</code>.
/// important:
/// Initializing <code>CSSQLiteStore</code>s with custom migration mapping models is currently not supported. Create an <code>SQLiteStore</code> instance from Swift code and bridge the instance to Objective-C using its <code>SQLiteStore.bridgeToObjectiveC</code> property.
- (nonnull instancetype)init;
/// The <code>NSURL</code> that points to the SQLite file
@property (nonatomic, readonly, copy) NSURL * _Nonnull fileURL;
/// An array of <code>SchemaMappingProvider</code>s that provides the complete mapping models for custom migrations. This is currently only supported for Swift code.
@property (nonatomic, readonly, copy) NSArray * _Nonnull migrationMappingProviders;
/// Options that tell the <code>CSDataStack</code> how to setup the persistent store
@property (nonatomic, readonly) NSInteger localStorageOptions;
/// The string identifier for the <code>NSPersistentStore</code>’s <code>type</code> property. For <code>CSSQLiteStore</code>s, this is always set to <code>NSSQLiteStoreType</code>.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull storeType;)
+ (NSString * _Nonnull)storeType SWIFT_WARN_UNUSED_RESULT;
/// The configuration name in the model file
@property (nonatomic, readonly, copy) NSString * _Nullable configuration;
/// The options dictionary for the <code>NSPersistentStore</code>. For <code>CSSQLiteStore</code>s, this is always set to
/// \code
/// [NSSQLitePragmasOption: ["journal_mode": "WAL"]]
///
/// \endcode
@property (nonatomic, readonly, copy) NSDictionary * _Nullable storeOptions;
/// Called by the <code>CSDataStack</code> to perform actual deletion of the store file from disk. Do not call directly! The <code>sourceModel</code> argument is a hint for the existing store’s model version. For <code>CSSQLiteStore</code>, this converts the database’s WAL journaling mode to DELETE before deleting the file.
- (BOOL)cs_eraseStorageAndWaitWithMetadata:(NSDictionary * _Nonnull)metadata soureModelHint:(NSManagedObjectModel * _Nullable)soureModelHint error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
@end


/// The <code>CSSectionBy</code> serves as the Objective-C bridging type for <code>SectionBy</code>.
/// seealso:
/// <code>SectionBy</code>
SWIFT_CLASS("_TtC9CoreStore11CSSectionBy") SWIFT_AVAILABILITY(macos,introduced=10.12)
@interface CSSectionBy : NSObject
/// Initializes a <code>CSSectionBy</code> clause with the key path to use to group <code>CSListMonitor</code> objects into sections
/// \param sectionKeyPath the key path to use to group the objects into sections
///
///
/// returns:
/// a <code>CSSectionBy</code> clause with the key path to use to group <code>CSListMonitor</code> objects into sections
+ (CSSectionBy * _Nonnull)keyPath:(NSString * _Nonnull)sectionKeyPath SWIFT_WARN_UNUSED_RESULT;
/// Initializes a <code>CSSectionBy</code> clause with the key path to use to group <code>CSListMonitor</code> objects into sections, and a closure to transform the value for the key path to an appropriate section name
/// \param sectionKeyPath the key path to use to group the objects into sections
///
/// \param sectionIndexTransformer a closure to transform the value for the key path to an appropriate section name
///
///
/// returns:
/// a <code>CSSectionBy</code> clause with the key path to use to group <code>CSListMonitor</code> objects into sections
+ (CSSectionBy * _Nonnull)keyPath:(NSString * _Nonnull)sectionKeyPath sectionIndexTransformer:(NSString * _Nullable (^ _Nonnull)(NSString * _Nullable))sectionIndexTransformer SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class CSSelectTerm;

/// The <code>CSSelect</code> serves as the Objective-C bridging type for <code>Select</code>.
/// seealso:
/// <code>Select</code>
SWIFT_CLASS("_TtC9CoreStore8CSSelect")
@interface CSSelect : NSObject
/// Creates a <code>CSSelect</code> clause for querying <code>NSNumber</code> values.
/// \code
/// NSNumber *maxAge = [CSCoreStore
///    queryValueFrom:CSFromClass([MyPersonEntity class])
///    select:CSSelectNumber(CSAggregateMax(@"age"))
///    // ...
///
/// \endcode\param numberTerm the <code>CSSelectTerm</code> specifying the attribute/aggregate value to query
///
- (nonnull instancetype)initWithNumberTerm:(CSSelectTerm * _Nonnull)numberTerm;
/// Creates a <code>CSSelect</code> clause for querying <code>NSDecimalNumber</code> values.
/// \code
/// NSDecimalNumber *averagePrice = [CSCoreStore
///    queryValueFrom:CSFromClass([MyPersonEntity class])
///    select:CSSelectDecimal(CSAggregateAverage(@"price"))
///    // ...
///
/// \endcode\param decimalTerm the <code>CSSelectTerm</code> specifying the attribute/aggregate value to query
///
- (nonnull instancetype)initWithDecimalTerm:(CSSelectTerm * _Nonnull)decimalTerm;
/// Creates a <code>CSSelect</code> clause for querying <code>NSString</code> values.
/// \code
/// NSString *fullname = [CSCoreStore
///    queryValueFrom:CSFromClass([MyPersonEntity class])
///    select:CSSelectString(CSAttribute(@"fullname"))
///    // ...
///
/// \endcode\param stringTerm the <code>CSSelectTerm</code> specifying the attribute/aggregate value to query
///
- (nonnull instancetype)initWithStringTerm:(CSSelectTerm * _Nonnull)stringTerm;
/// Creates a <code>CSSelect</code> clause for querying <code>NSDate</code> values.
/// \code
/// NSDate *lastUpdate = [CSCoreStore
///    queryValueFrom:CSFromClass([MyPersonEntity class])
///    select:CSSelectDate(CSAggregateMax(@"updatedDate"))
///    // ...
///
/// \endcode\param dateTerm the <code>CSSelectTerm</code> specifying the attribute/aggregate value to query
///
- (nonnull instancetype)initWithDateTerm:(CSSelectTerm * _Nonnull)dateTerm;
/// Creates a <code>CSSelect</code> clause for querying <code>NSData</code> values.
/// \code
/// NSData *imageData = [CSCoreStore
///    queryValueFrom:CSFromClass([MyPersonEntity class])
///    select:CSSelectData(CSAttribute(@"imageData"))
///    // ...
///
/// \endcode\param dataTerm the <code>CSSelectTerm</code> specifying the attribute/aggregate value to query
///
- (nonnull instancetype)initWithDataTerm:(CSSelectTerm * _Nonnull)dataTerm;
/// Creates a <code>CSSelect</code> clause for querying <code>NSManagedObjectID</code> values.
/// \code
/// NSManagedObjectID *objectID = [CSCoreStore
///    queryValueFrom:CSFromClass([MyPersonEntity class])
///    select:CSSelectObjectID()
///    // ...
///
/// \endcode
- (nonnull instancetype)initWithObjectIDTerm;
/// Creates a <code>CSSelect</code> clause for querying <code>NSDictionary</code> of an entity’s attribute keys and values.
/// \code
/// NSDictionary *keyValues = [CSCoreStore
///     queryValueFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     select:[CSSelect dictionaryForTerm:[CSSelectTerm maximum:@"age" as:nil]]];
///
/// \endcode\param term the <code>CSSelectTerm</code> specifying the attribute/aggregate value to query
///
///
/// returns:
/// a <code>CSSelect</code> clause for querying an entity attribute
+ (CSSelect * _Nonnull)dictionaryForTerm:(CSSelectTerm * _Nonnull)term SWIFT_WARN_UNUSED_RESULT;
/// Creates a <code>CSSelect</code> clause for querying <code>NSDictionary</code> of an entity’s attribute keys and values.
/// \code
/// NSDictionary *keyValues = [CSCoreStore
///     queryValueFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     select:[CSSelect dictionaryForTerms:@[
///         [CSSelectTerm attribute:@"name" as:nil],
///         [CSSelectTerm attribute:@"age" as:nil]
///     ]]];
///
/// \endcode\param terms the <code>CSSelectTerm</code>s specifying the attribute/aggregate values to query
///
///
/// returns:
/// a <code>CSSelect</code> clause for querying an entity attribute
+ (CSSelect * _Nonnull)dictionaryForTerms:(NSArray<CSSelectTerm *> * _Nonnull)terms SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The <code>CSSelectTerm</code> serves as the Objective-C bridging type for <code>SelectTerm</code>.
/// seealso:
/// <code>SelectTerm</code>
SWIFT_CLASS("_TtC9CoreStore12CSSelectTerm")
@interface CSSelectTerm : NSObject
/// Provides a <code>CSSelectTerm</code> to a <code>CSSelect</code> clause for querying an entity attribute.
/// \code
/// NSString *fullName = [CSCoreStore
///     queryValueFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     select:CSSelectString(CSAttribute(@"fullname"))
///     fetchClauses:@[[CSWhere keyPath:@"employeeID" isEqualTo: @1111]]];
///
/// \endcode\param keyPath the attribute name
///
- (nonnull instancetype)initWithKeyPath:(NSString * _Nonnull)keyPath;
/// Provides a <code>CSSelectTerm</code> to a <code>CSSelect</code> clause for querying the average value of an attribute.
/// \code
/// NSNumber *averageAge = [CSCoreStore
///     queryValueFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     select:[CSSelect numberForTerm:[CSSelectTerm average:@"age" as:nil]]];
///
/// \endcode<ul>
///   <li>
///     <code>as</code>: the dictionary key to use to access the result. Ignored when the query return value is not an <code>NSDictionary</code>. If <code>nil</code>, the default key “average(<attributeName>)” is used
///   </li>
/// </ul>
/// \param keyPath the attribute name
///
///
/// returns:
/// a <code>CSSelectTerm</code> to a <code>CSSelect</code> clause for querying the average value of an attribute
+ (CSSelectTerm * _Nonnull)average:(NSString * _Nonnull)keyPath as:(NSString * _Nullable)alias SWIFT_WARN_UNUSED_RESULT;
/// Provides a <code>CSSelectTerm</code> to a <code>CSSelect</code> clause for a count query.
/// \code
/// NSNumber *numberOfEmployees = [CSCoreStore
///     queryValueFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     select:[CSSelect numberForTerm:[CSSelectTerm count:@"employeeID" as:nil]]];
///
/// \endcode\param keyPath the attribute name
///
/// \param alias the dictionary key to use to access the result. Ignored when the query return value is not an <code>NSDictionary</code>. If <code>nil</code>, the default key “count(<attributeName>)” is used
///
///
/// returns:
/// a <code>SelectTerm</code> to a <code>Select</code> clause for a count query
+ (CSSelectTerm * _Nonnull)count:(NSString * _Nonnull)keyPath as:(NSString * _Nullable)alias SWIFT_WARN_UNUSED_RESULT;
/// Provides a <code>CSSelectTerm</code> to a <code>CSSelect</code> clause for querying the maximum value for an attribute.
/// \code
/// NSNumber *maximumAge = [CSCoreStore
///     queryValueFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     select:[CSSelect numberForTerm:[CSSelectTerm maximum:@"age" as:nil]]];
///
/// \endcode\param keyPath the attribute name
///
/// \param alias the dictionary key to use to access the result. Ignored when the query return value is not an <code>NSDictionary</code>. If <code>nil</code>, the default key “max(<attributeName>)” is used
///
///
/// returns:
/// a <code>CSSelectTerm</code> to a <code>CSSelect</code> clause for querying the maximum value for an attribute
+ (CSSelectTerm * _Nonnull)maximum:(NSString * _Nonnull)keyPath as:(NSString * _Nullable)alias SWIFT_WARN_UNUSED_RESULT;
/// Provides a <code>CSSelectTerm</code> to a <code>CSSelect</code> clause for querying the minimum value for an attribute.
/// \code
/// NSNumber *minimumAge = [CSCoreStore
///     queryValueFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     select:[CSSelect numberForTerm:[CSSelectTerm minimum:@"age" as:nil]]];
///
/// \endcode\param keyPath the attribute name
///
/// \param alias the dictionary key to use to access the result. Ignored when the query return value is not an <code>NSDictionary</code>. If <code>nil</code>, the default key “min(<attributeName>)” is used
///
///
/// returns:
/// a <code>CSSelectTerm</code> to a <code>CSSelect</code> clause for querying the minimum value for an attribute
+ (CSSelectTerm * _Nonnull)minimum:(NSString * _Nonnull)keyPath as:(NSString * _Nullable)alias SWIFT_WARN_UNUSED_RESULT;
/// Provides a <code>CSSelectTerm</code> to a <code>CSSelect</code> clause for querying the sum value for an attribute.
/// \code
/// NSNumber *totalAge = [CSCoreStore
///     queryValueFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     select:[CSSelect numberForTerm:[CSSelectTerm sum:@"age" as:nil]]];
///
/// \endcode\param keyPath the attribute name
///
/// \param alias the dictionary key to use to access the result. Ignored when the query return value is not an <code>NSDictionary</code>. If <code>nil</code>, the default key “sum(<attributeName>)” is used
///
///
/// returns:
/// a <code>CSSelectTerm</code> to a <code>CSSelect</code> clause for querying the sum value for an attribute
+ (CSSelectTerm * _Nonnull)sum:(NSString * _Nonnull)keyPath as:(NSString * _Nullable)alias SWIFT_WARN_UNUSED_RESULT;
/// Provides a <code>CSSelectTerm</code> to a <code>CSSelect</code> clause for querying the <code>NSManagedObjectID</code>.
/// \code
/// NSManagedObjectID *objectID = [CSCoreStore
///     queryValueFrom:[CSFrom entityClass:[MyPersonEntity class]]
///     select:[CSSelect objectIDForTerm:[CSSelectTerm objectIDAs:nil]]
///     fetchClauses:@[[CSWhere keyPath:@"employeeID" isEqualTo: @1111]]];
///
/// \endcode\param alias the dictionary key to use to access the result. Ignored when the query return value is not an <code>NSDictionary</code>. If <code>nil</code>, the default key “objecID” is used
///
///
/// returns:
/// a <code>SelectTerm</code> to a <code>Select</code> clause for querying the sum value for an attribute
+ (CSSelectTerm * _Nonnull)objectIDAs:(NSString * _Nullable)alias SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The <code>CSSetupResult</code> serves as the Objective-C bridging type for <code>SetupResult</code>.
/// seealso:
/// <code>SetupResult</code>
SWIFT_CLASS("_TtC9CoreStore13CSSetupResult") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSSetupResult : NSObject
/// <code>YES</code> if adding the <code>CSStorageInterface</code> to the <code>CSDataStack</code> succeeded, <code>NO</code> otherwise.
@property (nonatomic, readonly) BOOL isSuccess;
/// <code>YES</code> if adding the <code>CSStorageInterface</code> to the <code>CSDataStack</code> failed, <code>NO</code> otherwise. When <code>YES</code>, the <code>error</code> property returns the actual <code>NSError</code> for the failure.
@property (nonatomic, readonly) BOOL isFailure;
/// A <code>CSStorageInterface</code> instance if the <code>commit</code> operation for the transaction succeeded. Returns <code>nil</code> otherwise.
@property (nonatomic, readonly, strong) id <CSStorageInterface> _Nullable storage;
/// The <code>NSError</code> for a failed <code>commit</code> operation, or <code>nil</code> if the <code>commit</code> succeeded
@property (nonatomic, readonly, strong) NSError * _Nullable error;
/// If the result was a success, the <code>success</code> block is executed with the <code>CSStorageInterface</code> instance that was added to the <code>CSDataStack</code>. If the result was a failure, the <code>failure</code> block is executed with an <code>NSError</code> argument pertaining to the actual error.
/// The blocks are executed immediately as <code>@noescape</code> and will not be retained.
/// \param success the block to execute on success. The block passes a <code>CSStorageInterface</code> instance that was added to the <code>CSDataStack</code>.
///
/// \param failure the block to execute on failure. The block passes an <code>NSError</code> argument that pertains to the actual error.
///
- (void)handleSuccess:(SWIFT_NOESCAPE void (^ _Nonnull)(id <CSStorageInterface> _Nonnull))success failure:(SWIFT_NOESCAPE void (^ _Nonnull)(NSError * _Nonnull))failure;
/// If the result was a success, the <code>success</code> block is executed with a <code>BOOL</code> argument that indicates if there were any changes made. If the result was a failure, this method does nothing.
/// The block is executed immediately as <code>@noescape</code> and will not be retained.
/// \param success the block to execute on success. The block passes a <code>BOOL</code> argument that indicates if there were any changes made.
///
- (void)handleSuccess:(SWIFT_NOESCAPE void (^ _Nonnull)(id <CSStorageInterface> _Nonnull))success;
/// If the result was a failure, the <code>failure</code> block is executed with an <code>NSError</code> argument pertaining to the actual error. If the result was a success, this method does nothing.
/// The block is executed immediately as <code>@noescape</code> and will not be retained.
/// \param failure the block to execute on failure. The block passes an <code>NSError</code> argument that pertains to the actual error.
///
- (void)handleFailure:(SWIFT_NOESCAPE void (^ _Nonnull)(NSError * _Nonnull))failure;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



/// The <code>CSSynchronousDataTransaction</code> serves as the Objective-C bridging type for <code>SynchronousDataTransaction</code>.
/// seealso:
/// <code>SynchronousDataTransaction</code>
SWIFT_CLASS("_TtC9CoreStore28CSSynchronousDataTransaction") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSSynchronousDataTransaction : CSBaseDataTransaction
/// Saves the transaction changes and waits for completion synchronously. This method should not be used after the <code>-commitAndWaitWithError:</code> method was already called once.
/// \param error the <code>CSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// <code>YES</code> if the commit succeeded, <code>NO</code> if the commit failed. If <code>NO</code>, the <code>error</code> argument will hold error information.
- (BOOL)commitAndWaitWithError:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
/// Creates a new <code>NSManagedObject</code> with the specified entity type.
/// \param into the <code>CSInto</code> clause indicating the destination <code>NSManagedObject</code> entity type and the destination configuration
///
///
/// returns:
/// a new <code>NSManagedObject</code> instance of the specified entity type.
- (id _Nonnull)createInto:(CSInto * _Nonnull)into SWIFT_WARN_UNUSED_RESULT;
/// Returns an editable proxy of a specified <code>NSManagedObject</code>. This method should not be used after the <code>-commitAndWait</code> method was already called once.
/// \param object the <code>NSManagedObject</code> type to be edited
///
///
/// returns:
/// an editable proxy for the specified <code>NSManagedObject</code>.
- (id _Nullable)editObject:(NSManagedObject * _Nullable)object SWIFT_WARN_UNUSED_RESULT;
/// Returns an editable proxy of the object with the specified <code>NSManagedObjectID</code>. This method should not be used after the <code>-commitAndWait</code> method was already called once.
/// \param into a <code>CSInto</code> clause specifying the entity type
///
/// \param objectID the <code>NSManagedObjectID</code> for the object to be edited
///
///
/// returns:
/// an editable proxy for the specified <code>NSManagedObject</code>.
- (id _Nullable)editInto:(CSInto * _Nonnull)into objectID:(NSManagedObjectID * _Nonnull)objectID SWIFT_WARN_UNUSED_RESULT;
/// Deletes a specified <code>NSManagedObject</code>. This method should not be used after the <code>-commitAndWait</code> method was already called once.
/// \param object the <code>NSManagedObject</code> type to be deleted
///
- (void)deleteObject:(NSManagedObject * _Nullable)object;
/// Deletes the specified <code>NSManagedObject</code>s.
/// \param objects the <code>NSManagedObject</code>s to be deleted
///
- (void)deleteObjects:(NSArray<NSManagedObject *> * _Nonnull)objects;
@end


/// The <code>CSTweak</code> serves as the Objective-C bridging type for <code>Tweak</code>.
/// seealso:
/// <code>Tweak</code>
SWIFT_CLASS("_TtC9CoreStore7CSTweak") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSTweak : NSObject <CSDeleteClause, CSFetchClause, CSQueryClause>
/// The block to customize the <code>NSFetchRequest</code>
@property (nonatomic, readonly, copy) void (^ _Nonnull block)(NSFetchRequest<id <NSFetchRequestResult>> * _Nonnull);
/// Initializes a <code>CSTweak</code> clause with a closure where the <code>NSFetchRequest</code> may be configured.
/// important:
/// <code>CSTweak</code>’s closure is executed only just before the fetch occurs, so make sure that any values captured by the closure is not prone to race conditions. Also, some utilities (such as <code>CSListMonitor</code>s) may keep <code>CSFetchClause</code>s in memory and may thus introduce retain cycles if reference captures are not handled properly.
/// \param block the block to customize the <code>NSFetchRequest</code>
///
- (nonnull instancetype)initWithBlock:(void (^ _Nonnull)(NSFetchRequest<id <NSFetchRequestResult>> * _Nonnull))block;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (void)applyToFetchRequest:(NSFetchRequest<id <NSFetchRequestResult>> * _Nonnull)fetchRequest;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The <code>CSUnsafeDataModelSchema</code> serves as the Objective-C bridging type for <code>UnsafeDataModelSchema</code>.
/// seealso:
/// <code>UnsafeDataModelSchema</code>
SWIFT_CLASS("_TtC9CoreStore23CSUnsafeDataModelSchema") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSUnsafeDataModelSchema : NSObject <CSDynamicSchema>
/// Initializes a <code>CSUnsafeDataModelSchema</code> from an <code>NSManagedObjectModel</code>.
/// \param modelName the model version, typically the file name of an *.xcdatamodeld file (without the file extension)
///
/// \param model the <code>NSManagedObjectModel</code>
///
- (nonnull instancetype)initWithModelName:(NSString * _Nonnull)modelName model:(NSManagedObjectModel * _Nonnull)model OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
@property (nonatomic, readonly, copy) NSString * _Nonnull modelVersion;
- (NSManagedObjectModel * _Nonnull)rawModel SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class NSManagedObjectContext;

/// The <code>CSUnsafeDataTransaction</code> serves as the Objective-C bridging type for <code>UnsafeDataTransaction</code>.
/// seealso:
/// <code>UnsafeDataTransaction</code>
SWIFT_CLASS("_TtC9CoreStore23CSUnsafeDataTransaction") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSUnsafeDataTransaction : CSBaseDataTransaction
/// Saves the transaction changes asynchronously. For a <code>CSUnsafeDataTransaction</code>, multiple commits are allowed, although it is the developer’s responsibility to ensure a reasonable leeway to prevent blocking the main thread.
/// \param success the block executed if the save succeeds.
///
/// \param failure the block executed if the save fails. A <code>CSError</code> is reported as the argument of the block.
///
- (void)commitWithSuccess:(void (^ _Nullable)(void))success :(void (^ _Nullable)(CSError * _Nonnull))failure;
/// Saves the transaction changes and waits for completion synchronously. For a <code>CSUnsafeDataTransaction</code>, multiple commits are allowed, although it is the developer’s responsibility to ensure a reasonable leeway to prevent blocking the main thread.
/// \param error the <code>CSError</code> pointer that indicates the reason in case of an failure
///
///
/// returns:
/// <code>YES</code> if the commit succeeded, <code>NO</code> if the commit failed. If <code>NO</code>, the <code>error</code> argument will hold error information.
- (BOOL)commitAndWaitWithError:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
/// Rolls back the transaction.
- (void)rollback;
/// Undo’s the last change made to the transaction.
- (void)undo;
/// Redo’s the last undone change to the transaction.
- (void)redo;
/// Immediately flushes all pending changes to the transaction’s observers. This is useful in conjunction with <code>ListMonitor</code>s and <code>ObjectMonitor</code>s created from <code>UnsafeDataTransaction</code>s used to manage temporary “scratch” data.
/// important:
/// Note that unlike <code>commit()</code>, <code>flush()</code> does not propagate/save updates to the <code>DataStack</code> and the persistent store. However, the flushed changes will be seen by children transactions created further from the current transaction (i.e. through <code>transaction.beginUnsafe()</code>)
- (void)flush;
/// Flushes all pending changes to the transaction’s observers at the end of the <code>closure</code>’s execution. This is useful in conjunction with <code>ListMonitor</code>s and <code>ObjectMonitor</code>s created from <code>UnsafeDataTransaction</code>s used to manage temporary “scratch” data.
/// important:
/// Note that unlike <code>commit()</code>, <code>flush()</code> does not propagate/save updates to the <code>DataStack</code> and the persistent store. However, the flushed changes will be seen by children transactions created further from the current transaction (i.e. through <code>transaction.beginUnsafe()</code>)
/// \param block the block where changes can be made prior to the flush
///
- (void)flush:(SWIFT_NOESCAPE void (^ _Nonnull)(void))block;
/// Begins a child transaction where <code>NSManagedObject</code> creates, updates, and deletes can be made. This is useful for making temporary changes, such as partially filled forms.
/// To support “undo” methods such as <code>-undo</code>, <code>-redo</code>, and <code>-rollback</code>, use the <code>-beginSafeWithSupportsUndo:</code> method passing <code>YES</code> to the argument. Without “undo” support, calling those methods will raise an exception.
///
/// returns:
/// a <code>CSUnsafeDataTransaction</code> instance where creates, updates, and deletes can be made.
- (CSUnsafeDataTransaction * _Nonnull)beginUnsafe SWIFT_WARN_UNUSED_RESULT;
/// Begins a child transaction where <code>NSManagedObject</code> creates, updates, and deletes can be made. This is useful for making temporary changes, such as partially filled forms.
/// <ul>
///   <li>
///     prameter supportsUndo: <code>-undo</code>, <code>-redo</code>, and <code>-rollback</code> methods are only available when this parameter is <code>YES</code>, otherwise those method will raise an exception. Note that turning on Undo support may heavily impact performance especially on iOS or watchOS where memory is limited.
///   </li>
/// </ul>
///
/// returns:
/// a <code>CSUnsafeDataTransaction</code> instance where creates, updates, and deletes can be made.
- (CSUnsafeDataTransaction * _Nonnull)beginUnsafeWithSupportsUndo:(BOOL)supportsUndo SWIFT_WARN_UNUSED_RESULT;
/// Returns the <code>NSManagedObjectContext</code> for this unsafe transaction. Use only for cases where external frameworks need an <code>NSManagedObjectContext</code> instance to work with.
/// Note that it is the developer’s responsibility to ensure the following:
/// <ul>
///   <li>
///     that the <code>CSUnsafeDataTransaction</code> that owns this context should be strongly referenced and prevented from being deallocated during the context’s lifetime
///   </li>
///   <li>
///     that all saves will be done either through the <code>CSUnsafeDataTransaction</code>’s <code>-commit:</code> or <code>-commitAndWait</code> method, or by calling <code>-save:</code> manually on the context, its parent, and all other ancestor contexts if there are any.
///   </li>
/// </ul>
- (NSManagedObjectContext * _Nonnull)unsafeContext SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
@end

@class NSPredicate;
@protocol CoreDataNativeType;

/// The <code>CSWhere</code> serves as the Objective-C bridging type for <code>Where</code>.
/// seealso:
/// <code>Where</code>
SWIFT_CLASS("_TtC9CoreStore7CSWhere")
@interface CSWhere : NSObject <CSDeleteClause, CSFetchClause, CSQueryClause>
/// The internal <code>NSPredicate</code> instance for the <code>Where</code> clause
@property (nonatomic, readonly, strong) NSPredicate * _Nonnull predicate;
/// Initializes a <code>CSWhere</code> clause with a predicate that always evaluates to the specified boolean value
/// \code
/// MyPersonEntity *people = [transaction
///    fetchAllFrom:CSFromClass([MyPersonEntity class])
///    fetchClauses:@[CSWhereValue(YES)]]];
///
/// \endcode\param value the boolean value for the predicate
///
- (nonnull instancetype)initWithValue:(BOOL)value;
/// Initializes a <code>CSWhere</code> clause with a predicate using the specified string format and arguments
/// \code
/// NSPredicate *predicate = // ...
/// MyPersonEntity *people = [transaction
///    fetchAllFrom:CSFromClass([MyPersonEntity class])
///    fetchClauses:@[CSWherePredicate(predicate)]];
///
/// \endcode\param format the format string for the predicate
///
/// \param argumentArray the arguments for <code>format</code>
///
- (nonnull instancetype)initWithFormat:(NSString * _Nonnull)format argumentArray:(NSArray<NSObject *> * _Nullable)argumentArray;
/// Initializes a <code>CSWhere</code> clause that compares equality
/// \param keyPath the keyPath to compare with
///
/// \param value the arguments for the <code>==</code> operator
///
- (nonnull instancetype)initWithKeyPath:(NSString * _Nonnull)keyPath isEqualTo:(id <CoreDataNativeType> _Nullable)value;
/// Initializes a <code>CSWhere</code> clause that compares membership
/// \param keyPath the keyPath to compare with
///
/// \param list the array to check membership of
///
- (nonnull instancetype)initWithKeyPath:(NSString * _Nonnull)keyPath isMemberOf:(NSArray<id <CoreDataNativeType>> * _Nonnull)list;
/// Initializes a <code>CSWhere</code> clause with an <code>NSPredicate</code>
/// \param predicate the <code>NSPredicate</code> for the fetch or query
///
- (nonnull instancetype)initWithPredicate:(NSPredicate * _Nonnull)predicate;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (void)applyToFetchRequest:(NSFetchRequest<id <NSFetchRequestResult>> * _Nonnull)fetchRequest;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The <code>CSXcodeDataModelSchema</code> serves as the Objective-C bridging type for <code>XcodeDataModelSchema</code>.
/// seealso:
/// <code>XcodeDataModelSchema</code>
SWIFT_CLASS("_TtC9CoreStore22CSXcodeDataModelSchema") SWIFT_DEPRECATED_MSG("CoreStore Objective-C API will be removed soon.")
@interface CSXcodeDataModelSchema : NSObject <CSDynamicSchema>
/// Initializes an <code>CSXcodeDataModelSchema</code> from an *.xcdatamodeld file URL.
/// \param modelName the model version, typically the file name of an *.xcdatamodeld file (without the file extension)
///
/// \param modelVersionFileURL the file URL that points to the .xcdatamodeld’s “momd” file.
///
- (nonnull instancetype)initWithModelName:(NSString * _Nonnull)modelName modelVersionFileURL:(NSURL * _Nonnull)modelVersionFileURL OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
@property (nonatomic, readonly, copy) NSString * _Nonnull modelVersion;
- (NSManagedObjectModel * _Nonnull)rawModel SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Objective-C Foundation types that are natively supported by Core Data managed attributes all conform to <code>CoreDataNativeType</code>.
SWIFT_PROTOCOL("_TtP9CoreStore18CoreDataNativeType_")
@protocol CoreDataNativeType <NSObject>
@end


SWIFT_CLASS("_TtC9CoreStore22CoreStoreManagedObject")
@interface CoreStoreManagedObject : NSManagedObject
- (nonnull instancetype)initWithEntity:(NSEntityDescription * _Nonnull)entity insertIntoManagedObjectContext:(NSManagedObjectContext * _Nullable)context OBJC_DESIGNATED_INITIALIZER;
@end






@interface NSData (SWIFT_EXTENSION(CoreStore)) <CoreDataNativeType>
@end










@interface NSDate (SWIFT_EXTENSION(CoreStore)) <CoreDataNativeType>
@end








@interface NSDecimalNumber (SWIFT_EXTENSION(CoreStore))
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSAttributeType cs_rawAttributeType;)
+ (NSAttributeType)cs_rawAttributeType SWIFT_WARN_UNUSED_RESULT;
@end














@interface NSManagedObject (SWIFT_EXTENSION(CoreStore)) <CoreDataNativeType>
@end












@interface NSManagedObject (SWIFT_EXTENSION(CoreStore))
/// Provides a convenience wrapper for accessing <code>-primitiveValueForKey:</code> with proper calls to <code>-willAccessValueForKey:</code> and <code>-didAccessValueForKey:</code>. This is useful when implementing accessor methods for transient attributes.
/// \param KVCKey the KVC key
///
///
/// returns:
/// the primitive value for the KVC key
- (id _Nullable)cs_accessValueForKVCKey:(NSString * _Nonnull)KVCKey SWIFT_WARN_UNUSED_RESULT;
/// Provides a convenience wrapper for setting <code>-setPrimitiveValue:</code> with proper calls to <code>-willChangeValueForKey:</code> and <code>-didChangeValueForKey:</code>. This is useful when implementing mutator methods for transient attributes.
/// \param value the value to set the KVC key with
///
/// \param KVCKey the KVC key
///
- (void)cs_setValue:(id _Nullable)value forKVCKey:(NSString * _Nonnull)KVCKey;
/// Re-faults the object to use the latest values from the persistent store
- (void)cs_refreshAsFault;
@end






















@interface NSManagedObjectID (SWIFT_EXTENSION(CoreStore)) <CoreDataNativeType>
@end












@interface NSNull (SWIFT_EXTENSION(CoreStore)) <CoreDataNativeType>
@end






@interface NSNumber (SWIFT_EXTENSION(CoreStore)) <CoreDataNativeType>
@end






@interface NSNumber (SWIFT_EXTENSION(CoreStore))
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSAttributeType cs_rawAttributeType;)
+ (NSAttributeType)cs_rawAttributeType SWIFT_WARN_UNUSED_RESULT;
@end






@interface NSOrderedSet<ObjectType> (SWIFT_EXTENSION(CoreStore)) <CoreDataNativeType>
@end














@interface NSSet<ObjectType> (SWIFT_EXTENSION(CoreStore)) <CoreDataNativeType>
@end










@interface NSString (SWIFT_EXTENSION(CoreStore)) <CoreDataNativeType>
@end




























@interface NSProgress (SWIFT_EXTENSION(CoreStore))
/// Sets a closure that the <code>NSProgress</code> calls whenever its <code>fractionCompleted</code> changes. You can use this instead of setting up KVO.
/// \param closure the closure to execute on progress change
///
- (void)cs_setProgressHandler:(void (^ _Nullable)(NSProgress * _Nonnull))closure;
@end



#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop

#endif

#endif
